Computational Geometry 48 (2015) 554–574

Contents lists available at ScienceDirect

Computational Geometry: Theory and
Applications
www.elsevier.com/locate/comgeo

Fast segment insertion and incremental construction
of constrained Delaunay triangulations ✩
Jonathan Richard Shewchuk, Brielin C. Brown
Department of Electrical Engineering and Computer Sciences, University of California, Berkeley, CA 94720, USA

a r t i c l e

i n f o

Article history:
Available online 29 April 2015
Keywords:
Constrained Delaunay triangulation
-Net
Randomized incremental construction
Computational geometry

a b s t r a c t
The most commonly implemented method of constructing a constrained Delaunay
triangulation (CDT) in the plane is to ﬁrst construct a Delaunay triangulation, then
incrementally insert the input segments one by one. For typical implementations of
segment insertion, this method has a (kn2 ) worst-case running time, where n is the
number of input vertices and k is the number of input segments.
We give a randomized algorithm for inserting a segment into a CDT in expected time
linear in the number of edges the segment crosses. We demonstrate with a performance
comparison that for segments that cross many edges, our algorithm is faster than giftwrapping. We also show that a simple algorithm for segment location, which precedes
segment insertion, is fast enough never to be a bottleneck in CDT construction. A result
of Agarwal, Arge, and Yi implies that randomized incremental construction of CDTs by our
segment insertion algorithm takes expected O(n log n + n log2 k) time. We show that this
bound is tight by deriving a matching lower bound. Although there are CDT construction
algorithms guaranteed to run in O(n log n) time, incremental CDT construction is easier to
program and competitive in practice.
Lastly, we partly extend the analysis (albeit not the linear-time insertion algorithm) to
randomized incremental CDT construction in three dimensions.
© 2015 Elsevier B.V. All rights reserved.

1. Introduction
The constrained Delaunay triangulation (CDT) in the plane, proposed by Lee and Lin [26], is a variant of the well-known
Delaunay triangulation in which speciﬁed edges, sometimes called segments, are constrained to appear. The CDT is as close
to being Delaunay as possible subject to those constraints. In particular, every edge of the CDT either is an input segment or
is locally Delaunay. An edge in a triangulation is locally Delaunay if it is an edge of only one triangle, or it is an edge of two
triangles and the Delaunay triangulation of those triangles’ four vertices includes the edge, as illustrated at left in Fig. 1.
The constraints imposed by CDTs have many uses, including representing boundaries of nonconvex objects, supporting
better interpolation of discontinuous functions, and aiding the enforcement of boundary conditions in ﬁnite element meshes.
The input to a CDT construction algorithm is a planar straight line graph (PSLG), depicted in Fig. 2. A PSLG X is a set of
vertices and segments (constraining edges) that satisﬁes two restrictions: both endpoints of every segment in X are vertices
in X , and a segment in X may intersect other segments and vertices in X only at its endpoints. We seek a triangulation of
the vertices in X that includes every segment in X .

✩
Supported in part by the National Science Foundation under Awards CCF-0635381, IIS-0915462, and CCF-1423560, in part by the University of California
Lab Fees Research Program under Grant 09-LR-01-118889-OBRJ, and in part by an Alfred P. Sloan Research Fellowship.

http://dx.doi.org/10.1016/j.comgeo.2015.04.006
0925-7721/© 2015 Elsevier B.V. All rights reserved.

J.R. Shewchuk, B.C. Brown / Computational Geometry 48 (2015) 554–574

555

Fig. 1. Left: the solid edge e is locally Delaunay. The dashed edge that crosses it is not. Right: The triangle t is constrained Delaunay, despite having two
vertices inside its circumcircle. Bold lines represent segments, which block visibility.

Fig. 2. A planar straight line graph and its constrained Delaunay triangulation.

Throughout this article, every triangulation is understood to be a simplicial complex; thus it is a set containing vertices,
edges, and triangles. A triangulation of a PSLG X is a simplicial complex T ⊃ X such that T contains the same vertices as X
(additional vertices are not permitted) and the union of simplices s∈T s is the convex hull of the vertices in X . Note that
every segment in X is an edge in T .
We assume that the reader is familiar with Delaunay triangulations [14,9]. CDTs use visibility to relax the Delaunay
“empty circle condition.” Two points p and q are visible to each other if the open line segment pq does not intersect a
segment in X . Consider a triangle t in some triangulation of X ; thus t’s vertices are in X and t’s interior intersects no
segment in X . A triangle t is constrained Delaunay if it satisﬁes these two conditions and t’s circumcircle (circumscribing
circle) encloses no vertex in X that is visible from a point in the interior of t, as illustrated at right in Fig. 1. A constrained
Delaunay triangulation (CDT) of X is a triangulation of X in which every triangle is constrained Delaunay, as illustrated at
right in Fig. 2. By the Delaunay Lemma [14,26], a triangulation T of X is a CDT (has all its triangles constrained Delaunay)
if and only if every edge in T that is not a segment in X is locally Delaunay.
Two algorithms are known that construct the CDT of a PSLG with n vertices in O(n log n) time, which is optimal in
the decision tree model of computation. One is a divide-and-conquer algorithm by Chew [10]. Its lineage stretches back to
the ﬁrst Delaunay triangulation algorithm to run in O(n log n) time, the 1975 divide-and-conquer algorithm of Shamos and
Hoey [35], which was subsequently simpliﬁed and elaborated by Lee and Schachter [27] and Guibas and Stolﬁ [17]. The
other is a sweepline algorithm by Seidel [33], which generalizes a Delaunay triangulation algorithm of Fortune [16] to CDTs.
To the best of our knowledge, Seidel’s algorithm has not been implemented, and Chew’s algorithm has been implemented
only once (we do not recall by whom), perhaps because they are complicated. The only CDT construction algorithm widely
used in practice begins by constructing an ordinary Delaunay triangulation ﬁrst, then it inserts the segments into the
triangulation one by one. To insert a segment is to delete all the edges and triangles that intersect its relative interior,
create the new segment, and retriangulate the two polygonal cavities thus created (one on each side of the segment) with
constrained Delaunay triangles, as illustrated in Fig. 3. Note that the cavities might not be simple polygons, because they
might have edges dangling in their interiors, as shown.
Although CDT construction by incremental segment insertion does not run in O(n log n) time, it is popular for good
reasons: it takes advantage of the best existing implementations of (unconstrained) Delaunay triangulation algorithms; it is

556

J.R. Shewchuk, B.C. Brown / Computational Geometry 48 (2015) 554–574

Fig. 3. Inserting a segment into a constrained Delaunay triangulation.

Fig. 4. Top, an n-vertex PSLG for which inserting the k segments in order from left to right causes (kn) structural changes. Bottom, an illustration of how
each segment insertion causes the deletion and creation of (n) edges and (n) triangles in the CDT.

easier to implement than other CDT construction algorithms; its speed is often excellent in practice because many real-world
inputs have few or no segments that cross many edges; and the ability to dynamically update a CDT by inserting a new
segment is itself useful—for instance, in applications that support interactive geometric modeling [21]. Moreover, Agarwal,
Arge, and Yi [1] show that if the k segments are inserted in random order, the expected number of edges and triangles
deleted and created, summed over all segment insertions, is in O(n log2 k). Compare this with the deterministic worst case
of (kn) for the PSLG illustrated in Fig. 4.
In many implementations, each segment is inserted by a naive algorithm that takes O(m2 ) time, where m is the number
of triangles whose interiors intersect the segment, yielding a CDT construction algorithm that takes (kn2 ) time for some
PSLGs with n vertices and k segments. See Anglada [4] for a typical segment insertion algorithm that usually takes (m2 )
time, though it can achieve (m log m) best-case time when it has good luck with evenly subdividing the cavities. (Anglada’s
algorithm is a variant of well-known gift-wrapping algorithms; it gift-wraps triangles from the new segment out.)
Several algorithms have been proposed that compute the CDT of a simple polygon in linear time. A randomized algorithm
of Klein and Lingas [24] computes the CDT in expected O(m) time, and a later algorithm of Chin and Wang [12] runs in
deterministic O(m) time. Both algorithms rely on Chazelle’s algorithm for triangulating a simple polygon in linear time [8],
which is celebrated as a theoretical breakthrough but is considered too complicated for practical use. Lee and Lin [26] give
a simpler O(m log m)-time algorithm that is also simpler than Chew’s or Seidel’s algorithms, as it is specialized for simple
polygons. Kao and Mount [23] give an O(m log m)-time algorithm that, because it is specialized for segment insertion, is
even simpler. Anglada’s quadratic-time segment insertion algorithm remains the easiest to implement.
This article presents a randomized algorithm for inserting a segment into a CDT in expected O(m) time. The algorithm
is much easier to implement than the algorithms by Chew, Seidel, Klein and Lingas, and Chin and Wang. We provide
pseudocode, which we turned into working C code in ﬁve hours.
We also show a matching (n log2 k) lower bound on the number of structural changes during randomized incremental
CDT construction, which resolves the long-standing question of the expected complexity of uniformly randomized incremental segment insertion for worst-case PSLGs. This lower bound is a surprise; we and others had not believed the upper
bound was tight.
Our third contribution is to analyze a simple algorithm for segment location—ﬁnding one triangle deleted when a segment
is inserted—and to show that it is fast enough never to be a bottleneck in CDT construction. Speciﬁcally, its running time is
at worst proportional to the number of structural changes the CDT construction algorithm performs while building the CDT,
even if the insertion order is not randomized.
With fast segment location and linear-time segment insertion, the randomized incremental segment insertion algorithm
constructs the CDT of an n-vertex, k-segment PSLG in expected O(n log n + n log2 k) time. Although this running time falls
short of optimality, experience with incremental CDT construction software shows that segment insertion rarely takes longer
than constructing the initial Delaunay triangulation unless segments that intersect many edges are inserted by quadratictime algorithms like Anglada’s. Incremental segment insertion is likely to remain the most used CDT construction algorithm
long into the future, so we think it is important to provide an understanding of its performance and how to make it run
fast.
Our fourth contribution is to extend some of these results to three dimensions. Some tetrahedral CDTs can be constructed
by ﬁrst constructing a Delaunay triangulation, then incrementally inserting polygons into the CDT. We show that polygon

J.R. Shewchuk, B.C. Brown / Computational Geometry 48 (2015) 554–574

557

Fig. 5. Chew’s algorithm for computing the Delaunay triangulation of a convex polygon deletes vertices from the polygon in a random order to precompute
the information needed for point location, then inserts the vertices in the opposite order.

location, like segment location in the plane, is never the bottleneck in incremental construction of a three-dimensional
CDT. Although an n-vertex CDT can have (n2 ) tetrahedra, we show that for a class of nicely-behaved inputs that never
have more than O(n) tetrahedra during the construction process, the expected total number of structural changes during
randomized incremental CDT construction is in O(n log2 k), as in the plane. Unfortunately, it remains an open question
whether polygons can be inserted in time proportional to the number of structural changes.
Although this article devotes most of its space to analyzing algorithms, an equally important motivation for us is to
demonstrate to working programmers who write triangulation codes (but might not be researchers) that incremental segment insertion is a strong competitor among the known algorithms, and to show them how to avoid the hazard of very
slow performance on the most diﬃcult input PSLGs.
2. Chew’s Delaunay vertex deletion algorithm
Our segment insertion algorithm is closely related to an algorithm of Paul Chew [11] for deleting a vertex from a
Delaunay triangulation in expected O(m) time, where m is the degree of the deleted vertex. The latter algorithm is a good
preparation for understanding the former, more complicated algorithm. Our algorithm also uses Chew’s as a subroutine.
Vertex deletion is an operation that updates a Delaunay triangulation so it has one less vertex and is still Delaunay.
Chew’s algorithm can delete vertices from CDTs as well.
For simplicity, consider the (seemingly easier) problem of constructing the Delaunay triangulation of a convex polygon.
Chew’s algorithm is a randomized incremental insertion algorithm that inserts one vertex at a time into the Delaunay
triangulation. Let V be a sequence listing the m vertices of a convex polygon in counterclockwise order. The algorithm
begins by generating a random permutation of V that dictates the order in which the vertices will be inserted. It constructs
a triangle from the ﬁrst three vertices of the permutation, then inserts the remaining vertices one by one.
Just before a vertex u is inserted, it lies outside the growing triangulation, but only one triangulation edge v w separates
u from the triangulation’s interior. Point location is the task of identifying the edge v w. Next, the algorithm inserts u by ﬁrst
identifying and deleting all the triangles whose circumcircles enclose u. These can be found quickly by a depth-ﬁrst search
from the triangle adjoining v w. Then, by extending new edges from u, the algorithm retriangulates the cavity formed
by taking the union of the deleted triangles and uv w, as illustrated in the right half of Fig. 5. This is essentially the
Bowyer–Watson algorithm [5,19,20,45] for inserting a vertex into a Delaunay triangulation.
The cleverest aspect of Chew’s algorithm is how it performs point location. It does all point location in advance, before
constructing any triangles, by imagining the incremental insertion algorithm running backward in time. Speciﬁcally, imagine
taking the input polygon and removing vertices one by one, reversing the random permutation of V , yielding a shrinking
sequence of convex polygons as illustrated in the left half of Fig. 5. Removing a vertex u has the effect of joining its
neighbors v and w with an edge v w, which is the edge that later will be sought for point location.
The algorithm maintains a circularly-, doubly-linked list of vertices representing the polygon. It walks through a random
permutation of V in backward order, removing vertices from the circularly-linked list until only three remain. The algorithm
constructs a triangle from the three surviving vertices, then inserts the other vertices in the permutation of V in forward
order.
The same algorithm, with no changes, can also retriangulate the cavity evacuated when a vertex is deleted from a
Delaunay triangulation, even though the cavity might not be convex. We will not justify that claim here, except to point out
that Chew’s algorithm is a disguised algorithm for deleting a vertex from a three-dimensional convex hull [25], which is
related by the lifting map [6,32,15] to deleting a vertex from a two-dimensional Delaunay triangulation. On the lifting map,
the Delaunay triangles adjoining a vertex lie on the boundary of a convex polyhedral cone; Chew’s algorithm exploits this
convexity.
Theorem 1. Given an m-vertex polygon, Chew’s algorithm runs in expected O(m) time.
Proof. The point location stage runs in deterministic O(m) time. Chew derives the expected running time of the vertex
insertion stage by backward analysis, an analysis technique that Seidel [34] summarizes thus: “Analyze an algorithm as if it was
running backwards in time, from output to input.”
To simplify the analysis, we assume that every vertex set has a unique Delaunay triangulation, independent of the order
in which the vertices are inserted. This assumption might not hold if there are four cocircular vertices, but there is an easy
way to ﬁx the analysis [9, Section 3.5], which we omit.

558

J.R. Shewchuk, B.C. Brown / Computational Geometry 48 (2015) 554–574
CavityCDT( V )
{ V = v 0 , v 1 , . . . , v m−1 is a sequence of vertices in counterclockwise order around }
{ a cavity evacuated when the segment v 0 v m−1 is inserted. Some vertices in the sequence }
{ are duplicated if there are dangling edges in the cavity. }
1
for i ← 1 to m − 2
2
next[i] ← i + 1
{ The arrays next, prev: [1, m − 2] → [0, m − 1] represent }
3
prev[i] ← i − 1
{
a doubly-linked list of vertex indices. }
←
−−−−−−
→
{ distance[i] is proportional to the distance from v i to the line v 0 v m−1 . }
4
distance[i] ← Orient( v 0 , v i , v m−1 )
{ π [1 . . . m − 2] will always be a permutation of 1 . . . m − 2. }
5
π [i] ← i
6
distance[0] ← 0; distance[m − 1] ← 0
{ Delete the vertices from the polygon in a random order. }
7
for i ← m − 2 downto 2
←
−−−−−−
→
{ Select a vertex to delete that is not closer to v 0 v m−1 than both its neighbors. }
8
repeat
9
j ← a random integer in [1, i ]
10
while distance[π [ j]] < distance[prev[π [ j]]] and distance[π [ j]] < distance[next[π [ j]]]
{ Point location: take the vertex v π [ j ] out of the doubly-linked list. }
11
next[prev[π [ j]]] ← next[π [ j]]
12
prev[next[π [ j]]] ← prev[π [ j]]
{ Move the deleted vertex index π [ j] to follow the live vertices. }
13
Swap π [i] with π [ j]
14
CreateTriangle( v 0 , v π [1] , v m−1 )
{ Create the ﬁrst triangle. }
15
for i ← 2 to m − 2
16
InsertVertex( v π [i ] , v next[π [i ]] , v prev[π [i ]] )
17
if v π [i ] has been marked
18
Call Chew’s algorithm to retriangulate the fan of triangles that have all 3 vertices marked
19
Unmark all the marked vertices

Fig. 6. Expected linear-time algorithm for retriangulating a cavity evacuated by inserting a segment into a constrained Delaunay triangulation. The subroutines InsertVertex and Orient appear in Fig. 7.

Every triangulation of an m-vertex polygon has 2m − 3 edges, each with two endpoints. Imagine deleting a vertex chosen
uniformly at random; in expectation it adjoins 4 − 6/m edges.
With the algorithm running forward in time, the cost of inserting the last vertex is proportional to the number of edges
that adjoin it after it is inserted. The expected number of those edges is less than four. The same reasoning holds for the
other vertices. Summing this cost over all the vertices yields an expected linear running time. ✷
3. Inserting a segment into a CDT
To “insert a segment into a CDT” is to take as input a CDT of a PSLG X and a new segment s to insert, and produce a
CDT of X ∪ {s}. It is meaningful only if X ∪ {s} is a valid PSLG—that is, X already contains the endpoints of s (otherwise, they
must be inserted ﬁrst), and the relative interior of s intersects no segment or vertex in X . This section presents a segment
insertion algorithm similar to Chew’s algorithm. Its expected running time is linear in the number of edges the segment
crosses.
Let T be a CDT of X . If s ∈ T , then T is also a CDT of X ∪ {s}. Otherwise, the algorithm begins by performing segment
location: identifying a triangle in T whose interior intersects s. This can be done with a simple rotary traversal of the triangles adjoining the endpoint of s with lesser degree. In Section 8, we show that this method never increases the asymptotic
running time of CDT construction.
Once one triangle whose interior intersects s is found, the others can be identiﬁed by a simple walk in time linear in
their number. The algorithm deletes these triangles from T . All the other triangles in T remain constrained Delaunay after
s is inserted. Next, the algorithm adds s to the triangulation and retriangulates the two polygonal cavities on each side of s
with constrained Delaunay triangles, as illustrated in Fig. 3.
Let P and Pˆ be the two polygonal cavities; their edges include s. The randomized incremental insertion algorithm
CavityCDT in Figs. 6 and 7 retriangulates P , and a second call to CavityCDT retriangulates Pˆ . Be forewarned that CavityCDT
cannot compute the CDT of an arbitrary polygon; it depends upon the special nature of the cavities evacuated by segment
insertion for its correctness.
CavityCDT differs from Chew’s algorithm in several ways to account for the fact that P is not always convex. First, the
vertices of the segment s are inserted ﬁrst. Second, P might have edges dangling in its interior, like the segment connecting
vertices 5 and 6 in Fig. 8. In this case, imagine an ant walking a counterclockwise circuit of P ’s interior without crossing
any edges; it will visit one or more vertices of P twice. Split each such vertex into two copies and pretend they are two
separate vertices, like vertices 5 and 7 in the ﬁgure. (In rare circumstances, there may be three or more copies of a vertex.)
Third, CavityCDT maintains the invariant that after each vertex insertion, the computed triangulation is the CDT of the
polygon whose boundary is speciﬁed by the subsequence of vertices inserted so far; we call this polygon a subpolygon.
Because CavityCDT maintains a CDT and not merely a Delaunay triangulation, a newly inserted vertex sometimes causes a

J.R. Shewchuk, B.C. Brown / Computational Geometry 48 (2015) 554–574

559

InsertVertex(u , v , w )
{ u is a new vertex we are inserting. Is the triangle uv w constrained Delaunay? }
20
x ← Adjacent( w , v )
{ Find w vx on the other side of the edge v w from u. }
{ The edge v w survives if w vx does not exist or
(u is not inside the circumcircle of w vx and u is on the correct side of the edge v w). }
21
if x = ∅ or (InCircle( w , v , x, u ) ≤ 0 and Orient(u , v , w ) > 0)
22
CreateTriangle(u , v , w )
{ uv w is constrained Delaunay. }
23
else
{ uv w and w vx are not constrained Delaunay. }
24
DeleteTriangle( w , v , x)
{ Flip edge v w → edge ux. }
25
InsertVertex(u , v , x)
26
InsertVertex(u , x, w )
27
if InCircle( w , v , x, u ) ≤ 0
{ For the sake of speed, reuse the computation from Line 21. }
{ w vx is a crossed triangle. }
28
Mark vertices u, v, w, and x to be retriangulated later (in Line 18)
Orient(u , v , w )
{ Returns a positive value if u, v, and w occur in counterclockwise order. }

return det

u1 − w 1
v1 − w1

u2 − w 2
.
v2 − w2

InCircle(u , v , w , x)
{ Positive if x is strictly inside the circle passing through the positively oriented vertices u, v, and w. }

return det

u 1 − x1
v 1 − x1
w 1 − x1

u 2 − x2
v 2 − x2
w 2 − x2

| u − x|2
| v − x|2 .
| w − x|2

Fig. 7. Expected linear-time algorithm for retriangulating a cavity evacuated by inserting a segment into a constrained Delaunay triangulation (continued
from Fig. 6). A triangulation data structure permits Adjacent(u , v ) to look up the third vertex w of a triangle uv w in O(1) expected time, with the
convention that u, v, and w are positively oriented (occur in counterclockwise order); it returns w = ∅ if there is no such triangle. The operations
CreateTriangle and DeleteTriangle add and remove positively oriented triangles in expected O(1) time. These running times can be achieved with a hash
table that maps pairs of vertices to triangles; our implementation achieves them with a tree data structure.

Fig. 8. Computing the constrained Delaunay triangulation of a cavity obtained by inserting a segment s. The cavity has a repeated vertex, numbered 5 and 7,
because of the dangling edge adjoining it. The deletion of vertex 2 creates a self-intersection, but the algorithm works correctly anyway.

triangle to be deleted not because the new vertex lies inside the triangle’s circumcircle, but because the two polygon edges
adjoining the new vertex cut through the triangle. For example, the insertion of vertex 8 in Fig. 8 deletes a triangle whose
circumcircle does not enclose vertex 8. Line 21 of InsertVertex (Fig. 7) accounts for this possibility with an orientation test.
Fourth, unlike in Chew’s algorithm, the insertion of a vertex u can create new triangles that do not adjoin u, as illustrated
in Fig. 9. The three shaded triangles in the top triangulation must be deleted when u is inserted, but u is not inside their
circumcircles. We call triangles with this property crossed triangles. After u’s insertion, the corresponding new triangles
(shaded in the bottom triangulation) may include some that do not adjoin u.
CavityCDT inserts u in a manner that initially connects u to all the vertices of all the deleted triangles. If there are
crossed triangles, CavityCDT subsequently uses Chew’s original algorithm to correctly retriangulate the shaded region (in
expected linear time). We observe few crossed triangles in practice, so the overhead of occasionally invoking Chew’s algorithm is unlikely to have much inﬂuence on the running time. (An alternative, easier to implement, is for CavityCDT to call

560

J.R. Shewchuk, B.C. Brown / Computational Geometry 48 (2015) 554–574

Fig. 9. The shaded triangles in the top triangulation (called crossed triangles) are deleted by u’s insertion despite u not being inside their circumcircles
because the edge u w crosses them. InsertVertex produces the triangles in the middle triangulation, but the shaded triangles are not necessarily constrained
Delaunay. We use Chew’s algorithm to replace them with the shaded triangles in the bottom triangulation, which include two that do not adjoin u.

itself recursively with u w serving as the segment, but we do not know whether this option preserves the expected linear
running time.)
Fifth, a subpolygon might be self-intersecting. Observe in Fig. 8 that deleting vertex 2 from the cavity P creates a subpolygon G in which the edge connecting vertices 1 and 3 crosses the edge connecting vertices 4 and 5, and the subpolygon’s
interior angle at vertex 3 exceeds 360◦ . By some deﬁnitions, G is not actually a polygon, although it is a polygon in the
conventional sense of a looped chain of edges; and its triangulation in Fig. 8 (bottom center) is not a simplicial complex,
because it has triangles that overlap each other. Fortunately, it is like a CDT in two respects: it has all the combinatorial
properties of a triangulation of a polygon—for example, its dual graph is a tree—and every edge is locally Delaunay.
The incremental vertex insertion algorithm works correctly even when these self-intersecting subpolygons arise, subject
to one caveat: it will not correctly insert a vertex at which the polygon’s internal angle is 360◦ or greater. For example, it
cannot triangulate P in Fig. 8 by inserting vertex 6 last, nor triangulate G by inserting vertex 3 last. These vertex insertions
are anticipated and averted during the algorithm’s point location step, when random vertices are deleted from P one by
one until the subpolygon is reduced to a triangle. Hence, the random permutation by which the vertices are inserted is not
chosen uniformly from all permutations of the vertices.
For the sake of speed, CavityCDT does not compute internal angles. Instead, let s¯ be the line that includes the segment s.
It is a property of the cavities created by segment insertion that a subpolygon vertex can have an internal angle of 360◦ or
greater only if that vertex is closer to s¯ than both its neighbors on the subpolygon chain. (We will justify this claim shortly.)
CavityCDT declines to delete from P any vertex with the latter property (see Line 10). Later we will consider a second
reason for this restriction (see Lemma 4).
Line 4 of CavityCDT computes the distance of each vertex of P from s¯ . The point location step (Lines 7–13) deletes
vertices from P one by one, choosing uniformly at random from all the vertices that are not endpoints of s and are not
closer to s¯ than both their neighbors.
Be forewarned that CavityCDT cannot use the same triangulation data structure as the triangulation in which the segment s is being inserted, because CavityCDT sometimes temporarily creates triangles that conﬂict with those outside the
cavity. For example, in Fig. 8 the triangulation outside the cavity probably includes an edge connecting vertices 7 and 9,
which is an edge of two triangles. CavityCDT temporarily creates a third triangle with this edge when it ﬁrst inserts vertex 9. To avoid corrupting the data structure, CavityCDT requires the use of a separate, initially empty triangulation data
structure. The ﬁnal triangles must subsequently be copied to the main triangulation.
4. The speed and correctness of C AVIT YCDT
To analyze CavityCDT, we must answer several questions: how do we understand a self-intersecting polygon? What does
it mean for it to have a triangulation or a CDT? Does its CDT obey the same rules as a traditional CDT, such as the Delaunay
Lemma? We will answer these questions by deﬁning subpolygons to be topological spaces we call multisheet polygons, which
are constructed by gluing ordinary polygon-shaped topological spaces together along their edges.
Before discussing those foundations, we take a brief detour to analyze the running time of CavityCDT. The following
proof is not yet complete, because it relies on a fact about CDTs of subpolygons (the forthcoming Lemma 3) whose proof

J.R. Shewchuk, B.C. Brown / Computational Geometry 48 (2015) 554–574

561

Fig. 10. At left, each vertex has a sightline. Note that vertices 5 and 7 have different sightlines, although they are really a single repeated vertex. A selfintersecting polygon (center) can be interpreted topologically as several polygons glued together along their sightlines (right).

we must delay until we develop an understanding of multisheet polygons. The proof also relies implicitly on the fact that
CavityCDT and InsertVertex work correctly. But the core argument is simple, so we put it up front.
Theorem 2. Given an m-vertex cavity, CavityCDT runs in expected O(m) time.
Proof. The expected cost of InsertVertex is proportional to the number of edges adjoining the newly inserted vertex u
plus the number of newly created triangles that do not adjoin u. We bound these numbers separately, both by backward
analysis.
Every triangulation of an m-vertex polygon has m − 2 triangles and m − 3 interior edges. At least (m − 1)/2 vertices
are eligible to be the ﬁrst vertex deleted during point location and the last vertex inserted. One of those vertices is chosen
uniformly at random; in expectation it adjoins at most 2(m − 3)/((m − 1)/2) < 4 interior edges, thus fewer than 6 edges
total.
When the insertion of a new vertex u causes the creation of a triangle t that does not adjoin u, as illustrated in Fig. 9, it
happens because a new subpolygon edge adjoining u entirely crosses t’s circumcircle and hides one or more vertices inside
t’s circumcircle. Consider CavityCDT running backward in time; what is the probability that a triangle t will be deleted
during the deletion of a randomly chosen vertex u that is not a vertex of t? The forthcoming Lemma 3 states that there at
most two vertices, besides the vertices of t, whose deletion could expose t to a vertex, thereby deleting t. The probability
that u is one of those two vertices is at most 4/(m − 1). Summing this probability over the m − 2 triangles, we ﬁnd that
the expected number of deleted triangles not adjoining u is less than 4.
Thus, forward in time, the expected cost of inserting each vertex is constant. Summing this cost over all the vertices
yields an expected linear running time. ✷
Before proving the correctness of the algorithm CavityCDT, we must make sense of self-intersecting polygons and their
triangulations. The original cavity P has a special property that enables CavityCDT to work despite the possibility of selfintersecting subpolygons: P is included in a union of triangles that cross the segment s. Therefore, each vertex v i has a
sightline b i : a line segment connecting v i to s strictly through P ’s interior, depicted in Fig. 10. We choose each sightline to
be a subset of an edge that was deleted to make way for s; these sightlines do not intersect each other.
A self-intersecting subpolygon G can be understood as a topological space deﬁned by gluing ordinary quadrilaterals and
triangles together along the sightlines, as illustrated. We call these constructions multisheet polygons because they can be
assembled from multiple sheets of paper taped together. In such a multisheet polygon, two points with the same Euclidean
coordinates are not necessarily the same point; they may be in different, overlapping quadrilaterals or triangles. We triangulate a multisheet polygon by subdividing it into triangles that form the topological space G when they are glued together
along shared edges. We call this triangulation a CDT if all its edges are locally Delaunay.
One consequence of G’s sightlines is that for any vertex v of G at which the internal angle is 360◦ or greater (e.g.,
vertex 3 or 6 in Fig. 10), both v’s neighbors on G’s boundary chain are further from s¯ (the aﬃne hull of s) than v is—each
because the other neighbor has a valid sightline. This observation justiﬁes the algorithm’s use of the latter property to
screen out vertices with the former property in Lines 8–10.
Our correctness proof for CavityCDT relies on a constrained version of the famous Delaunay Lemma. In 1934, Boris
Delaunay [14] showed that a triangulation of a point set is Delaunay (has every triangle Delaunay) if and only if every edge
is locally Delaunay. In 1986, Lee and Lin [26] showed that a triangulation of a PSLG is constrained Delaunay (has every
triangle constrained Delaunay) if and only if every edge is locally Delaunay except perhaps the PSLG segments.
This Constrained Delaunay Lemma extends to a multisheet polygon G as follows. Two points p , q ∈ G are said to be
visible to each other if there is a path from p to q in G that is a straight line segment. Observe that two distinct points
in G can lie at the same position in Euclidean space yet not be visible to each other, because the shortest path connecting
them in G goes around a corner. With this deﬁnition of “visible,” the deﬁnition of “constrained Delaunay triangle” in the
Introduction applies to triangulations of multisheet polygons. It is easy to extend the proof of Lee and Lin to show that a
triangulation of a multisheet polygon has every triangle constrained Delaunay if and only if every edge is locally Delaunay.
We are ready to complete the proof of Theorem 2.
Lemma 3. Consider a subpolygon G whose CDT contains a triangle t. Imagine CavityCDT running backward in time; suppose a vertex
of G is deleted. Besides t’s vertices, there are at most two other vertices of G whose deletion would delete t.

562

J.R. Shewchuk, B.C. Brown / Computational Geometry 48 (2015) 554–574

Fig. 11. A subpolygon G in which the deletion of a vertex (not shown) has exposed a vertex v f inside the circumcircle C of a triangle t, so t is no longer
constrained Delaunay. The dashed lines are sightlines. The conﬁguration depicted here is impossible because v g does not have a sightline.

Proof. Let C be t’s circumcircle. As t is constrained Delaunay (with respect to G), no vertex of G is both strictly inside C
and visible from the interior of t. Suppose that the deletion of some vertex u of G causes t to be deleted, but u is not a
vertex of t, as in Fig. 9. Then G has a vertex (such as v in Fig. 9) that is strictly inside C and becomes visible from t when
u is deleted.
Let v i and v j be the vertices of t with the least index i and the greatest index j. The edge v i v j of t cuts G into
two multisheet polygons, one having vertices numbered between i and j and one having the remaining vertices and the
segment s, as illustrated in Fig. 11. Each vertex’s sightline can cross v i v j at most once: each vertex of G in the range
v i +1 , v i +2 , . . . , v j −1 is visible from the interior of t because its sightline passes through t, but no other vertex’s sightline
intersects t’s interior. As t is constrained Delaunay, no vertex of G in the range v i , v i +1 , . . . , v j is strictly inside C .
Let v g be the vertex of G with the greatest index g < i such that v g is strictly inside C , if such a vertex exists, as
illustrated in Fig. 11. Let q be an arbitrary point in the interior of t. As t is constrained Delaunay, v g is not visible from q.
As G is simply connected, there is a unique shortest path from q to v g through G; as G is a multisheet polygon that does
not include a straight path from q to v g , the shortest path is composed of two or more line segments. Let v h be the vertex
where this path ﬁrst turns (hence v h is visible from q). Symmetrically, let v l be the vertex of G with the least index l > j
such that v l is strictly inside C , if such a vertex exists, and let v k the ﬁrst vertex on the shortest path from q to v l , as
illustrated. Observe that g < h ≤ i < j ≤ k < l.
As v h is visible from q, v h is not strictly inside C . Let be the line through q and v h , and consider a line segment e ⊂
that extends from v h directly away from q (extending the ﬁrst segment of the shortest path) until it cuts G into two simply
connected multisheet polygons, as illustrated in Fig. 11. The polygon on one side of e has the vertex v g , and the polygon on
the other side includes the triangle t. Observe that no part of e is inside C (because q is inside C and v h is not).
Consider any vertex v f of G that is strictly inside C . We claim that v f can become visible from the interior of t only if
v h or v k is deleted; this claim establishes the lemma. Suppose for the sake of contradiction that there exists a subpolygon
G of G that retains the vertices v f , v h , and v k and the vertices of t, but within G , v f is visible from some point q in t’s
interior—that is, the multisheet polygon G includes the line segment v f q . By our deﬁnitions of v g and v l , either f ≤ g or
f ≥ l; suppose without loss of generality that f ≤ g. (The symmetric case, in which f ≥ l, can be treated with the same
reasoning in mirror image.)
As f < h ≤ i, v h ’s sightline bh separates v f from t in G . Thus the line segment v f q crosses bh . We claim that v f q also
crosses bh . To see this, observe that bh must cross the entire triangle qq v f , because qq v f is strictly inside C , v h is not
inside C , and the other endpoint of bh lies on the segment s and so cannot be in the interior of qq v f . But bh cannot
intersect qq , because bh does not intersect t’s interior. Therefore, bh crosses the other two edges of qq v f . It follows that
v f q crosses bh as claimed, so v f is on the same side of as bh is. This implies that the line segment e separates the portion
of G containing v g from the portion containing v f (and thus f = g).
These relationships impose irreconcilable constraints on v g ’s sightline. The sightline for v g terminates on the segment s
between the sightlines for v f and v h , and the sightlines do not intersect each other. Hence v g ’s sightline starts at v g , which
is inside C ; then it crosses e, which is outside C ; and then it crosses v f q, which is inside C . But a sightline is straight; it
cannot exit and reenter C . The lemma follows by contradiction. ✷
Next, we justify the use of Chew’s algorithm to ﬁx part of the triangulation (Line 18 of CavityCDT) when the insertion
of a vertex u causes the deletion of crossed triangles whose circumcircles do not enclose u. We will show (see Lemma 4
below) that these crossed triangles always form a fan adjoining a single vertex v, shaded at left in Fig. 9. The polygon that
we retriangulate with Chew’s algorithm (shaded at right in Fig. 9) is not necessarily convex, so we must justify why Chew’s
algorithm will always succeed. Recall that Chew’s algorithm is known to work correctly for retriangulating a cavity created
when a vertex is deleted from a Delaunay triangulation (and more generally, for deleting a vertex from a three-dimensional
convex hull [25]). The triangles in the fan adjoining v are separated by locally Delaunay edges. With reference to the ﬁgure,
if we add the triangle vuz to the fan, the edge v z is locally Delaunay as well, because the fan triangles are crossing
triangles whose circumcircles do not enclose u. The polygon we are retriangulating is the polygon obtained by deleting v.
(On the lifting map, v is lifted to the apex of a convex cone in three dimensions. The fact that the lifted vertices of the fan
are in convex position from v’s point of view is the precondition for Chew’s algorithm to work correctly.) Therefore, Chew’s
algorithm correctly retriangulates the fan.

J.R. Shewchuk, B.C. Brown / Computational Geometry 48 (2015) 554–574

Fig. 12. An impossible conﬁguration: upon the insertion of u, a crossed triangle t has a vertex x above

563

that is not u’s neighbor on the subpolygon chain.

To see that the crossed triangles always form this fan conﬁguration, suppose without loss of generality that s is horizontal, as in Fig. 12, with the cavity above s and the vertex indices increasing from 0 at the right endpoint of s to m − 1
at the left endpoint. Let be the horizontal line (parallel to s) through u. By design, when u is inserted, its two neighbors
(v and w) on the subpolygon G cannot both be above . Suppose without loss of generality that u’s neighbor w, whose
index is less than u’s index, is on or below . Because there is a crossed triangle, u is a concave vertex of G, so u’s other
neighbor v (with greater index) must be strictly above .
Lemma 4. Given the suppositions stated above, the crossed triangles form a fan of triangles sharing vertex v, and their other vertices
have indices less than u’s index.
Proof. Let t be a crossed triangle. It has at least one vertex x whose index is greater than u’s and one vertex y whose
index is less. (If every vertex of t had a greater index, t would be protected from u by v’s sightline; if every vertex of t had
a lesser index, t would be protected from u by w’s sightline.) Suppose for the sake of contradiction that x = v, as Fig. 12
shows. Either y = w or the triangle edge xy crosses the subpolygon edge u w, so y lies on or below . As xy also crosses
the subpolygon edge uv, x lies strictly above .
Before s was inserted, v was connected by an edge of the CDT to a vertex v on the other side of s, so there existed
a circle C through v and v that enclosed no vertex visible from the relative interior of the edge v v . The portion of v v
terminating at s is a sightline for v in the original cavity P and in every subpolygon of P . Both u and x are visible (within P )
from the point v v ∩ s, so neither u nor x is inside C . There is a point in the interior of t from which v is visible, because v’s
sightline intersects t’s interior. As t is constrained Delaunay (with respect to the polygon just before u is inserted), v is not
inside t’s circumcircle C . As t is a crossed triangle, u is not inside C either.
The vertices v and x are above , and v and y are below or on , so both circles C and C (circumscribing v v and xy)
intersect , as illustrated. Neither circle encloses u; C intersects to the left of u, and C intersects to the right of u (both
possibly touching u). The edges v v and xy cross each other above , so v is outside C and y is outside C . It is impossible
to simultaneously satisfy the constraints that v v and xy cross each other, a circle C through v and v encloses neither x
nor y, and a circle C = C through x and y encloses neither v nor v . The result follows by contradiction. ✷
Our correctness proof uses the constrained Delaunay property of the triangles before each vertex insertion as a precondition to guarantee the locally Delaunay property of the edges after each vertex insertion. By the Constrained Delaunay
Lemma, the latter property implies that the former holds at the beginning of the next vertex insertion.
Theorem 5. CavityCDT correctly constructs the CDT of a cavity evacuated by the insertion of a segment into a CDT.
Proof. Let T and T be the triangulation before and after a top-level call to the recursive procedure InsertVertex inserts
a new vertex u and Line 18 of CavityCDT ﬁxes the marked triangles (if necessary). Let G and G be the corresponding
subpolygons without and with u. We will show that if T is a CDT of G , then T is a CDT of G. The result follows by
induction on the sequence of vertex insertions.
It is straightforward to check that a top-level call to InsertVertex is equivalent to gluing a new triangle uv w onto an
edge v w of T , then repeatedly checking each edge that is opposite the new vertex u in some triangle (initially the edge
v w, later other edges that are exposed by ﬂips) and ﬂipping any such edge that is not locally Delaunay or forms a fold in
the triangulation (Line 21 of InsertVertex). Every edge created by a ﬂip has the vertex u, and every vertex of every triangle
deleted by a ﬂip gets connected to u.
Each InsertVertex call maintains the invariant that the set of stored triangles forms a combinatorial triangulation of a
polygon—speciﬁcally, the dual graph of the triangulation is a tree whose leaves correspond to the edges of the polygon in
circular order. Gluing on a new triangle is equivalent to replacing a leaf of the dual tree with a new degree-three node and
two new leaves. Edge ﬂips correspond to tree rotations.
If gluing uv w onto T does not create a fold at v w, then the modiﬁed triangulation is immediately a triangulation
of G. Otherwise, pretend that the algorithm ﬂips only fold edges until none survive, then ﬂips edges that are not locally
Delaunay. (CavityCDT actually ﬂips the edges in a different order, but this does not change the ﬁnal product.) Observe that

564

J.R. Shewchuk, B.C. Brown / Computational Geometry 48 (2015) 554–574

Fig. 13. As

w vx was constrained Delaunay before u was inserted, ux is locally Delaunay.

Fig. 14. Constrained Delaunay triangulations of our input cavities, collinear or jittered.

u is safely conﬁned between the sightlines of v and w; no other vertex lies between these sightlines, so no vertex can
lie inside the inverted triangle uv w. It is straightforward to see that there is only one fold edge at any given time and
the ﬂips of the fold edges collectively remove uv w from G , yielding G. Subsequent ﬂips do not change the underlying
topological space of the triangulation, so it remains a triangulation of G.
To show that the updated triangulation T is constrained Delaunay, we show that all its edges are locally Delaunay.
Consider an edge ux created because the InCircle test in Line 21 found that the new vertex u is inside the circumcircle of a
triangle w vx ∈ T ; we wish to show that ux is locally Delaunay in T . Let uxy and xuz be the triangles in T of which
ux is an edge. The vertices y and z are visible (within G ) from the interior of w vx, because they are visible (within G)
from every point on ux, which passes through the interior of w vx as Fig. 13 shows. As T is a CDT, w vx is constrained
Delaunay (prior to the insertion of u), so neither y nor z is inside the circumcircle of w vx. Let C be the circle that passes
through u and x and is tangent to the circumcircle of w vx at x, as illustrated. As the circumcircle encloses C , neither y
nor z is inside C , so ux is locally Delaunay in T as claimed.
Let us categorize the edges of T and show they are all locally Delaunay. By the foregoing argument, every edge adjoining
u because of the Incircle test in Line 21 is locally Delaunay. Every edge that adjoins the same two triangles in T it adjoined
in T is locally Delaunay because it was locally Delaunay in T . Every edge that adjoins one old triangle surviving from T
and one triangle new to T is locally Delaunay either because the Incircle test in Line 21 chose not to ﬂip it or because the
new triangle replaces a crossing triangle after a vertex stopped being visible. Every edge on the boundary of G is locally
Delaunay because it is an edge of only one triangle. The only edges that ﬁt none of these categories are the new edges
created by Line 18 of CavityCDT, which are locally Delaunay by the correctness of Chew’s algorithm. Therefore, every edge
in T is locally Delaunay, and by the Constrained Delaunay Lemma, T is a CDT. ✷
5. A comparison of two cavity retriangulation implementations
We have implemented CavityCDT and Anglada’s gift-wrapping algorithm [4] so that we could compare their speeds on
cavities of different sizes. Both implementations use Shewchuk’s ﬂoating-point Orient and InCircle predicates [36], which
are fast despite being robust. We timed two kinds of cavity, illustrated in Fig. 14: cavities in which all the vertices are
collinear except the segment endpoints, and perturbed versions of those cavities in which the vertices are jittered by random
vertical movements proportional to the distances between the vertices. Although these examples do not represent the
variety of cavities that can come up in practice, they are representative of the most common ways that the cavity geometry
inﬂuences the running times. Collinear points, which occur frequently in practice, bring out the worst of gift-wrapping’s
quadratic running time. Jittered vertices hide the quadratic growth until the number of vertices is greater, because the
gift-wrapping algorithm has more luck ﬁnding balanced subdivisions of small recursive subproblems.
Table 1 tabulates average running times and numbers of predicate calls for the two algorithms. Calls to Orient in Line 4
of CavityCDT are not counted because we optimized Line 4 by taking advantage of subexpressions that are reused every
time it iterates and by not using exact arithmetic. We optimized Line 21 to reduce the number of Orient tests by taking
advantage of the fact that if a call to InsertVertex ﬁnds that its input triangle uv w has positive orientation, all its
recursive calls to InsertVertex will also have positively oriented input triangles that do not require testing.
Given the cavities with collinear vertices as input, CavityCDT becomes faster than gift-wrapping for 30 vertices or more,
and the advantage grows rapidly. Given the jittered cavities, CavityCDT is faster for 85 vertices or more. We observe that
CavityCDT performs fewer InCircle calls on average for 8 or more vertices. In a higher-precision implementation with
expensive InCircle calls, the balance would shift further in favor of CavityCDT.
Because both algorithms are easy to implement, a CDT construction program can choose between them according to
the cavity size. We grant that cavities of 85 vertices or more are a small minority of those that arise in real-world CDT

J.R. Shewchuk, B.C. Brown / Computational Geometry 48 (2015) 554–574

565

Table 1
Timings for CavityCDT and Anglada’s gift-wrapping algorithm compiled by “gcc -O3” on a MacBook Pro with a 3.06 GHz Intel dual core, 8 GB memory
(1.07 GHz DDR3 SDRAM), and a 6 MB level-two cache. Each number is an average over 10,000 runs with different jittering for each run.
Vertices

Anglada

CavityCDT

time (μs)

InCircle tests

time (μs)

InCircle tests

Orient tests
(Line 21 only)

16
196
2401
249,001

1.29
4.20
14.14
152.65

13.02
67.07
271.00
2959.48

7.78
43.01
178.14
1968.93

1.53
16.26
19.10
180.63

11.03
161.39
191.48
1920.00

7.17
106.04
125.84
1268.00

Cavities in which most
vertices are collinear

10
30
100
1000

0.41
4.20
47.27
4748.62

Jittered cavities

10
85
100
1000

0.57
16.26
20.68
719.67

14.41
620.04
804.34
32,184.86

construction, but it would take just one segment that crosses 100,000 edges to make one regret not having the linear-time
algorithm as an option.
6. The cost of randomized incremental segment insertion
Agarwal, Arge, and Yi [1] show that when k segments are inserted into an n-vertex CDT in random order, the total
expected number of structural changes (triangles and edges created and deleted) is in O(n log2 k). For completeness, we
reprise their analysis, ﬁlling in many missing details. In Section 7, we exhibit a PSLG for which this bound is tight. Thus, if
an O(n log k)-time incremental segment insertion algorithm exists, it will require a smarter insertion order, not just a better
analysis.
Let X be a PSLG with n vertices and k segments. Let S be the set of segments in X . We use the theory of -nets to
bound the expected maximum number of segments in X that a line segment in the plane can cross without crossing any
segment in X that has already been inserted. Different line segments in the plane can intersect different subsets of S, but
unless k is small, not all 2k subsets are possible. The plane imposes a structure such that the number of possible subsets is
polynomial in k.
Lemma 6. Let S be a set of k non-crossing segments in the plane. Consider the sequence of segments in S whose relative interiors
intersect a ﬁxed line, written in the order of the intersection points. Let Q be the set of all such sequences, for all lines in the plane, with
the proviso that a sequence and its reverse are considered equivalent and are not counted as distinct members of Q . The cardinality of
Q is at most 8k2 + 1.
Proof. We use the standard planar geometric duality by which a point p = ( p x , p y ) dualizes to a line p ∗ with the formula
y = p x x − p y , and vice versa. Planar duality preserves incidences between points and lines, so if a primal point p lies on
a primal line , then the dual point ∗ lies on the dual line p ∗ . Let U be the set of vertices of the segments in S; then
|U | ≤ 2k. Vertical lines do not have duals in this formulation, so assume without loss of generality that the coordinate
system is rotated so that no two vertices in U have the same x-coordinate. Hence, every vertical line can be tilted slightly
so that it is not perfectly vertical but it intersects the same segment interiors as before.
Let A be the arrangement (expressed as a polygonal complex) formed by the lines dual to the vertices in U . The total
number of faces of all dimensions in A —vertices, edges, and 2-faces—is at most 2(2k)2 + 1 = 8k2 + 1 [44]. If two primal lines
1 and 2 dualize to points in the same face of A , it is possible to translate and rotate 1 to 2 without causing it to pass
over a vertex in U or change its incidences with the vertices in U ; it follows that 1 and 2 intersect the same segments in
S in the same order. Therefore, for every sequence of segments Q ∈ Q , there is a face of A whose interior points all dualize
to lines that generate the sequence Q . It follows that the number of sequences in Q is less than or equal to the number of
faces of A . ✷
Lemma 7. Let S be a set of k non-crossing segments in the plane. For every possible line segment e in the plane, consider the subset of
segments in S whose relative interiors intersect e. Let M be the set of all such subsets, for all line segments in the plane. The cardinality
of M is at most f (k), where f (k) = k(k + 1)(8k2 + 1)/2 + 1.
Proof. The sequence of segments in S whose relative interiors intersect a line segment is an interval taken from the sequence of segments whose relative interiors intersect a line. By Lemma 6, there are at most 8k2 + 1 such sequences, each
having length at most k. A sequence of length k has k(k + 1)/2 nonempty intervals. We add one for the empty set. ✷
For our purposes, the exact bound given by Lemma 7 is not important; it suﬃces that the bound is polynomial, rather
than exponential, in k.

566

J.R. Shewchuk, B.C. Brown / Computational Geometry 48 (2015) 554–574

Next, we reprise a famous result of Haussler and Welzl [18] on -nets. Let S 1 and S 2 be two random sequences obtained
by taking i independent samples from S with replacement (hence segments may be repeated). For some ∈ (0, 1) and
k = | S |, let E be the event that there exists a line segment e that does not intersect any segment in S 1 , but e intersects
at least k segments in S. If E does not occur, S 1 is said to be an -net for S. We want to show that E is very unlikely
when i is suﬃciently large, thus S 1 is very likely to be an -net. Let E + be the event that there exists a line segment e that
does not intersect any segment in S 1 , but intersects at least k segments in S and at least i − 1 segments in S 2 . (Repeated
segments in S 2 may be counted multiple times.) The following lemma shows that event E usually entails event E + .
Lemma 8. (Adapted from Haussler and Welzl [18], Lemma 3.4.) Pr[ E ] < 2 Pr[ E + ].
Proof. Suppose that event E occurs; then we will show that E + also occurs with probability at least 1/2. Event E implies
that there exists a line segment e that intersects at least k of the k segments in S. Let γ be the number of segments in S 2
that e intersects; if γ ≥ i − 1, then event E + also occurs. Because S 2 is chosen by randomly choosing i segments from S
with replacement, γ is a binomial random variable with expectation i. Let η be the median value of γ —the lesser median
if there are two medians. Kaas and Buhrman [22] show that for any binomial distribution,
i ≤ η ≤ i . Therefore, the
probability that event E + also occurs when E occurs is

Pr [γ ≥ i − 1] ≥ Pr [γ ≥

i ] ≥ Pr [γ ≥ η] > 1/2.

Thus Pr[ E + ] = Pr[ E ] · Pr[ E + | E ] > Pr[ E ]/2.

✷

Let E ∗ be the event that there exists a line segment e that intersects no segment in S 1 , but intersects at least
segments in S 2 .

i−1

Lemma 9. (Adapted from Haussler and Welzl [18], Lemma 3.5.) Pr[ E + ] ≤ Pr[ E ∗ ] ≤ f (2i ) 21− i , where f ( j ) = j ( j + 1)(8 j 2 + 1)/2 + 1.
Proof. The ﬁrst inequality follows because event E + implies event E ∗ . For the second inequality, imagine sampling 2i
segments from S with replacement to form a sequence S 12 , then randomly choosing i of those segments to form S 1 ; the
remainder form S 2 .
Let e be a ﬁxed line segment in the plane, and let c be the number of segments that intersect e among the 2i segments
in S 12 . The line segment e can trigger the event E ∗ only if none of those c segments are chosen for S 1 , which happens with
probability

2i − c

2i

i

i

=

i
2i

·

i−1
2i − 1

···

i−c+1
2i − c + 1

≤ 2−c .

Moreover, e can trigger E ∗ only if c ≥ i − 1, so the probability that e triggers E ∗ is at most 21− i . (The magic of this upper
bound is that it is independent of how many segments in S intersect e.)
Now, consider the probability that any line segment in the plane triggers E ∗ . By Lemma 7, there are at most f (2i )
subsets of S 12 that a line segment e can pick out. If two line segments intersect exactly the same segments in S 12 , then
either both of them trigger E ∗ , or neither do. Therefore, the probability of event E ∗ is at most f (2i ) 21− i . ✷
Let
= s1 , s2 , . . . , sk be a permutation of the k segments in X , chosen uniformly at random from the set of all such
permutations. Let T0 be the Delaunay triangulation of the n vertices in X , ignoring the segments. For i ∈ [0, k], let Ti be the
CDT constructed by inserting the ﬁrst i segments in .
A conﬂict is a segment-edge pair (s, e ) consisting of an edge e ∈ Ti and a segment s ∈ X that crosses e. When the segment
si +1 is inserted into the triangulation Ti , it deletes every edge in Ti it conﬂicts with. An edge e is said to have c conﬂicts if
it crosses c segments in X .
Theorem 10. (Agarwal, Arge, and Yi [1].) The expected number of edges deleted over the duration of the randomized incremental
segment insertion algorithm is in O(n log2 k).
Proof. By Lemmas 8 and 9, the probability Pr[ E ] that there exists a line segment that intersects at least k segments in X
but intersects no segment among i segments sampled randomly from X with replacement satisﬁes Pr[ E ] < 4 f (2i ) 2− i . This
probability is not increased by sampling without replacement, as the incremental algorithm does. Setting = (5 log2 k)/i
yields Pr[ E ] < 4 f (2i )/k5 ∈ O(1/k). Therefore, the ﬁrst i randomly chosen segments are likely to be a (5 log2 k)/i-net for the
segments in X .
Let e be an edge with c conﬂicts in the triangulation Ti . When a randomly chosen segment si +1 is inserted, the probability that e is deleted is c /(k − i ). The probability that there exists an edge with more than (5k log2 k)/i conﬂicts is at most
Pr[ E ]. As Ti has fewer than 3n edges, the expected number of edges deleted over the duration of the algorithm is less than

J.R. Shewchuk, B.C. Brown / Computational Geometry 48 (2015) 554–574

567

Fig. 15. The pulling vertices v 1 , v 2 , and v 3 conﬂict with one, two, and three segments (thick lines), respectively. The triangulation (thin lines) connects the
(n) pushing vertices to v 3 until a segment conceals it.

k −1

5k log2 k

3n + 3n

i (k − i )

i =1

+ Pr[ E ] ∈ O(n log2 k).

✷

Therefore, the total expected cost of all calls to CavityCDT is in O(n log2 k). With the cost of constructing the initial
Delaunay triangulation T0 and performing segment location for each segment prior to inserting it (see Section 8), the
incremental CDT construction algorithm runs in expected O(n log n + n log2 k) time.
7. A lower bound for randomized incremental segment insertion
There is a matching (n log2 k) lower bound on the expected number of structural changes. To see this, consider the
PSLG in Fig. 15, which is similar to an example Agarwal, Arge, and Yi [1] use to establish an (n log k) lower bound. The
example uses two sequences of nearly cocircular vertices. On the bottom half of the circle is a sequence of (n) pushing
vertices that lie precisely on the circle. On the top half is a smaller sequence of m pulling vertices v 1 , v 2 , . . . , v m that are
perturbed so they lie just inside the circle. Each pulling vertex v j is concealed by j segments, all of whose endpoints lie
outside the circle. The total number of segments is k = m(m + 1)/2. No segment conceals more than one pulling vertex. The
pulling vertices are placed so that edges of the CDT connect every pushing vertex to the pulling vertex with greatest index
that is not concealed, which we call the dominant pulling vertex. Every edge connecting a pushing vertex to a pulling vertex
v j has j conﬂicts. Say that v j is alive if no segment that conceals it has been inserted yet, and call the j segments that
conceal v j its conﬂicts. When a newly inserted segment conﬂicts with the dominant pulling vertex, (n) edges are deleted
and (n) new edges are created adjoining the new dominant pulling vertex.
We analyze the longevity of a pulling vertex v c with c conﬂicts with a method developed by Clarkson [13]. After i
segments have been inserted, the likelihood that v c is still alive is

Pr[ v c alive] =

>

k−c

k

i

i

k−i−c
k−c

=

k−i
k

·

k−i−1
k−1

···

k−i−c+1
k−c+1

c

.

Consider the (i + 1)th segment insertion for any

i∈

αk ln k
m

α

, min

2

k1−2α ln k,

k
2

−m

where α > 0 is a constant we will choose shortly. For every pulling vertex v c that has c ≤ (αk ln k)/i conﬂicts, the range of
i implies that c ≤ m and i ≤ k/2 − c, so

Pr[ v c alive] >

k−i−c

(αk ln k)/i

= 1+

k−c

≥e

−(αk ln k)/(k−i −c )

≥k

−2 α

=k

i

−(αk ln k)/i

k−i−c

−αk/(k−i −c )

.

The middle inequality follows because 1 + x ≤ e x for all x. Consider the (αk ln k)/(2i ) vertices in the range from v (αk ln k)/(2i )
to v (αk ln k)/i . The probability that at least one of them is alive is

Pr[one of v (αk ln k)/(2i ) , . . . , v (αk ln k)/i alive] > 1 − 1 − k−2α

≥ 1 − e −(αk

1−2α

(αk ln k)/(2i )

ln k)/(2i )

.

568

J.R. Shewchuk, B.C. Brown / Computational Geometry 48 (2015) 554–574

Fig. 16. For each doubling of the number i of inserted segments
from i = ln k to i = k, at most expected O(n log k) structural changes occur, establishing the
√
upper bound of O(n log2 k). For each doubling from i ∈ ( k ln k) to i ∈ (k1−2α ln k), at least expected (n log k) structural changes occur for the PSLG in
2
Fig. 15, establishing the lower bound of (n log k).

We assume that i ≤ α2 k1−2α ln k, so with probability at least 1 − e −1 > 0.63 there is a live pulling vertex with
(αk ln k)/(2i ) conﬂicts. Edges connect the live pulling vertex with the most conﬂicts to the (n) pushing vertices,
(i + 1)th segment insertion deletes these edges with probability at least (αk ln k)/(2i (k − i )). We choose α to be a
constant less than 1/4. Therefore, the expected number of edges deleted during the duration of the algorithm is at
min α2 k1−2α ln k, k/2−m

√

0.63

i =(αk ln k)/m∈ ( k ln k)

αk ln k
2i (k − i )

(n) =

at least
and the
positive
least

(n log2 k).

The cogent observation is that there is a range of values for i spanning a factor of k0.5−2α in which the dominant
live vertex has many conﬂicts. Although this range is narrow (and hidden—it took us a long time to realize it existed), it
suﬃces to allow the summation
1/i to contribute a (log k) factor. In this range, each doubling of i contributes (n log k)
structural changes, and i is doubled (log k) times. Fig. 16 depicts this idea visually.
Our lower bound example is related to the coupon collector’s problem. Imagine that the pulling vertices represent a set
of m types of coupons you wish to collect, and that when you buy a coupon (choose a random segment), it is of type v i
with some probability p i . Coupon collection can be modeled as a Poisson process; the probability of collecting every coupon
v i +1 , v i +2 , . . . , v m before collecting v i is [7]
∞

p i e− pi t

Pr[ v i after v i +1 , . . . , v m ] =
0

1 − e − p j t dt .
j >i
m

Our analysis is equivalent to asking, if p i = i /k where k = i =1 i, how often do you collect a coupon for the ﬁrst time such
that every coupon with greater index has already been collected? We have not been able to ﬁnd a published asymptotic
bound in terms of m for this problem, but we have just shown that the expected answer is in (log2 k) = (log2 m). For
comparison, if every coupon arrives with equal probability, the expected answer is in (log m).
It is well known that the problem of sorting a set of numbers can be reduced to computing a triangulation (Delaunay
or not) of a point set, so every algorithm for computing a triangulation of n points takes (n log n) worst-case time in the
decision tree model of computation. Therefore, CDT construction by uniformly randomized incremental segment insertion
takes expected (n log n + n log2 k) time for worst-case PSLGs.
8. The cost of segment location
Recall that for an uninserted segment s, segment location is the act of identifying a triangle in the current CDT whose
interior intersects s. We perform segment location with a simple rotary traversal of the triangles adjoining the endpoint of
s with lesser degree, taking time proportional to that endpoint’s degree. One way to identify the endpoint of lesser degree
is to record the vertex degrees and update them with every change to the triangulation. A simpler alternative is to perform
simultaneous rotary searches around both endpoints of s, interleaving steps around one endpoint with steps around the
other; a suitable triangle will be found in time proportional to the lesser degree.
In practice, most segment location operations take O(1) time. But what if both endpoints of many segments have large
degrees? Here, we show that the total cost of this segment location method is at worst proportional to the number of
vertices plus the number of structural changes that occur during segment insertion. Therefore, segment location never

J.R. Shewchuk, B.C. Brown / Computational Geometry 48 (2015) 554–574

569

worsens the asymptotic running time of incremental CDT construction. This result holds regardless of the order in which
the segments are inserted, and does not depend upon randomization.
Consider incrementally constructing the CDT of a PSLG X with n vertices and k segments. Let l be the total number of
edges that are created during all the segment insertion operations, including edges that are subsequently deleted. We have
seen in Section 6 that in expectation, l ∈ O(n log2 k) when the segment insertion order is randomized; but often l is much
smaller.
Theorem 11. During incremental construction of the CDT of X (whether randomized or not), the total time for segment location as
described above is in O(n + l).
Proof. As segments are inserted into the CDT, the degrees of the vertices change. For i ∈ [0, k], let Ti be the CDT after the
ﬁrst i segments have been inserted. For j ∈ [1, n], let d j be the maximum degree of the vertex with index j over all the
triangulations T0 , T1 , . . . , Tk . It follows from Euler’s formula that the sum of vertex degrees in T0 is at most 6n − 12, so
n
n
j =1 d j ≤ 6n + 2l − 12. The following argument shows that all the segment location operations together take O(
j =1 d j )
time, and therefore take O(n + l) time.
Suppose that we index the vertices in nonincreasing order of maximum degree, so that di ≥ d j whenever i < j. (This
indexing is not related to the insertion order!) The time to locate a segment s ∈ X whose vertices are numbered i and j
with i < j is at worst proportional to min{di , d j } = d j ; call that number the cost of s. For all i ∈ [3, n], let Xi ⊆ X be the
PSLG induced by taking only the ﬁrst i vertices in X and the segments whose endpoints are both among the ﬁrst i vertices.
Let the cost of Xi be the total cost of all its segments.
Observe that the total time for segment location is proportional to the cost of X = Xn . We show that this total is less
n
than 3 j =1 d j . As X is planar, Xi has at most 3i − 6 edges as a consequence of Euler’s formula. X3 has at most three edges
(a triangle) with total cost at most d2 + 2d3 . X4 has at most six edges, but at most three of those are in X3 ; every edge
in X4 but not in X3 has cost d4 . Hence X4 has cost at most d2 + 2d3 + 3d4 . Similarly, X5 has at most nine edges. If X5 has
edges not in X4 , they cost d5 each, so X5 has cost at most d2 + 2d3 + 3d4 + 3d5 . By inductive application of this reasoning,
i
n
the cost of Xi is at most d2 + 2d3 + 3 j =4 d j , and the cost of X is less than 3 j =1 d j . ✷
9. Extensions to three dimensions
Incremental construction of constrained Delaunay triangulations generalizes to three or more dimensions, albeit under
limited circumstances. Not every polyhedron has a CDT—or even a tetrahedralization [31,30]—and not every CDT can be
constructed incrementally. However, with the insertion of extra vertices on its edges, every polyhedron can be converted
into a structure that does have a CDT that can be constructed incrementally [37,42]. This fact is used by some algorithms
for generating high-quality tetrahedral meshes [40,41].
The natural analog of a PSLG in three dimensions is called a piecewise linear complex (PLC), introduced by Miller et al. [28].
For our purposes, a three-dimensional PLC X is a set of vertices, segments, and polygons (not necessarily convex) that obey
certain rules characteristic of complexes; for example, the boundary of every polygon in X must be a union of segments
in X , the endpoints of every segment in X must be vertices in X , and the intersection of any two elements of X must be a
union of elements of X . See elsewhere [9,39] for a complete deﬁnition.
The segments and polygons in X constrain how X can be triangulated. For example, to support the application of boundary conditions, a PLC X may have vertices and segments ﬂoating in the relative interior of a polygon, or vertices, segments,
and polygons ﬂoating inside the convex hull of X ; a triangulation of X must respect these constraints. A triangulation of a PLC
X is a simplicial complex T such that T contains the same vertices as X , every segment in X is an edge in T , every polygon
in X is a union of triangles in T , and the union of simplices s∈T s is the convex hull of the vertices in X . A constrained
Delaunay triangulation (CDT) of X is a triangulation of X in which every triangular face is either locally Delaunay or included
in a polygon in X . A CDT differs from an ordinary Delaunay triangulation in that a triangular face that lies in a polygon is
not required to be locally Delaunay.
A PLC X is said to be edge-protected if for each segment s ∈ X , there exists a closed ball whose boundary passes through
the endpoints of s, but the ball contains no other vertex in X . If X is edge-protected, every Delaunay triangulation of the
vertices in X contains every segment in X , but it does not necessarily respect the polygons in X (and therefore it is not
necessarily a triangulation of X ). The CDT Theorem [39] states that every edge-protected PLC has a CDT, which does respect
the polygons.
An incremental polygon insertion algorithm of Shewchuk [38] constructs the CDT of an n-vertex, edge-protected PLC by
constructing a Delaunay triangulation of the vertices, then inserting the polygons one by one in a manner that performs
at most O(n2 ) structural changes. (The running time of the algorithm is in O(n2 log n); the extra log n factor accounts
for a priority queue that controls the order in which the structural changes occur.) This number of structural changes is
asymptotically worst-case optimal: Fig. 17 depicts a PLC for which the insertion of just one polygon causes (n2 ) structural
changes. Thus the question of the number of structural changes during polygon insertion in worst-case PLCs is resolved,
although the question of time complexity is not; we hope that an O(n2 )-time CDT construction algorithm will be discovered.
However, there are reasons to believe that CDT construction is faster for most PLCs that arise in practice. It is well known
that the construction of a Delaunay triangulation takes (n2 ) time in the worst case, because some Delaunay triangulations

570

J.R. Shewchuk, B.C. Brown / Computational Geometry 48 (2015) 554–574

Fig. 17. The Delaunay triangulation on the left has n vertices and
to be deleted.

(n2 ) tetrahedra. The insertion of a single square polygon causes most of the tetrahedra

have (n2 ) tetrahedra; but for many point sets, the randomized incremental algorithm for constructing Delaunay triangulations runs in expected O(n log n) time and performs expected O(n) structural changes. This circumstance occurs when
the Delaunay triangulation has size O(n) and the expected size of the Delaunay triangulation of a random subset of the
input vertices is linear in the size of the random subset [3]. Many real-world inputs have this property, which explains why
three-dimensional incremental Delaunay triangulators are observed to run quickly in practice on most inputs. Can a similar
statement be made about three-dimensional incremental CDT construction?
Here we show that, under assumptions that apply to many common real-world inputs, the expected number of structural
changes required for randomized incremental construction of the CDT of an edge-protected PLC with n vertices, k segments,
and m polygons is in O(n log k log m), matching the bound for CDT construction in the plane. (Note that m ∈ O(k); see
Lemma 12 below.) However, we do not know an algorithm that inserts a polygon in time linear in the number of structural
changes. Under somewhat stronger assumptions, Shewchuk’s CDT construction algorithm [38], randomized, runs in expected
O(n log n log k log m) time. Note that fast incremental polygon insertion also requires a fast polygon location algorithm, which
we describe in Section 10.
We begin with a useful lemma. A polygon can have arbitrarily many segments, and a segment can be an edge of
arbitrarily many polygons, but the number of polygons is limited by the number of segments.
Lemma 12. Let X be a PLC in R3 with k > 0 segments and m polygons. Then m < 2k.
Proof. Imagine placing a sphere of inﬁnitesimal radius around a vertex v ∈ X . The segments and polygons adjoining v
induce a planar graph on the sphere: each segment adjoining v pierces the sphere at a single point, and each polygon
adjoining v pierces the sphere in a circular arc adjoining two or more such points. Deﬁne a graph by considering only the
arcs subtending angles strictly less than 180◦ on the sphere; thus there cannot be more than one arc adjoining any pair
of points. If a polygon f ∈ X induces such an arc for v, call v a convex corner of f . Each polygon has at least three convex
corners, because every vertex of its convex hull is a convex corner.
The number of arcs in a nonempty planar graph (with no pair of points connected by more than one arc and no point
connected to itself) is less than three times its number of points. By summing these numbers over every vertex v ∈ X ,
we ﬁnd that the number of convex corners in X is less than three times the number of segment-vertex incidences in X .
Therefore, the number of polygons in X is less than the number of segment-vertex incidences, which is twice the number
of segments. ✷
Next, we ask how many different subsets of the PLC polygons can be stabbed by a line or a line segment.
Lemma 13. Let X be a PLC in R3 with k segments and m polygons. Consider the sequence of polygons in X whose relative interiors1
intersect a ﬁxed line, written in the order of the intersection points, leaving out polygons coplanar with the line. Let Q be the set of all
such sequences, for all lines in R3 . The cardinality of Q is in O(k4 ).
Proof. Imagine extending each segment in X to a line in R3 , and let L be the set of these lines. Observe that | L | ≤ k.
To any pair of lines ( , ) in R3 , we assign a mutual orientation designated zero, positive, or negative. If
and
are
1
Rigorously speaking, “relative interior” is the wrong term here, because PLCs allow vertices and segments to ﬂoat in the relative interior of a polygon,
and intersections of the ﬁxed line with these vertices and segments should not count as intersections with the polygon. Read “relative interior” as shorthand
for “the polygon after removing all points in the PLC vertices and segments.” With this adjustment, the polygons in a PLC truly have disjoint “relative
interiors,” because the deﬁnition of PLC requires that if two polygons intersect, their intersection is a union of PLC segments and vertices.

J.R. Shewchuk, B.C. Brown / Computational Geometry 48 (2015) 554–574

571

coplanar, their mutual orientation is zero. Otherwise, imagine each line as a vector directed from lexicographically lesser
to lexicographically greater coordinates. We say that the mutual orientation of ( , ) is positive if the cross product ×
points from to , and negative otherwise.
We map each line ⊂ R3 to a point in R4 by taking the y- and z-coordinates where intersects the plane x = 0 and
concatenating the y- and z-coordinates where intersects the plane x = 1. (This map does not take lines perpendicular to
the x-axis, but we can account for those lines by repeating the argument with the coordinate system rotated.) Consider a
line that maps to a point ( y , z, v , w ) and a line
that maps to a point ( y , z , v , w ). The mutual orientation of the two
lines is the sign of ( y − y )( w − w ) + ( z − z )( v − v ); for example, and
are coplanar if and only if this expression is
zero.
If we treat ( y , z, v , w ) ∈ R4 as a vector of independent variables and ( y , z , v , w ) as a constant, the expression is a
quadratic function from R4 to R whose sign is the orientation of ( , ) for a ﬁxed
and a varying . The zero-surface
of this function is the set of points in R4 satisfying ( y − y )( w − w ) + ( z − z )( v − v ) = 0. Consider the arrangement A
of surfaces in R4 deﬁned by overlaying these zero-surfaces for every
∈ L. If two lines 1 and 2 map to points in the
same face of A , then it is possible to translate and rotate 1 to 2 without changing its orientation with respect to any
line in L. It follows that 1 and 2 intersect the relative interiors of the same polygons in X in the same order, possibly
excepting polygons coplanar with both 1 and 2 . The maximum number of faces in such an arrangement of zero-surfaces
is in O(k4 ) [29,2], and thus the number of sequences in Q is also in O(k4 ). ✷
Lemma 14. Let X be a PLC in R3 . Let P be a subset of the polygons in X . Let m be the number of polygons in P , and let k be the number
of segments of those polygons (i.e., segments in X included in at least one polygon in P ). Consider the subset of polygons in P whose
relative interiors intersect a ﬁxed line segment, leaving out polygons coplanar with the line segment. Let M be the set of all such subsets,
for all line segments in R3 . The cardinality of M is in O(k4 m2 ).
Proof. Follows from Lemma 13 by the same reasoning used to prove Lemma 7.

✷

Let X be an edge-protected PLC. Let
= f 1 , f 2 , . . . , f m be a permutation of the m polygons in X , chosen uniformly
at random from the set of all such permutations. Let T0 be the Delaunay triangulation of the n vertices in X , ignoring the
polygons. Because X is edge-protected, T0 contains every segment in X . For i ∈ [0, m], let Ti be the CDT constructed by
inserting the ﬁrst i polygons in .
A conﬂict is a polygon-edge pair ( f , e ) consisting of an edge e ∈ Ti and a polygon f ∈ X whose relative interior intersects
the relative interior of e. When the polygon f i +1 is inserted into the triangulation Ti , it deletes every edge in Ti it conﬂicts
with. An edge e is said to have c conﬂicts if it crosses c polygons in X .
Theorem 15. In the randomized incremental polygon insertion algorithm, suppose that the expected number of tetrahedra in each
intermediate triangulation T0 , . . . , Tm is in O( g (n)) for some function g (n). The expected number of structural changes made over the
duration of the algorithm is in O( g (n) log k log m).
Proof. Lemmas 8 and 9 extend to polygons in three dimensions, with the function f ( j ) in Lemma 9 replaced by another
function satisfying f ( j ) ∈ O(k4 j 2 ) per Lemma 14. Thus, the probability Pr[ E ] that there exists a line segment that intersects
at least m polygons in X but intersects no polygon among i ≤ m polygons sampled randomly from X with replacement
satisﬁes Pr[ E ] ∈ O(4k4 (2i )2 2− i ). This probability is not increased by sampling without replacement, as the incremental
algorithm does. As i ≤ m < 2k by Lemma 12, setting = (7 log2 k)/i yields Pr[ E ] ∈ O(1/k). Therefore, the ﬁrst i randomly
chosen polygons are likely to be a (7 log2 k)/i-net for the polygons in X .
Let e be an edge with c conﬂicts in the triangulation Ti . When a randomly chosen polygon f i +1 is inserted, the probability that e is deleted is c /(m − i ). The probability that there exists an edge with more than (7m log2 k)/i conﬂicts is at most
Pr[ E ]. A tetrahedron is deleted only if one of its six edges is deleted. By assumption, Ti has expected O( g (n)) tetrahedra, so
the expected number of tetrahedra deleted over the duration of the algorithm is in
m −1

O 6 g (n)
i =1

7m log2 k
i (m − i )

+ Pr[ E ]

= O( g (n) log k log m).

The ﬁnal triangulation Tm has expected O( g (n)) tetrahedra, so the expected number of tetrahedra created is also in
O( g (n) log k log m). ✷
Moreover, Shewchuk [38] shows that the total number of structural changes is in O(n2 ), regardless of the polygon insertion order, so with a randomized insertion order the expected number of structural changes is in

O(min{ g (n) log k log m, n2 }).
Unfortunately, there is no known algorithm that can retriangulate the cavities evacuated by the insertion of a polygon
in time linear in the number of structural changes. Shewchuk’s algorithm for polygon insertion, which is based on bistellar

572

J.R. Shewchuk, B.C. Brown / Computational Geometry 48 (2015) 554–574

ﬂips, incurs two additional costs: an O(log n)-time cost per ﬂip to perform priority queue (binary heap) operations that
ensure that ﬂips occur in the correct order; and the fact that the number of bistellar ﬂips could far exceed the number
of necessary structural changes because some tetrahedra are created only to be immediately deleted again during a single
polygon insertion operation, though the total number of ﬂips never exceeds O(n2 ). Experiments [43] suggest that it is
uncommon for the number of ﬂips to exceed the number of deleted tetrahedra by more than a small constant, and our
intuition is that such circumstances are analogous to the circumstances in which a Delaunay triangulation has a superlinear
size—possible for inputs exhibiting a certain regular structure, but not the norm. For many, probably most, PLCs that arise
in practice, g (n) ∈ O(n), so we anticipate that randomized incremental polygon insertion implemented with bistellar ﬂips
will often run in O(n log n log k log m) time in practice.
10. Polygon location in three-dimensional CDTs
Just as segment location is the ﬁrst step to inserting a segment into a planar CDT, the ﬁrst step to inserting a polygon
f into a three-dimensional CDT is polygon location: the act of identifying a tetrahedron in the current CDT whose interior
intersects f .
We assume that every segment of f is an edge of the current triangulation (a safe assumption if the underlying PLC
is edge-protected). In analogy to vertex degrees, we deﬁne the degree of an edge in a triangulation to be the number of
tetrahedra that include the edge. Our polygon location method is to perform a simple rotary traversal of the tetrahedra
around the segment of f with least degree, taking time proportional to that segment’s degree in the current triangulation.
To analyze segment insertion in the plane, in Section 8 we used the fact that after one triangle is found whose interior
intersects the new segment, the other conﬂicting triangles can be found by a depth-ﬁrst search in time linear in their
number, and the cost of the search can be charged to the time spent deleting those triangles. Unfortunately, this charging
scheme does not suﬃce to analyze polygon insertion in three dimensions, because a polygon might already be partially
present in the CDT: the CDT may already contain triangles that are subsets of the polygon, as well as edges coinciding with
the polygon’s relative interior. We can still use a careful depth-ﬁrst search to ﬁnd all the tetrahedra whose interiors intersect
the new polygon, but the cost of that search is proportional to the number of tetrahedra deleted plus the degrees of the
triangulation edges that are included in the new polygon but are not PLC segments (because it may be necessary to search
all the tetrahedra adjoining these edges). Fortunately, a triangulation edge that is not a PLC segment can be included in only
one PLC polygon.
Consider incrementally constructing the CDT of a PSLG X with k segments and m polygons. Let l be the total number
of distinct tetrahedra that exist in one or more of the triangulations T0 , . . . , Tm (i.e., the tetrahedra in the initial Delaunay
triangulation and the tetrahedra created during polygon insertion operations). The following theorem shows that the total
cost of polygon location is dominated by the cost of simply creating all those tetrahedra.
Theorem 16. During incremental construction of the CDT of X (whether randomized or not), the total time for polygon location as
described above is in O(l).
Proof. The time to locate a polygon f ∈ X is at worst proportional to the number of segments of f (as we must check the
degree of each segment), which we call the ﬁrst cost of f , plus the degree of its lowest-degree segment, which we call the
second cost of f , plus the number of tetrahedra deleted when f is inserted, which we call the third cost of f , plus the sum
of the degrees of any triangulation edges included in f that are not segments, which we call the fourth cost of f .
The total ﬁrst cost of all the polygons is equal to the number of polygon-segment incidences in X . Each such incidence
induces a distinct triangle-edge incidence in the ﬁnal triangulation Tm . Tm has at most 12 triangle-edge incidences per
tetrahedron, and there are at most l tetrahedra in Tm . Therefore, the total ﬁrst cost of all the polygons at most 12l.
The total third cost of all the polygons is at most l, because a tetrahedron must be created before it is deleted, and a
deleted tetrahedron is never created again.
Let E be the set containing every edge that exists in one or more of the triangulations T0 , . . . , Tm . For e ∈ E, let de be the
maximum degree of e over all the triangulations T0 , T1 , . . . , Tm . Each tetrahedron has six edges, so
e ∈ E de ≤ 6l. Therefore,
the total fourth cost of all the polygons at most 6l.
Suppose that the segments in X are all in E (a necessary condition for the algorithm to succeed). Order the segments
in X by their maximum degrees, from greatest to least. For all i ∈ [1, k], let Xi ⊆ X be the PLC induced by taking all the
vertices in X , the ﬁrst i segments (with greatest maximum degrees), and the polygons in X whose segments are all among
those i segments. By Lemma 12, Xi has fewer than 2i polygons. By a repetition of the same inductive reasoning employed
in the proof of Theorem 11, the total second cost of all the polygons is less than 2 e∈ E de ≤ 12l. ✷
11. Conclusions and open problems
Although this article emphasizes the time complexity of randomized incremental segment insertion, we draw some conclusions useful to programmers implementing CDT construction codes. First, when some segments cross very large numbers
of edges, a faster segment insertion algorithm can make enough of a difference to justify its implementation. Second, there

J.R. Shewchuk, B.C. Brown / Computational Geometry 48 (2015) 554–574

573

is a very simple segment location method that never compromises incremental insertion’s asymptotic running time, with
or without randomization. Third, it might be worthwhile to randomize the order in which the segments are inserted; compare the expected O(n log2 k) upper bound on the number of structural changes with the (kn) structural changes that
can occur with a deterministic ordering. Fourth, the O(n log2 k) upper bound is almost always too pessimistic in practice;
circumstances in which this much work is required are diﬃcult to devise and unlikely to occur in the real world. Fifth, and
most importantly, if incremental segment insertion is implemented intelligently, it is fast enough; implementing a more
complicated O(n log n)-time CDT construction algorithm is unlikely to repay the effort.
Considering the (n log2 k) lower bound on the expected number of structural changes that the randomized incremental
segment insertion algorithm performs on some PSLGs, we wonder whether the algorithm could be faster if the segments
were inserted in a biased order. For example, it is possible to choose two segments at random, determine which one crosses
the fewest edges, and insert it in time proportional to the number of edges it crosses—without taking the time to count all
the edges the other segment crosses. Does this procedure reduce the expected asymptotic number of structural changes?
Interestingly, the O(n log2 k) upper bound on the number of structural changes does not rely on the constrained Delaunay
property; the analysis applies however the cavities are retriangulated. Are there other algorithms for computing optimal
triangulations that can be sped up by randomized incremental segment insertion?
Finally, how quickly can an algorithm insert a polygon into a three-dimensional CDT? There is no obvious reason to
doubt that an algorithm exists that runs in expected time linear in the number of structural changes, but neither is there
an obvious reason to be conﬁdent that one exists.
Acknowledgements
We thank Kevin Yi for introducing us to his work on CDT structural changes [1], Pankaj Agarwal and Ken Clarkson
for discussions of the probabilistic methods behind it [13,18], Peter Shor for pointing out the connection to the coupon
collector’s problem, and James Martin for introducing us to the Poissonization of that problem. We also thank James O’Brien
for the inspiration of writing “This is hopeless. You will never ﬁgure it out” on the whiteboard while we worked out the
lower bound.
References
[1] P.K. Agarwal, L. Arge, K. Yi, I/O-eﬃcient construction of constrained Delaunay triangulations. Unpublished manuscript; http://www.cse.ust.hk/~
yike/cdt/paper.pdf. Most of this paper appears in the Proceedings of the Thirteenth European Symposium on Algorithms, pages 355–366, October
2005, but the published version omits the analysis of the number of structural changes performed by randomized incremental segment insertion.
[2] P.K. Agarwal, M. Sharir, Arrangements and their applications, in: Handbook of Computational Geometry, Elsevier Science, Amsterdam, The Netherlands,
2000, pp. 49–119.
[3] N. Amenta, S. Choi, G. Rote, Incremental constructions con BRIO, in: Proceedings of the Nineteenth Annual Symposium on Computational Geometry,
Association for Computing Machinery, San Diego, California, 2003, pp. 211–219.
[4] M.V. Anglada, An improved incremental algorithm for constructing restricted Delaunay triangulations, Comput. Graph. 21 (1997) 215–223.
[5] A. Bowyer, Computing Dirichlet tessellations, Comput. J. 24 (1981) 162–166.
[6] K.Q. Brown, Voronoi diagrams from convex hulls, Inf. Process. Lett. 9 (1979) 223–228.
[7] M. Brown, E.A. Peköz, S.M. Ross, Coupon collecting, Probab. Eng. Inf. Sci. 22 (2008) 221–229.
[8] B. Chazelle, Triangulating a simple polygon in linear time, Discrete Comput. Geom. 6 (1991) 485–524.
[9] S.W. Cheng, T.K. Dey, J.R. Shewchuk, Delaunay Mesh Generation, CRC Press, Boca Raton, Florida, 2012.
[10] L.P. Chew, Constrained Delaunay triangulations, Algorithmica 4 (1989) 97–108.
[11] L.P. Chew, Building Voronoi diagrams for convex polygons in linear expected time, Technical report PCS-TR90-147, Department of Mathematics and
Computer Science, Dartmouth College, 1990.
[12] F. Chin, C.A. Wang, Finding the constrained Delaunay triangulation and constrained Voronoi diagram of a simple polygon in linear time, SIAM J.
Comput. 28 (1998) 471–486.
[13] K.L. Clarkson, New applications of random sampling in computational geometry, Discrete Comput. Geom. 2 (1987) 195–222.
[14] B.N. Delaunay, Sur la sphère vide, Izv. Akad. Nauk SSSR, Otd. Mat. Estestv. Nauk 7 (1934) 793–800.
[15] H. Edelsbrunner, R. Seidel, Voronoi diagrams and arrangements, Discrete Comput. Geom. 1 (1986) 25–44.
[16] S. Fortune, A sweepline algorithm for Voronoi diagrams, Algorithmica 2 (1987) 153–174.
[17] L.J. Guibas, J. Stolﬁ, Primitives for the manipulation of general subdivisions and the computation of Voronoi diagrams, ACM Trans. Graph. 4 (1985)
74–123.
[18] D. Haussler, E. Welzl, -Nets and simplex range queries, Discrete Comput. Geom. 2 (1987) 127–151.
[19] F. Hermeline, Une methode automatique de maillage en dimension n, Ph.D. thesis, Université Pierre et Marie Curie, Paris, France, 1980.
[20] F. Hermeline, Triangulation automatique d’un polyèdre en dimension N, RAIRO. Anal. Numér. 16 (1982) 211–242.
[21] M. Howison, CAD tools for creating space-ﬁlling 3D Escher tiles, Master’s thesis, University of California at Berkeley, Berkeley, California, 2009, Available
as technical report UCB/EECS-2009-56.
[22] R. Kaas, J.M. Buhrman, Mean, median and mode in binomial distributions, Stat. Neerl. 34 (1980) 13–18.
[23] T.C. Kao, D.M. Mount, Incremental construction and dynamic maintenance of constrained Delaunay triangulations, in: Proceedings of the Fourth Canadian Conference on Computational Geometry, St. John’s, Newfoundland, 1992, pp. 170–175.
[24] R. Klein, A. Lingas, A linear-time randomized algorithm for the bounded Voronoi diagram of a simple polygon, in: Proceedings of the Ninth Annual
Symposium on Computational Geometry, Association for Computing Machinery, San Diego, California, 1993, pp. 124–132.
[25] R. Klein, A. Lingas, A note on generalizations of Chew’s algorithm for the Voronoi diagram of a convex polygon, in: Proceedings of the Fifth Canadian
Conference on Computational Geometry, Waterloo, Ontario, Canada, 1993, pp. 370–374.
[26] D.T. Lee, A.K. Lin, Generalized Delaunay triangulations for planar graphs, Discrete Comput. Geom. 1 (1986) 201–217.
[27] D.T. Lee, B.J. Schachter, Two algorithms for constructing a Delaunay triangulation, Int. J. Comput. Inf. Sci. 9 (1980) 219–242.
[28] G.L. Miller, D. Talmor, S.H. Teng, N.J. Walkington, H. Wang, Control volume meshes using sphere packing: Generation, reﬁnement and coarsening, in:
Proceedings of the 5th International Meshing Roundtable, Pittsburgh, Pennsylvania, 1996, pp. 47–61.

574

[29]
[30]
[31]
[32]
[33]
[34]
[35]
[36]
[37]
[38]
[39]
[40]
[41]
[42]
[43]
[44]
[45]

J.R. Shewchuk, B.C. Brown / Computational Geometry 48 (2015) 554–574

R. Pollack, M.F. Roy, On the number of cells deﬁned by a set of polynomials, C. R. Acad. Sci., Ser. 1 Math. 316 (1993) 573–577.
J. Ruppert, R. Seidel, On the diﬃculty of triangulating three-dimensional nonconvex polyhedra, Discrete Comput. Geom. 7 (1992) 227–253.
E. Schönhardt, Über die Zerlegung von Dreieckspolyedern in Tetraeder, Math. Ann. 98 (1928) 309–312.
R. Seidel, Voronoi Diagrams in higher dimensions, Diplomarbeit, Institut für Informationsverarbeitung, Technische Universität Graz, Graz, Austria, 1982.
R. Seidel, Constrained Delaunay triangulations and Voronoi diagrams with obstacles, in: H.S. Poingratz, W. Schinnerl (Eds.), 1978–1988 Ten Years IIG,
Institut für Informationsverarbeitung, Technische Universität Graz, Graz, Austria, 1988, pp. 178–191.
R. Seidel, Backwards analysis of randomized geometric algorithms, in: J. Pach (Ed.), New Trends in Discrete and Computational Geometry, in: Algorithms
Comb., vol. 10, Springer-Verlag, Berlin, 1993, pp. 37–67.
M.I. Shamos, D. Hoey, Closest-point problems, in: 16th Annual Symposium on Foundations of Computer Science, Berkeley, California, 1975, pp. 151–162.
J.R. Shewchuk, Adaptive precision ﬂoating-point arithmetic and fast robust geometric predicates, Discrete Comput. Geom. 18 (1997) 305–363.
J.R. Shewchuk, Constrained Delaunay tetrahedralizations and provably good boundary recovery, in: Proceedings of the 11th International Meshing
Roundtable, Sandia National Laboratories, Ithaca, New York, 2002, pp. 193–204.
J.R. Shewchuk, Updating and constructing constrained Delaunay and constrained regular triangulations by ﬂips, in: Proceedings of the Nineteenth
Annual Symposium on Computational Geometry, Association for Computing Machinery, San Diego, California, 2003, pp. 181–190.
J.R. Shewchuk, General-dimensional constrained Delaunay triangulations and constrained regular triangulations I: Combinatorial properties, Discrete
Comput. Geom. 39 (2008) 580–637.
J.R. Shewchuk, H. Si, Higher-quality tetrahedral mesh generation for domains with small angles by constrained Delaunay reﬁnement, in: Proceedings
of the Thirtieth Annual Symposium on Computational Geometry, Association for Computing Machinery, Kyoto, Japan, 2014, pp. 290–299.
H. Si, Constrained Delaunay tetrahedral mesh generation and reﬁnement, Finite Elem. Anal. Des. 46 (2010) 33–46.
H. Si, K. Gärtner, Meshing piecewise linear complexes by constrained Delaunay tetrahedralizations, in: B.W. Hanks (Ed.), Proceedings of the Fourteenth
International Meshing Roundtable, San Diego, California, 2005, pp. 147–163.
H. Si, J.R. Shewchuk, Incrementally constructing and updating constrained Delaunay tetrahedralizations with ﬁnite precision coordinates, in: Proceedings of the 21st International Meshing Roundtable, San Jose, California, 2012, pp. 173–190.
J. Steiner, Einige Gesetze über die Theilung der Ebene und des Raumes, J. Reine Angew. Math. 1 (1826) 349–364.
D.F. Watson, Computing the n-dimensional Delaunay tessellation with application to Voronoi polytopes, Comput. J. 24 (1981) 167–172.

