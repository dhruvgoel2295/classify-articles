Computational Geometry 48 (2015) 589–605

Contents lists available at ScienceDirect

Computational Geometry: Theory and
Applications
www.elsevier.com/locate/comgeo

On soft predicates in subdivision motion planning ✩
Cong Wang a , Yi-Jen Chiang a,∗ , Chee Yap b
a
b

Department of Computer Science and Engineering, Polytechnic School of Engineering, New York University, Brooklyn, NY, USA
Department of Computer Science, New York University, New York, NY, USA

a r t i c l e

i n f o

Article history:
Available online 14 April 2015
Keywords:
Exact algorithms
Subdivision algorithms
Motion planning
Soft predicates
Resolution-exact algorithms

a b s t r a c t
We propose to design new algorithms for motion planning problems using the wellknown Domain Subdivision paradigm, coupled with “soft” predicates. Unlike the traditional
exact predicates in computational geometry, our primitives are only exact in the limit. We
introduce the notion of resolution-exact algorithms in motion planning: such an algorithm
has an “accuracy” constant K > 1, and takes an arbitrary input “resolution” parameter ε > 0
such that: if there is a path with clearance K ε , it will output a path with clearance ε / K ;
if there are no paths with clearance ε / K , it reports “NO PATH”. Besides the focus on soft
predicates, our framework also admits a variety of global search strategies including forms
of the A* search and probabilistic search.
Our algorithms are theoretically sound, practical, easy to implement, without implementation gaps, and have adaptive complexity. Our deterministic and probabilistic strategies
avoid the Halting Problem of current probabilistically complete algorithms. We develop
the ﬁrst provably resolution-exact algorithms for motion-planning problems in SE(2) =
R2 × S 1 . To validate this approach, we implement our algorithms and the experiments
demonstrate the eﬃciency of our approach, even compared to probabilistic algorithms.
© 2015 Elsevier B.V. All rights reserved.

1. Introduction
A central problem of robotics is motion planning [4,20,21,10]. In the early 80’s there was strong interest in this problem
among computational geometers [15,32]. This period saw the introduction of strong algorithmic techniques with complexity
analysis, and the careful investigation of the algebraic conﬁguration space (C-space). In particular, Schwartz and Sharir [31]
showed that the method of algebraic cell decomposition is a universal solution for motion planning. We introduced the
retraction method in [24,33,34]. In the ﬁrst survey of algorithmic motion planning [40], we also showed the universality
of the retraction method. This method is now commonly known as the road map approach, popularized by Canny [8] who
showed that its algebraic complexity is in single exponential time. Typical of algorithms in Computational Geometry, these
exact motion planning algorithms assume a computational model in which exact primitives are available in constant time.
Implementing these primitives exactly is non-trivial (certainly not constant time), involving computation with algebraic
numbers.
In the 1990s, interest shifted back to more practical techniques. Today, the dominant approach is based on sampling,
usually combined with randomization. The most well-known representative of the sampling approach is the probabilistic

✩
An extended abstract of this paper appeared in Proc. ACM Symposium on Computational Geometry (SoCG’13), pp. 349–358, 2013. This work is supported by
NSF Grant CCF-0917093 and DOE Grant DE-SC0004874.
Corresponding author.
E-mail addresses: cwang05@students.poly.edu (C. Wang), chiang@nyu.edu (Y.-J. Chiang), yap@cs.nyu.edu (C. Yap).

*

http://dx.doi.org/10.1016/j.comgeo.2015.04.002
0925-7721/© 2015 Elsevier B.V. All rights reserved.

590

C. Wang et al. / Computational Geometry 48 (2015) 589–605

roadmap method (PRM) [19]. The idea is to compute a partial road map by random sampling of the C-space. PRM offers a
computational framework for a large class of algorithms. Moreover, many variants1 of the basic framework have been developed (see [21,10]). Most sampling methods take sample points in conﬁguration space, but the recent paper from Halperin’s
group [29] takes sample (parametrized) subsets of conﬁguration space. In an invited talk at the IROS 2011 Workshop on
Progress and Open Problems in Motion Planning.2 J.C. Latombe stated that the major open problem of such Sampling Methods is that they do not know how to terminate when there is no free path. In practice, one would simply time-out the
algorithm, but this leads to issues such as “Climber’s Dilemma” [16, p. 4] that arose in the work of Bretl (2005). We call this
the halting problem of PRM, viewed as the ultimate form of what is popularly known as the “Narrow Passage Problem” [10,
p. 216]. Latombe’s talk suggested promising approaches such as Lazy PRM [3]. The theoretical foundation of PRM is based
on two principles: probabilistic completeness, and fast convergence under certain “expansiveness” assumptions [18] about
the environment. It is unclear how to check these assumptions on speciﬁc environments. For a comprehensive overview of
motion planning, see Lavalle [21] and Choset et al. [10].
In this paper, we turn to a third popular approach [46] for motion planning, which we call Subdivision Methods. The
general idea is to subdivide some bounded domain B 0 , typically a subset of Rd . In motion planning, the domain is a subset
of conﬁguration space. In its simplest form, the subdivision of B 0 can be represented as a subdivision tree, which is a generalization of binary trees (d = 1) or quad-trees (d = 2). An early reference for this approach is Brooks and Lozano-Perez [5].
Recent subdivision references include [46,2,45,12,26]. Manocha’s group has been active and highly successful in producing
practical subdivision algorithms for a variety of tasks, not just in motion planning (e.g., [38,36]). Domain subdivisions are
sometimes known as “cell decomposition” (e.g., [46]), but we reserve “cell decomposition” for the approaches based on partitioning the conﬁguration space into algebraic “cells” with bounded combinatorial complexity that are directly correlated
with the combinatorial features on the obstacles (e.g., [30,40]). In contrast to such cells, the boxes in subdivision approaches
are more related to “resolution”. Nevertheless, subdivision that takes into account combinatorial complexity may be seen in
[45,46]. Such kinds of subdivision algorithms offer tantalizing opportunities for new kinds of complexity analysis. Examples
of such analysis may be seen in [28,35,7].
¶1. Contributions of this paper Although subdivision algorithms have been widely used by practitioners, their theoretical
foundations have so far been lacking. This paper begins this task.
The notion of “resolution completeness” is widely used in the motion planning literature [10] but rarely analyzed (Section 5 discusses some issues). Our ﬁrst contribution is to introduce the concept of resolution-exact (or ε -exact) planners.
Such planners accept an input resolution parameter ε > 0. The planner has an accuracy constant K > 1, independent of
the input, such that if there is a path of clearance K ε , it will output a path with clearance ε / K ; if there is no path of clearance ε / K , it will output “NO PATH”. As this paper shows, our deﬁnition allows us to devise planners that avoid the halting
problem of PRM. Moreover, Section 5 notes that the usual concept of “resolution completeness” does not automatically solve
the halting problem. But in what sense have we “solved” the halting problem? To be sure, we are not solving the halting
problem for exact motion planning—this would require exact computation, something we wish to avoid in robotics. Instead,
ε -exactness weakens the requirements for the “NO PATH” output. But is this just a trick to solve the halting problem by
ﬁat? No, we argue that our weakening is not only justiﬁable, but desirable: good engineers know the limits of accuracy in
their sensors, actuators, robot dimensions, etc. Path planning that depends on accuracy beyond these limits is not realistic,
even dangerous. Note that when we output “NO PATH”, we guarantee that there exists no path with clearance K ε (this is
the contrapositive of the statement just mentioned above: “if there is a path of clearance K ε , it will output a path with
clearance ε / K ”); no similar guarantees can come from PRM. With this information, users can choose ε based on engineering
limits so that when we declare “NO PATH”, no further search is warranted.
Our second contribution is the introduction of soft primitives for designing resolution-exact planners. Brieﬂy, soft primitives are suitable numerical approximations of exact (hard) primitives. Such primitives are perhaps nascent in previous
literature. But by making this idea explicit, we open up many new possibilities, as well as lay the groundwork for a
systematic investigation of such algorithms. Such primitives are relatively easy to implement correctly (i.e., there are no
“implementation gaps” in such algorithms).
Third, we design new planners based on soft predicates. These algorithms are the ﬁrst explicit examples of resolutionexact planners. Our algorithms can use various search strategies, including probabilistic ones. Halting is guaranteed even in
our probabilistic planners.
Our ﬁnal contribution is the development and implementation of the ﬁrst resolution-exact algorithms for rigid robots
with conﬁguration space SE(2) = R2 × S 1 . Our experiments demonstrate their effectiveness.
2. On numerical computational geometry
Computational Geometry (CG) has traditionally concentrated on Exact Methods. The attractive features of exact algorithms are well-known. The drawback of such methods is exposed when we start to implement the algorithms. The inability

1
A partial list includes Expansive-Spaces Tree planner (EST), Rapidly-exploring Random Tree planner (RRT), Sampling-Based Roadmap of Trees planner
(SRT).
2
http://www.cse.unr.edu/robotics/tc-apc/ws-iros2011. Sept. 30, 2011, San Francisco.

C. Wang et al. / Computational Geometry 48 (2015) 589–605

591

of Exact Methods to have wider impact on robotics and ﬁelds of Computational Sciences and Engineering (CS&E) despite
the fact that geometric reasoning is central in these ﬁelds calls for a re-examination of our assumptions. We argue that
Subdivision Algorithms, when3 combined with soft primitives, offer a pathway for CG’ers to design new algorithms based
on numerical approximations that are both practical and theoretically sound. Our soft primitives do not entail error analysis
in the style of numerical analysis; rather, we rely on interval methods [22]. Algorithms in “Numerical CG” in this sense are
distinctly different from the usual exact algorithms (see [43] for a general discussion).
One limitation of numerical primitives is that they are only complete in the limit. They also cannot detect degeneracies
unless we use zero bounds [42]. Luckily for us, this is not an issue for resolution-exact planners and many other applications.
But there are some problems (e.g., subdivision methods for Voronoi diagrams [39]) for which it is a challenge to handle
degeneracies using only soft predicates. On the other hand, numerical methods have the advantage of greater generality,
being applicable to non-algebraic problems where exact solutions are generally unknown (see a rare exception in [9]).
Numerical CG will open up completely new areas for CG’ers.
The conventional wisdom of roboticists (see Choset et al. [10, p. 202]) is that Subdivision Methods are effective only
up to “medium” degrees of freedom (DOFs) while Sampling Methods can be effective for much higher DOFs. This remark
is borne out by currently implemented planners. But we do not see any inherent reason for this gap. Use of randomness
is not a reason—as we will see, it is easy to deploy random search strategies in Subdivision Methods. We believe that the
current reach of Subdivision Methods in motion planning can be greatly extended with better (perhaps randomized) search
strategies. More generally, does the supposed limitation of subdivision extend beyond motion planning? Pessimistic views of
subdivision often assume that the size of subdivision trees is exponential in the inverse resolution 1/ε . This only shows that
adaptivity in subdivision is critical. Some recent examples [28,6,35] suggest that adaptive approaches can guarantee optimal
tree sizes, even in the worst case sense. Also the exploitation of Newton-type techniques in subdivision is very promising
(e.g., [27]). All these point to many new opportunities for algorithmic development in Numerical CG.
3. Subdivision motion planning
In this section, we illustrate our approach with a basic motion planning problem. Fix a rigid robot R 0 ⊆ Rd and an
obstacle set ⊆ Rd . Both R 0 and
are closed sets. Initially we assume R 0 is a d-dimensional ball of radius r0 > 0.
Suppose we want to compute a motion from an initial conﬁguration α to some ﬁnal conﬁguration β . One of the best
exact solutions when R 0 is a ball is based on roadmaps (i.e., retraction approach). Historically, the case d = 2 was the
ﬁrst exact roadmap algorithm [24]. For polygonal , the roadmap is eﬃciently computed as the Voronoi diagram of line
segments [41,13]. For d = 3, it is clear that a similar exact solution is possible. But here we see the limitations of exact
solutions: there is no known exact algorithm for the Voronoi diagram of polyhedral obstacles [17,39]. The conﬁguration
space or C space is Rd when R 0 is a ball. In general, we write C space ( R 0 ) for the conﬁguration of a robot R 0 . Let α , β ∈ C space .
The footprint of R 0 at α is the set R 0 [α ] comprising those points in Rd occupied by R 0 in conﬁguration α (where R 0 is
centered at α ). We say α is free if R 0 [α ] ∩
is empty; it is semi-free if it is not free but R 0 [α ] does not intersect the
interior of . Thus α is semi-free if R 0 [α ] is just touching
without penetrating it. Finally α is stuck if it is neither free
nor semi-free. Thus, every conﬁguration is classiﬁed as free, stuck or semi-free. We extend this classiﬁcation to any set
B ⊆ C space : we say B is free (resp., stuck) if every α ∈ B is free (resp., stuck). Otherwise, B is mixed (i.e., contains at least
one semi-free conﬁguration). We thus deﬁned the (exact) classiﬁcation predicate C : 2C space → {FREE, STUCK, MIXED}. This
classiﬁcation goes back to the beginning of subdivision motion planning in Brooks and Perez [5]. Our goal in soft primitive
design is to avoid this exact predicate.
Let C free = C free ( R 0 , ) ⊆ C space denote the set of free conﬁgurations. A motion from α to β is a continuous map μ :
[0, 1] → C space with μ(0) = α and μ(1) = β . We call μ a free motion or more simply, a path, if its range {μ(t ) : t ∈ [0, 1]}
is contained in C free . For sets A , B ⊆ Rd , deﬁne their separation to be Sep( A , B ) := inf{ a − b : a ∈ A, b ∈ B }. The clearance
of a conﬁguration γ ∈ C space is the separation between R 0 [γ ] and . The clearance of a path μ is the minimum clearance
of μ(t ) for t ∈ [0, 1].
¶2. Subdivision trees Our main data structure is a subdivision tree T rooted at a box B 0 ⊆ Rd . The nodes of T are subboxes
of B 0 , where boxes are closed subsets of full dimension d, and each internal node B is split into 2i (i = 1, . . . , d) congruent
subboxes which form the children of B. We remark that boxes B are axes-parallel and not assumed to be square, with width
w ( B ) and length ( B ) deﬁned to be the lengths of the shortest and longest side (resp.). For convergence, we must assume
that the aspect ratio ( B )/ w ( B ) ≥ 1 is bounded. Any box that can be obtained as a descendant of B 0 in a subdivision tree
is said to be aligned. Let m( B ) denote the midpoint and radius r ( B ) be the distance from m( B ) to any corner of B. For
any real number s > 0, let s · B (or sB) denote the congruent box centered at m( B ) with radius s · r ( B ). Two boxes B , B are
adjacent if B ∩ B is a facet F of B or of B , where facets refer to faces of co-dimension 1. Also, let D m (r ) denote the closed
ball centered at m with radius r.

3
Subdivision Algorithms could also be combined with hard primitives. But to exploit the full power of Subdivision Methods we must consider soft
primitives.

592

C. Wang et al. / Computational Geometry 48 (2015) 589–605

To allow domains of arbitrarily complex geometry, the input to our algorithm is an initial subdivision tree T0 whose
leaves are arbitrarily marked ON or OFF. The set of ON-leaves forms a subdivision of the region-of-interest ROI(T ) of the
tree. Subsequently, T can be expanded at any ON-leaf B, by splitting B into 2i (1 ≤ i ≤ d) congruent subboxes who become
the children of B.
¶3. A subdivision FindPath algorithm Our algorithm is given ε > 0 and an initial T0 rooted at B 0 . The algorithm is
parametrized by two subroutines: a classiﬁcation predicate C ( B ) for boxes, and a subroutine Split( B , ε ) which returns
a subdivision of B into 2i (for some i = 0, . . . , d) congruent subboxes; the split subroutine is said to fail if w ( B ) ≤ ε (in this
case i = 0). Recall that we assume the aspect ratio ( B )/ w ( B ) to be bounded. We use T to search for a path in B 0 ∩ C free
as follows. Let V (T ) denote the set of free leaves in ROI(T ). We deﬁne an undirected graph G (T ) with a vertex set V (T )
and edges connecting pairs of adjacent free boxes. We maintain the connected components of G (T ) using the well-known
Union-Find data structure on V (T ): given B , B ∈ V (T ), Find( B ) returns the index of the component containing B, and
Union( B , B ) merges the components of B and of B .
We associate with T a priority queue Q = Q T to store all the mixed leaves B with width w ( B ) > ε . Let T .getNext()
remove a box in Q of highest “priority”. This priority is discussed below. We denote by BoxT (α ) (resp. BoxT (β)) the leaf
box in T containing α (resp. β ). Let B be BoxT (α ) or BoxT (β) or a leaf box returned by T .getNext(). We will expand
B as follows: ﬁrst call Split( B , ε ). If Split( B , ε ) fails, we return fail (note that it never fails if B is a box returned
by T .getNext()). Otherwise, each of the subboxes B returned by Split( B , ε ) is made a child of B. We label B with the
predicate C ( B ). If C ( B ) = FREE, we insert B into V (T ) and into the union-ﬁnd structure, and for each B ∈ V (T ) adjacent
to B , we add an edge ( B , B ) to the graph G (T ) and call Union( B , B ). Finally, if C ( B ) = MIXED and w ( B ) > ε , we insert
B into Q . Thus, mixed boxes of width ≤ ε are discarded (effectively regarded as STUCK). Now we are ready to present a
simple but useful subdivision algorithm:

FindPath:
Input: Conﬁgurations α , β , tolerance ε > 0, box B 0 ∈ Rd .
Output: Path from α to β in Free( R 0 , ) ∩ B 0 .
Initialize a subdivision tree T with only a root B 0 .
1.
While (BoxT (α ) = FREE)
If (Expand BoxT (α ) fails) Return(“No Path”).
2.
While (BoxT (β) = FREE)
If (Expand BoxT (β) fails) Return(“No Path”).
3.
While (Find(BoxT (α )) = Find(BoxT (β)))
If Q T is empty, Return(“No Path”)
(*)
B ← T .getNext ()
Expand B
4.
Compute a channel P from BoxT (α ) to BoxT (β).
Generate a path P from P and Return( P )

In Step 4, the channel P is a sequence ( B 1 , . . . , B m ) of boxes where B i , B i +1 are adjacent. We also call P an F-channel
since the B i ’s are all free. We easily convert an F-channel into a path (or trajectory) which is a parametrized path P :
[0, 1] → C free from α to β . It is also easy to produce P that satisﬁes reasonable constraints such as smoothness. This ability
to generate a path is a beneﬁt of subdivision methods over pure algebraic methods. Freeness is essential for our use of the
extremely eﬃcient Union-Find data structure. The use of Union-Find was proposed in [21].
In contrast to F-channels, Zhu–Latombe [46] uses M-channels (comprised of FREE or MIXED leaf boxes). Their idea is to
attempt to ﬁnd an F-channel along the “shortest” M-channel, by expanding all the MIXED boxes in the channel. Subsequent
researchers (Barbehenn–Hutchinson [2] and Zhang–Manocha–Kim [45]) continued this approach. Barbehenn and Hutchinson
[2,1] introduced the highly eﬃcient Dijkstra or the related A* search. The challenge in their approach is how to eﬃciently
update the A*-structure after expansions along the M-channel.
The routine T .getNext() in Step (*) is not fully speciﬁed; the correctness of our planner also does not depend on
T .getNext(). Nevertheless, it is critical for performance. There are many possible strategies for implementing getNext ().
For instance, getNext() may return a random box in the queue, or use the BFS strategy. We can implement a Dijkstra-like or
A* strategy by letting getNext() return a mixed leaf that is adjacent to the connected component of BoxT (α ). By alternating
between two or more of these strategies, we get hybrid strategies. Another idea is to use some entropy criteria. Recent work
on shortest-path algorithms in GIS road systems offers many other heuristics.
Our FindPath algorithm is not our claim to novelty. Nevertheless, it has interesting features, including great potential for
adaptivity through its getNext() strategy. In contrast, non-adaptive uniform grid approaches (e.g., [21, p. 185]) are widely
used. Although grids are superﬁcially similar to subdivisions, grids use point-based operations while our theory is based on
box (interval) operations (see Section 4). Uniform grid translates into breadth-ﬁrst search strategy for getNext (), but we can
do much better.

C. Wang et al. / Computational Geometry 48 (2015) 589–605

593

Fig. 1. (a) Domains W + ( B ) and W − ( B ). (b) Condition (S1) holds. (For interpretation of the colors in this ﬁgure, the reader is referred to the web version
of this article.)

4. Let us design soft predicates!
The preceding FindPath is based on the exact predicate C ( B ). Our main interest in the Subdivision Method lies in its
ability to replace C ( B ) by some “soft” version C ( B ) which is easy to compute and correct in the limit. We now formalize
this.
¶4. Soft predicates Let C ( B ) be a box predicate that returns a value in {FREE, STUCK, MIXED}. We call C a soft version of
C if two conditions hold:
(A1) It is conservative, i.e., C ( B ) = MIXED implies C ( B ) = C ( B ).
(A2) It is convergent, i.e., if { B i : i = 1, 2, . . . , ∞} converges to a conﬁguration

γ , then C ( B i ) = C (γ ) for large enough i.

We need a quantitative measure of the convergence rate. Let 0 ≤ σ ≤ 1 and B be any class of boxes. A soft version C
of C is said to be σ -effective (or have effectivity factor σ ) for B if C ( B ) = FREE implies C (σ B ) = FREE for all B ∈ B
(recall that σ B is the congruent box centered at m( B ) with radius σ · r ( B )). One might imagine a stronger condition that
C ( B ) = MIXED implies C (σ B ) = MIXED for all B ∈ B , but our current deﬁnition suﬃces for our main Theorem A. For
example, we will prove that our soft predicates below are effective for any class B of boxes with bounded aspect ratio.
⊆ Rd is a polyhedral set, and the boundary of
is partitioned into a
We now design soft predicates C assuming
simplicial complex comprising relatively open cells of each dimension. For simplicity, assume d = 2. These cells are called
features of . The features of dimensions 0 and 1 are called corners and edges (resp.). Each box B is associated with three
sets: its outer domain W + ( B ), inner domain W − ( B ), and feature set φ( B ). When the robot R 0 ⊆ R2 is a ball of radius r0 ,
W + ( B ) ⊆ R2 and W − ( B ) ⊆ R2 are deﬁned as the disks D m( B ) (r0 + r ( B )) and D m( B ) (r0 − r ( B )), respectively. See Fig. 1(a). If
r0 < r ( B ), then W − ( B ) is empty. Also, φ( B ) comprises the features of
that intersect W + ( B ). We call B simple if one of
the following conditions holds:
intersects its outer domain W + ( B ).
(S0) Its feature set φ( B ) is empty. Equivalently, no feature of
−
intersects its inner domain W ( B ). Thus (S1) holds in Fig. 1(b) because of the red triangle obstacle.
(S1) Some feature of
The soft predicate C can now be deﬁned: for our purposes, we only need to deﬁne C ( B ) for aligned boxes B. Thus we can
use induction by depth. If B is non-simple, declare C ( B ) = MIXED. Else if (S1) holds, declare C ( B ) = STUCK. Otherwise, (S0)
holds and clearly B is either free or stuck, and we deﬁne C ( B ) = C ( B ) accordingly.
We now come to computing C ( B ), but only in the context where B is a leaf of a subdivision tree. Observe if B is a child
of B, then W + ( B ) is contained in W + ( B ). This implies the following distributional approach of computing φ( B ) is valid:
when we expand B, we can distribute the features in φ( B ) to each of its children. Note that a feature can be given to more
than one child, or to no child (when it intersects no W + ( B )). Moreover, we can check the conditions (S1) and (S0) during
this distribution. Finally, if (S0) holds, we determine C ( B ) as follows: C ( B ) = FREE (resp. STUCK) iff m( B ) is outside (resp.
inside) the obstacle . To decide between these two cases, note that by a linear search of the non-empty set φ( B .parent),
we can ﬁnd the feature f in φ( B .parent) that is closest to m( B ). We have 2 possibilities: (1) f is an edge. Assume that
edges are oriented so that we can decide using a orientation test whether m( B ) is inside or outside
in the neighborhood
of f . (2) f is a corner. We call f a convex (resp., concave) corner if, for any suﬃciently small ball D centered at f , the set
D∩
is a convex (resp., concave) set. Every corner is either convex or concave. Moreover, f is convex iff m( B ) is outside
(iff B is free).
is given as the union of a set of polygons that may overlap (this situation arises in Section 7). Moreover, φ( B )
Suppose
is deﬁned to comprise features in these (possibly overlapping) polygons. We extend the above FREE/STUCK test for (S0) as
follows: again linearly search φ( B .parent), and for each obstacle polygon S appearing in φ( B .parent), ﬁnd the feature
f ⊆ ∂ S that is closest to m( B ). Then m( B ) is outside
(and B is free) iff m( B ) is outside all such polygons S.

594

C. Wang et al. / Computational Geometry 48 (2015) 589–605

√

Fig. 2. Effectivity factor 1/ 2.

Lemma√1. The predicate C is a soft version of C for the ball robot R 0 ⊆ R2 . When boxes are squares, C√has an effectivity factor
σ = 1/ 2. More generally, if our boxes have aspect ratio at most α ≥ 1, then the effectivity factor is σ = 1/ 1 + α 2 .
Proof. To see the effectivity factor for square boxes, suppose that C ( B ) = FREE for some square B. Referring to Fig. 2, we
see that the region bounded by the outer four red segments and the outer four red circular arcs does not intersect the
obstacle set . Clearly, the dotted circle also does not intersect . Note that this dotted circle is centered at m( B ) with
√
radius r ( B ) = r + r0 , and√it is the boundary of the outer domain W + (σ B ) of box σ B whose radius is r,√where r = r ( B )/ 2.
This means that σ = 1/ 2 and we have C (σ B ) = FREE. Therefore, C has an effectivity factor σ = 1/ 2. In general, let B
be a rectangular box with dimensions 2w × 2α w. If B is free, there
√ is a disc centered at m( B ) of radius w + r0 that does
not intersect . This disc is the outer domain of σ B where σ = 1/ 1 + α 2 . ✷
The proof easily generalizes to ball robots in every dimension. We can now use the soft predicate C instead of the exact
predicate C to get a resolution-exact algorithm. This will be proved below. Of course, doing this for the disc robot is no
great achievement since the exact algorithm is actually quite practical too. But it lays the groundwork for generalization to
more complicated robots for which exact methods are no longer viable.
¶5. Implementability We claim that our algorithm is easy to implement correctly. We have designed our predicates so that
they are reduced to comparison of “distances” between sets. In particular, a feature f is in φ( B ) iff

Sep(m( B ), f ) ≤ r ( B ) + r0

(1)

where Sep( A , B ) is the separation between sets A and B. Notice that (1) is a comparison of two exact (!) expressions. There
are implicit square roots in these expressions, so an exact implementation would be expensive. But we are not obliged to
implement soft predicates exactly—this cannot be said for hard predicates. We provide a simple implementation method:
for any numerical expression x, let (x) or x denote any closed interval [a, b] that contains x. If the interval has width
at most 2− p , we also write p (x). Assume that for any expression x and any given p, we can compute some p (x). This can be
achieved with any software bigFloat package (e.g., GMP [14], MPFR [23]). We deﬁne the “lax comparison”
on intervals
whereby [a, b] [a , b ] holds iff a ≤ b . Note that the “strict comparison” would be b ≤ a . We implement the test (1) using
this lax comparison:
p (Sep(m( B ),

f ))

p (r ( B ) + r 0 )

(2)

where p = − lg r ( B ). Let C ( B ) be the “implemented” version of C ( B ).
Lemma 2. C ( B ) is a soft predicate for C ( B ).
Proof. Recall that φ( B ) is the set of features belonging to the box B. Suppose φ( B ) is the set of features that belong to B
when we use the lax comparison . The key observation is that x ≤ y implies p x
p y. This shows that φ( B ) ⊆ φ( B ).
The lax comparison (2) implies that

Sep(m( B ), f ) − r ( B ) ≤ (r ( B ) + r0 ) + r ( B )
or, Sep(m( B ), f ) ≤ 3 · r ( B ) + r0 . This shows that the extra features in φ( B ) must intersect the disc W + (3B ) (the outer
domain of 3B). If a sequence of boxes B i converges to a point q as i → ∞, we see that φ( B i ) → φ(q). This implies that the
approximate classiﬁcation C ( B i ) also converges to C (q). ✷
¶6. Improvements We can improve the convergence of our soft predicates. In practice, and typical of subdivision approaches,
such improvements can be quite signiﬁcant (e.g., see [39]). Let us deﬁne the set φ( B ) slightly differently, by recognizing two
regimes for boxes. In the “small B regime”, i.e., r ( B ) < r0 , we compute φ( B ) as before. In the√“large B regime”, i.e., r ( B ) ≥ r0 ,
we can deﬁne φ( B ) to comprise those features that intersect the box α B where α = 1 + 2r0 /r ( B ). Checking if a feature
intersects α B is simple. This new deﬁnition should generally result in smaller sizes for φ( B ). For a simple implementation,
condition (S1) could be omitted; its role is to provide an early stuck decision.

C. Wang et al. / Computational Geometry 48 (2015) 589–605

595

5. Resolution exactness
We have designed some non-trivial algorithms under our scheme. We now clarify what sort of algorithms these are.
Informally, our algorithms are “resolution complete”. There are slightly variant deﬁnitions, but a typical (e.g., [37]) deﬁnition
says “a planner is resolution complete if it ﬁnds a path if one exists provided the resolution parameters are selected small
enough”. This deﬁnition does not4 say what happens if there is no path. Some formulations appear to assume that the
resolution is not given but the planner has to search for it. Of course, this search would not terminate if there is no path.
Our algorithms in Section 4 (and in Section 6 as well) have an explicit input ε > 0, called the resolution parameter. It is
essential that ε be different from 0. To use this parameter, we recall the concept of “clearance”. Here is an attempt to deﬁne
resolution completeness with a converse: (i) if there is a path with clearance ε , the planner will ﬁnd a free path, and (ii) if there
is no path with clearance ε , it will report “NO PATH”. Taken together, this pair of statements cannot be the correct, as it implies
that, with suﬃcient resolution, we can detect the case where the clearance is exactly ε , a feat that only Exact Methods can
achieve (in which case we might as well design algorithms with ε = 0). What is missing in current discussions of resolution
completeness is the concept of an accuracy constant K > 1. We say that a planner is resolution-exact if there exists an
(accuracy) constant K > 1 that is independent of the input (but may depend on the algorithm) such that:

• If there is a path with clearance K ε , it outputs a path with clearance ε / K .
• If there is no path with clearance ε / K , it reports “NO PATH”.
What if the maximum clearance of free paths lies strictly in the range (ε / K , K ε ]? According to this deﬁnition, the planner is
free to report a path or “NO PATH”. In our Theorem A below, we prove that this cannot be avoided! This indeterminacy is the
necessary price to pay for resolution-exactness. In our view, this price is not a serious one because the user has the option to
decrease the ε parameter as desired. Of course, if we decrease ε to ε / K , the indeterminacy will reappear for input instances
that only have paths with clearance in the range (ε / K 2 , ε ]. But as argued in Section ¶1 there is no inﬁnite regress if we
know some hard engineering limits of how much clearance a path should have.
The result of Theorem A below concerns our algorithm Exact FindPath in Section ¶3 in the 2D case, assuming that all
boxes are squares and we use the exact classiﬁer predicate C ( B ). Recall that in our Exact FindPath algorithm, we subdivide
a box only if its width w ( B ) is larger than the input resolution parameter ε > 0. So the smallest boxes in the subdivision
tree T have width t with ε /2 < t ≤ ε . Now consider the “full expansion” of the subdivision tree T whose leaves are of the
smallest size possible. Recall from Section ¶3 that a channel is a sequence ( B 1 , . . . , B m ) where B i , B i +1 are adjacent. We are
interested in a free channel where α ∈ B 1 and β ∈ B m .
Lemma 3. If there exists a motion μ with clearance δ =

√

2ε , then our Exact FindPath algorithm outputs a path with clearance ε /4.

Proof. Consider the “full expansion” of T as mentioned above, where the leaves have a width t with ε /2 < t ≤ ε . Consider
the subset A of such leaves that cover μ. We claim
that
√
√ each leaf box in A is free: let p be a point in μ and B be the leaf
box where p lies; since the diagonal of B is 2t ≤ 2ε = δ , B lies entirely within the “clearance region” of p and thus
B is free. Therefore, A consists of free leaf boxes of width t that covers μ; in other words, A is a free channel
that
covers μ.
Since there exists a free channel
connecting α and β , our Exact FindPath algorithm will ﬁnd some free channel
connecting α and β (
is not necessarily , but at least
exists as a candidate to be found by our algorithm). This can
be justiﬁed as follows: consider the subdivision tree T produced by our algorithm. It produces a subdivision of ROI(T ), and
for each free box B in A, there is a corresponding free leaf B ∗ in T that contains B. These free leaves B ∗ , after pruning
redundancies, yield a free channel ∗ that covers . By deﬁnition of the correctness of any path ﬁnding algorithms, a free
channel
connecting α and β will be found iff there exists a free channel ∗ connecting α and β .
Note that
consists of free aligned boxes connecting from B (α ), the free (aligned) box containing α , to B (β), the free
(aligned) box containing β . Since each free box in
has width at least t, we can construct a rectilinear path P , from the
box center a of B (α ) to the box center b of B (β), through the free boxes in
where each point of P is away from the box
boundary by a distance at least t /2 (see Fig. 3 for an example), and thus P has clearance t /2 > ε /4.
Our ﬁnal reported path P f is given by P f = αa ∪ P ∪ bβ . It remains to show that αa has clearance ε /4 (and similarly

√

for bβ by the same argument). The key point is to use the fact that α belongs to μ and thus has a clearance δ = 2ε . We
consider the following two cases.
√ Case (1):
√ The width of B (α ) is t. Then for any point q ∈ αa, d(α , q) is at most half of the diagonal of B (α ), i.e., d(α , q) ≤
2t /2 ≤ 2ε /2 = δ/2. However, α has clearance δ , and thus q ∈ αa has clearance δ − d(α , q) ≥ δ/2 > ε /4.
Case (2): The width of B (α ) is at least 2t. We refer to Fig. 4, where the boundaries of the inner box and of B (α ) are
apart by a distance t /2. Clearly, any point of αa lying inside the inner box has clearance at least t /2 > ε /4. Now consider
the portion of αa outside the inner box. Without loss of generality, suppose such portion lies in the green shaded rectangle

4
In Computer Science, “completeness” concepts typically have some “if-and-only-if” connotation. Otherwise, they might be qualiﬁed as “partial completeness”. E.g., “partial correctness” of programs, or “partial decidability” of problems, etc.

596

C. Wang et al. / Computational Geometry 48 (2015) 589–605

Fig. 3. Path P from a to b with clearance t /2 > ε /4. A canonical path P ∗ consists of

Fig. 4. Segment

αa, bβ and essential path P , with essential clearance t /2.

αa has clearance ε /4.

and the slope of αa is in the range [0, 1] (for other cases the slopes are in the ranges (1, ∞), [−1, 0), and (−∞, −1)
and symmetric arguments apply). Note
w = t /2 and h ≤ w (since the slope of αa is in [0, 1]), the diagonal of the
√ that √
green shaded rectangle is at most 2t /2 ≤ 2ε /2 = δ/2, i.e., any point q ∈ αa lying in the green shaded rectangle has
d(α , q) ≤ δ/2. Since α has clearance δ , such q has clearance δ − d(α , q) ≥ δ/2 > ε /4. Therefore, every point of αa has
clearance ε /4. ✷
We deﬁne an essential path to be a path from the center a of a free box B (α ) containing α to the center b of a free box
B (β) containing β (e.g., path P in Fig. 3). A canonical path P ∗ consists of line segments αa, bβ , and an essential path P
from a to b. Note that the major task in motion planning is to ﬁnd an essential path P , while making P canonical by adding
αa and bβ is straightforward. We deﬁne the essential clearance of a canonical path to be the clearance of its essential path
(see Fig. 3).
Lemma 4. If there is no free canonical path with essential clearance ε /4, then our Exact FindPath algorithm reports “NO PATH”.
Proof. We prove the contrapositive: When our Exact FindPath algorithm ﬁnds a path, there exists a free canonical path
with essential clearance ε /4. Indeed, when our algorithm ﬁnds a free path, it ﬁnds a set of free aligned boxes connecting
from B (α ) to B (β). Since each such free box has width at least t, we can construct an essential path, which is a rectilinear
path P where each point of P is away from the box boundary by a distance at least t /2 (see Fig. 3). Clearly αa ∪ P ∪ bβ is
a free canonical path with essential clearance at least t /2 = ε /4. ✷
Putting together Lemmas 3 and 4, we have the following results for 2D, assuming that all boxes are squares and we use
the exact classiﬁer predicate C ( B ).
Theorem A (Hard predicate). Let K 0 , k0 ≥ 1 and consider our planner Exact FindPath.

√

(i) For K 0 = 2, if there is a path with clearance K 0 ε , then our planner outputs a path with clearance ε /4.
(ii) For k0 = 4, if there is no free canonical path of essential clearance ε /k0 , then our planner reports “NO PATH”.
The results in (i) and (ii) are tight in the following sense:

√

(i ) If K 0 < 2, there are obstacle inputs admitting paths with clearance K 0 ε , but our planner reports “NO PATH”.
(ii ) If k0 < 4, there are obstacle inputs admitting no paths of clearance ε /k0 but our planner outputs a path.

C. Wang et al. / Computational Geometry 48 (2015) 589–605

597

Fig. 5. Proof of Theorem A (i ).

Fig. 6. Proof of Theorem A (ii ). (For interpretation of the colors in this ﬁgure, the reader is referred to the web version of this article.)

Proof. (i) and (ii) are Lemmas
√ 3 and 4 respectively.
(i ). Consider any K 0 < 2. We can have an obstacle input
such that it admits a path with clearance K 0 ε , where α
lies in the aligned box B = B (α ) of our subdivision tree, with width w ( B√
) = ε , but the robot center cannot be placed in the
red shaded triangle region (see Fig. 5). Note that the diagonal of B is 2ε and α can still have clearance K 0 ε . However,
B is a mixed box with w ( B ) = ε and thus the expansion of B fails. Therefore, our planner reports “NO PATH”.
(ii ). Suppose k0 < 4. Let δ := 4 − k0 . We now construct an input for our algorithm. Let

B 0 = [−4, 4] × [−4, 4],

r0 < 1.9,

ε = 4 − (δ/2),

α = (−3, 1), β = (3, 1),
and
is the union of two half spaces, {(x, y ) ∈ R2 : y ≤ −u − r0 } and {(x, y ) ∈ R2 : y ≥ 2 + u + r0 } for some small u ∈
(0, 2 − r0 ) to be determined. See Fig. 6, where is shown in yellow.
Using an exact classiﬁcation predicate, we will subdivide until we obtain a “linear” channel of boxes from B (α ) to B (β)
(shown in green in Fig. 6). Note that each box in this channel has width 2 and the straightline path from α to β has
clearance 1 + u. So our algorithm will output the straightline path from α to β . Note that this path has clearance 1 + u
(which is in fact the largest clearance possible, but the algorithm does not actually know this clearance). We shall choose u
to fulﬁll

1+u<

ε
k0

=

4 − (δ/2)
4−δ

,

(3)

i.e., the largest clearance of any paths, 1 + u, is less than ε /k0 , so that
admits no paths of clearance ε /k0 . Here (3) is
true iff u < (1/2)(δ/k0 ). Note that the ratio δ/k0 could be large, but recall that u ∈ (0, 2 − r0 ) (where r0 < 1.9) from our
construction. So we can pick u = min{(1/3)(δ/k0 ), 1.9 − r0 } to fulﬁll both conditions. ✷
Theorem A implies an accuracy factor K = 4, but it is clear that K can be reduced by adjusting our algorithm to use the
resolution parameter ε in a more equitable way.
The general form of this result is perhaps no surprise, but the accuracy constants might not be what we initially expect,
since we are talking about an “exact algorithm”. There are several sources for loss of accuracy: ﬁrst, subdivision boxes are
“aligned” with the integer grid in the sense that their coordinates are dyadic numbers. Second, the width of our smallest
boxes, the ε -MIXED boxes, lies between ε /2 and ε . The third is the use of soft predicates. In particular, what is the accuracy
of our prototype algorithm in Section ¶3 when using the soft predicates of Section ¶4? Recall from Lemma 1 that when
√
boxes are squares, our soft predicate C has an effectivity factor σ = 1/ 2. In our algorithm, we can replace our input

598

C. Wang et al. / Computational Geometry 48 (2015) 589–605

resolution parameter with ε¯ = σ ε , i.e., we split boxes until the smallest box width is between ε¯ /2 and ε¯ (between
and σ ε ).
Lemma 5. If there exists a motion μ with clearance δ =
σ ε/4.

√

σ ε /2

2ε , then our algorithm using soft predicate C outputs a path with clearance

Proof. This is a “soft version” of Lemma 3. Consider the “full expansion” of our subdivision tree T ; now the smallest boxes
have width σ t (instead of t). Look at the subset A of such leaf boxes that cover μ. For each such leaf box B , let B /σ
be the box centered at m( B ) with width t. We claim
√ that
√ B /σ is free: let p be a point on μ that lies in B ; clearly
p also lies in B /σ . Since the diagonal of B /σ is 2t ≤ 2ε = δ , B /σ lies entirely within the “clearance region” of p
and thus B /σ is free. Therefore, we have C ( B /σ ) = FREE. By the effectivity factor σ for C , C ( B /σ ) = FREE implies
C ( B ) = C (σ ( B /σ )) = FREE. Therefore, we can use C to classify each B to be free, and thus to classify A as a free
channel covering μ. This is the same as the free channel A covering μ in the proof of Lemma 3, but now each channel
box has width σ t rather than t. The rest of the proof of Lemma 3 carries over, with the reported path having a clearance
σ ε/4 rather than ε/4. ✷
Lemma 6. If there is no free canonical path with essential clearance σ ε /4, then our algorithm using soft predicate C reports “no path”.
Proof. This is a “soft version” of Lemma 4. Again we prove the contrapositive: When our algorithm ﬁnds a path, there exists
a free canonical path with essential clearance σ ε /4. The proof of Lemma 4 carries over, but now each free aligned box has
width σ t rather than t, and thus the essential clearance is at least σ t /2 = σ ε /4. ✷
We re-state Lemmas 5 and 6 together in the following.
Theorem B (Soft predicate). With the same assumptions as Theorem A, but with the exact predicate C ( B ) replaced by a soft predicate
C ( B ) with effectivity factor σ , we have:

√

(i) For K 0 = 2, if there is a path with clearance K 0 ε , then our planner outputs a path of clearance σ ε /4.
(ii) For k0 = 4, if there is no free canonical path with essential clearance σ ε /k0 , then we report “NO PATH”.
This implies that the accuracy factor K now becomes 4/σ . In general, we have:
Corollary. If the Exact version of our planner has an accuracy factor of K , then the Soft version of our planner using a soft predicate
with effectivity factor σ has an accuracy factor of K /σ .
6. Rotational degree of freedom
In this section we develop resolution-exact algorithms for the case where robot R 1 ⊆ R2 has a simple shape: R 1 is a
triangle that is contained in a circumscribing disc R 0 of radius r0 . Now, C space = S E (2) = R2 × S 1 . Each box B ⊆ C space is
decomposed as R ×
where R ⊆ R2 is a rectangle and
⊆ S 1 is an angular range. We also write m( R ), r ( R ), w ( R ) to
denote the previously deﬁned m( B ), r ( B ), w ( B ). Two boxes B = R ×
and B = R ×
are adjacent iff R and R are
adjacent, and
and
are adjacent in the circular geometry of S 1 .
¶7. ε -smallness We discuss the issue of splitting B = R × : we can obviously simply split B into 8 congruent children.
However there are two issues. First of all, we may want to avoid splitting the angular range when B is in the “large regime”:
as long as w ( R ) ≥ r0 , we can approximate R 1 by the disc R 0 and ignore the rotational degree of freedom. So B is split into
4 children (based on splitting R but not ). When B is in the “small regime”, i.e., w ( R ) < r0 , we begin to split the angular
range. But here, we want to treat
differently from R. To understand this, recall that we previously do not split a box R
when w ( R ) ≤ ε . Let us say that R is ε -small if w ( R ) ≤ ε . We need a similar criterion for : say
is ε -small if | | ≤ ε /r0 .
This assumes that angles are in radians, and
is represented as an interval [θ1 , θ2 ] ⊆ [0, 2π ]; also | | is deﬁned as θ2 − θ1 .
Finally, we say that B = R ×
is ε -small if both R and
are ε -small. We now deﬁne our procedure Split( B , ε ) as
follows: to split B, we split R and
separately. These are not split if they are already ε -small. Thus, splitting B will result
in 2i children for i = 0, 1, 2, 3. The following justiﬁes our deﬁnition of ε -smallness:
Lemma 7. Assume 0 < ε ≤ π /2. If B = R × √is ε -small and R is a square, then the Hausdorff distance between the footprints of R 1
at any two conﬁgurations in B is at most (1 + 2)ε .

C. Wang et al. / Computational Geometry 48 (2015) 589–605

599

Fig. 7. Shaded areas represent round triangles: (i) aa bb cc with 3 straight edges, (ii) ab cc with 2 straight edges. In (i), the round triangle aa bb cc is
T ∩ D where T is the triangle ( A , B , C ) and D is the (white) disk.

Fig. 8. Enclosing circle of enclosing rectangle for obtuse triangle: their rotation. (For interpretation of the colors in this ﬁgure, the reader is referred to the
web version of this article.)

Proof. This result uses the fact that if we rotate R 1 by θ about the center of R 0 , then the vertices of R 1 move by at most
2r0 sin(θ/2) ≤ r0√
θ ≤ ε since sin θ ≤ θ for θ in the said range. Also, the translational distance between any two conﬁgurations
in B is at most 2ε . ✷
¶8. Soft predicate for rotation We now design a soft version C of C . The strategy follows the case of disc robot: we deﬁne the
feature set φ( B ) associated with a box B = R ×
as comprising those features of
that intersect the set W + ( B ) where
+
W ( B ) is a “round triangle” associated with B. We call RT a round triangle if it is given as the intersection of a disc D
with a triangular region T (see Fig. 7).
For any real number s, we denote the s-expansion of various shapes S ⊆ R2 by ( S )s . If S = D (m, r ) is a disc,
( D )s := D (m, r + s). If S a convex polygon P , then ( P )s is the polygon obtained by shifting each deﬁning line of its edges in
an outward normal direction by a distance of s. Typically, P is a triangle or a box. Finally, if S is a round triangle RT = D ∩ T ,
then (RT )s = ( D )s ∩ ( T )s . Note that (RT )s depends on the representation D and T . Usually we have s ≥ 0; if s < 0, then RT
is shrunk and (RT )s may be the empty set.
Consider a conﬁguration (m, θ) ∈ C space ; the footprint R 1 [m, θ] is a triangle in D m (r0 ). Let RT (m, ) be the convex hull
of the union of these footprints as θ ranges over . Note that RT (m, ) is a round triangle. In Fig. 7, we show RT (m, ) for
two choices of R 1 . We deﬁne the outer domain W + ( B ) to be the r ( B )-expansion of RT (m( B ), ). As before, the feature set
φ( B ) is deﬁned as those features of that intersect W + ( B ). Finally, we deﬁne C ( B ) using φ( B ) as before. Computing C ( B )
in the context of expanding a subdivision tree is also similar.
Lemma 8. C is a soft version of C for the robot R 1 . Also C is effective for the class of squares.
¶9. Improvements We can improve by providing some heuristic for quick detection of stuck boxes, in analogy to Property
(S1) for a disc robot. For any box B, we can deﬁne an inner domain W − ( B ) such that if any feature intersects W − ( B ), then
B is stuck. Indeed W − ( B ) can be deﬁned to be a suitable triangle: in Fig. 7(i), W − ( B ) is the triangle bounded by the lines
ab , bc and ca .
Our deﬁnition of R 0 as the circumscribing circle for R 1 can lead to extremely large radius r0 when R 1 is a very thin
obtuse triangle. We describe an alternative: when R 1 is obtuse, we will deﬁne R 0 as the smallest disc containing R 1 . Choose
the robot origin to be the center of this new R 0 . Thus, the longest side of R 1 will be a diameter of R 0 , and one vertex of
R 1 will be in the interior of R 0 . This is illustrated in Fig. 8 where the red and blue vertices of R 1 deﬁne a diameter of the
circle C , but the green vertex lies on a concentric inner circle C . The interior of C is pink in this ﬁgure. If we slightly rotate
the robot R 1 counter-clockwise about the center of C , the boundary of the area swept by R 1 will include a small arc of C .
The convex hull of this swept area will comprise of 3 arcs, two arcs from C and one arc from C . We can again construct a
soft predicate based on such a convex hull, but this variation has not been implemented.

600

C. Wang et al. / Computational Geometry 48 (2015) 589–605

Fig. 9. Subdivision for disc robot. Color scheme: Green = FREE, Red = STUCK, Yellow = ε -large MIXED, Grey = ε -small MIXED. (For interpretation of the
references to color in this caption, the reader is referred to the web version of this article.)

Fig. 10. Subdivision for triangular robot: translational boxes show blended colors. (For interpretation of the references to color in this caption, the reader is
referred to the web version of this article.)

7. Experimental results
We have implemented in C++ the planner for disc and triangle robots described in this paper. Our code, data and
experiments are freely distributed with the Core Library5 and is available on our project web page. The platform for
the experiments was a Linux Fedora 16 OS with a 3.4 GHz Intel Quad Core CPU, and 16 GB RAM. Our current implementation
does not apply the technique of “lax comparison” in Section ¶5. Instead, we use machine arithmetic. This is because in our
examples, the subdivision boxes are large enough that machine arithmetic suﬃces. In the future, we plan to provide error
estimates to justify this expedient.
Figs. 9 and 10 show the GUI interface of our implementation of the disc and triangle robots, respectively. Since C space =
R2 for a disc, it is straightforward to visualize the box classiﬁcation in a subdivision, as illustrated in Fig. 9. For a triangle
robot, each box B ⊆ C space = R2 × S 1 has the form B = B t × B r where B t is the translational component. The color of B is
projected onto B t . We display a blended color of all boxes that project to B t .
We implemented the following three search strategies: Breadth First Search (BFS), Random (RAN), and Greedy Best First
(GBF). In BFS and Random, we follow the original scheme described in Section ¶3, where a union-ﬁnd data structure is
used to determine if the leaf boxes BoxT (α ) and BoxT (β) belong to the same connected component of the adjacency
5

http://cs.nyu.edu/exact/core/download/core/.

C. Wang et al. / Computational Geometry 48 (2015) 589–605

601

Fig. 11. Bugtrap.

Fig. 12. Input200: 200 random triangles.

graph comprising the FREE-leaves in T . The MIXED-leaves of width > ε are stored in a priority queue Q as candidates for
expansion. The only difference between these two strategies is that BFS picks a box in Q with the maximum size to expand,
while Random picks a random box in Q to expand.
In GBF, we do not use a union-ﬁnd data structure; rather, we maintain a set Sα of leaves of T which are FREE and
connected to BoxT (α ). Boxes in Sα are said to be “marked”. A path is detected as soon as BoxT (β) is marked. Initially,
BoxT (α ) is the only marked box. The priority queue Q contains all the FREE- or MIXED-leaves of T that are on the
“fringe” of Sα (a “fringe box” is unmarked but adjacent to some marked box). The priority of a box B in the queue is the
“distance” from B to β . In case of a disc robot, this “distance” is the Euclidean distance from m( B ) to β ∈ R2 . In case of
a triangle robot, let B = B t × A where B t ⊆ R2 is the translational component of B, and A an angular range. Similarly,
β = (βt , θ) where βt ∈ R2 . Then “distance” is the Euclidean distance between m( B t ) and βt . Moreover, Q is a min-priority
queue, so that box with the smallest distance to β has highest priority. We terminate with “NO PATH” if Q is empty;
otherwise let B be a box extracted from Q for expansion. There are two cases: (1) If B is free, we mark B (i.e., add it to
the set Sα ) and for each neighbor B of B, we push B into Q if it is unmarked and is either FREE or MIXED. (2) If B is
mixed, we ﬁrst check its width. If the width is ≤ ε , we discard B. Otherwise we expand B, and for each child B of B, we
push B into Q if it is adjacent to a marked box and is either FREE or MIXED.
We use four input ﬁles: bugtrap, input150, input200, input300. Each ﬁle represents the environment as a set of polygons
(not necessarily disjoint) within a 512 × 512 bounding box. The ﬁle inputNNN (where NNN = 150, 200 or 300) contains
NNN randomly generated triangles. Three of these environments are shown in Figs. 11, 12, 13. The polygons edges are

602

C. Wang et al. / Computational Geometry 48 (2015) 589–605

Fig. 13. Input300: 300 random triangles.

shown in white (Fig. 11) or in blue (Figs. 12, 13). The paths found by our GBF search strategy are also shown (“NO PATH”
in Fig. 11). We can see that the triangles may overlap, which can be handled by our approach easily.
In the following we present Table 1. The top shows the statistics of running our planners for disc and triangle robots on
each input. The starting and ending conﬁgurations α and β are shown as (x, y ) for disc robot and (x, y , θ) for triangle robot.
The disc robot is speciﬁed as disc(r , Z ) where r is the robot radius and Z ∈ {BFS, GBF , RAN} indicates the search strategy.
Similarly, the triangle robot is speciﬁed by tri(r , Z ). Whenever the randomized strategy Z = RAN is used, the statistics is
the average of 5 runs; these are reproducibly encoded in Makeﬁle targets in Core Library. Of the 3 strategies, we see
that GBF is consistently the fastest. We have columns reporting the number of free, stuck, and mixed boxes. There were
two kinds of mixed boxes: those of width > ε and the rest. Note that when the number of mixed boxes of width > ε is
zero (last column), this implies ‘NO PATH’. Excluding the cases of “Expanding BoxT (α ) fails” and “Expanding BoxT (β) fails”
(trivial cases of ‘NO PATH’), the converse is true only for the BFS or Random search strategy.6 We explicitly mark the entries
in the last column with an asterisk (*) to indicate ‘NO PATH’.
We also directly compared our triangle robot with the GBF strategy (the instances of the top-table entries in bold, also
shown in Figs. 11–13) with PRM and RRT, and show the results in the bottom table. For PRM, we ran the benchmark
package OOPSMP [25], and the running times are shown as preprocessing, query, and total times in the bottom table. For
RRT, we ran OOPSMP (denoted “RRT-OOP” in the table), the code by Prof. Jyh-Ming Lien (denoted “RRT-JML” in the table)
of the robotics group in George Mason University, and the MSL library from Prof. Steven Lavalle’s group in University of
Illinois (UIUC). MSL did not seem to work well for our datasets of bounding boxes 512 × 512 (all its examples are of small
bounding boxes 100 × 100) so we do not include its results in the table.
We remark that our only parameter is ε > 0. For PRM, OOPSMP requires user-chosen parameters like number of sample
points, budgeted times for preprocessing and query, with default values 5000 points, 5 s and 5 s. Ideally, one would like
to have an automatic process to ﬁnd an optimal number of sample points that can result in a free path (if one exists).
Unfortunately, the PRM of OOPSMP is poorly designed for such experiments, since each run needs user interactions to
specify the parameters and other settings, and hence we were not able to make the process automatic. We did experiment
with one instance, on bugtrap with triangle robot of radius 22 (i.e., the instance with No. 7, bugtrap (22), in the two tables):
we ﬁrst tried with 1000 sample points (33 ms), no path found, then increased for another 1000 samples (another 34 ms)
to get 2000 samples, still no path. We then repeated the incremental process: another 1000 samples were added (another
34 ms) to get 3000 samples total, no path; ﬁnally, after adding 1000 more samples (another 36 ms, 4000 samples total),
a free path was found (via query) in 3 ms. Overall, the incremental sampling up to 4000 points took 137 ms overall, plus
the ﬁnal query time of 3 ms, thus a total of 140 ms (plus much longer user interaction time!). For all other runs of PRM,
we just used the default values (5000 samples), and increased the number of samples if 5000 was not enough to ﬁnd a
path. For RRT, the RRT of OOPSMP (RRT-OOP) does not allow the user to ﬁne-tune any parameters, while RRT-JML provides
additional ﬂexibility to adjust parameters such as step size and goal bias, for which we tried for each instance to ﬁnd
reasonable values to use; the resulting number of samples are also shown in the table.
From the top portion of the bottom table, we see that our running times are competitive with PRM and RRT: among the
8 instances listed, we are the fastest in 4 of them, and the second fastest in another 3 of them; for the remaining instance

6

We do not include the instances of such trivial cases of ‘NO PATH’ in our tables here.

C. Wang et al. / Computational Geometry 48 (2015) 589–605

603

Table 1
In the top table, the effect of increasing ε is seen in the ﬁrst three rows. The ‘NO PATH’ instances are marked with “(*)” in the last column. In the bottom
table, each row is an instance of the row in the top table with the corresponding line number (the “No.” entry). Among the running times of various
methods, the winner is shown in bold, and our results marked with “†” are the second fastest. The ‘NO PATH’ instances are marked with “(*)” in the ﬁrst
column.
No.
1
2
3
4
5

Obstacle
(input)

Robot
(radius)

α

β
(x, y , θ)

eps

(x, y , θ)

bugtrap

disc(14, GBF)
disc(14, GBF)
disc(14, GBF)
disc(15, GBF)
disc(25, GBF)

200, 350
200, 350
200, 350
200, 350
200, 350

60, 50
60, 50
60, 50
60, 50
60, 50

1
2
4
0.5
1

tri(14, GBF)
tri(22, GBF)
tri(50, GBF)

200, 350, 0
200, 350, 0
200, 350, 0

60, 50, 0
60, 50, 0
60, 50, 0

6
7
8
9

input150

10
11
12
13
14
15

input200

16
17
18
19
20
21

input300

22
23
24
25

No.

6
7
8 (*)
10
13
16
22
25

4
5 (*)
15
21

Time
(ms)

Free

Stuck

Mixed

Mixed

≤ε

>ε

16
10
5
30
18

3867
1779
854
8036
3260

2076
943
460
4193
1709

3403
1750
801
6887
2984

462
275
151 (*)
913
415 (*)

5
5
5

245
482
746

19 394
39 482
55 864

26
1556
4153

31 121
57 546
79 411

220
3880
9025 (*)

disc(7, RAN)

200, 270

20, 20

2

428

6892

10 082

8027

1955

tri(7, GBF)
tri(7, BFS)
tri(7, RAN)
tri(7, GBF)

200, 270, 0
200, 270, 0
200, 270, 0
325, 425, 0

20, 20, 0
20, 20, 0
20, 20, 0
20, 20, 0

5
5
5
5

10
1349
315
216

945
152 841
32 179
10 233

0
366
1028
129

1334
0
101 322
19 382

360
608 432
32 477
1389

disc(5, BFS)
disc(5, GBF)

130, 460
130, 460

20, 20
20, 20

2
2

16
15

2590
283

4891
99

0
230

5636
131

tri(5, GBF)
tri(5, BFS)
tri(5, RAN)

130, 460, 0
130, 460, 0
130, 460, 0

20, 20, 0
20, 20, 0
20, 20, 0

2
2
2

89
1742
3940

16 866
182 866
331 830

160
1036
7044

0
0
0

29 602
747 445
1 408 722

disc(7, BFS)
disc(7, BFS)
disc(3, GBF)

230, 210
230, 210
230, 210

480, 10
480, 10
480, 10

4
1
1

23
35
29

3785
6439
3986

11 284
15 339
1760

7465
0
3529

tri(7, GBF)
tri(7, BFS)
tri(7, RAN)
tri(7, GBF)

230, 210, 0
230, 210, 0
230, 210, 0
10, 500, 0

480, 10, 0
480, 10, 0
480, 10, 0
480, 10, 0

4
4
4
4

32
2101
7470
478

5212
110 005
371 119
25 893

0
667
8539
106

0
0
0
42 274

Obstacle
input ﬁle
(robot radius)

Tri(GBF)
Time
(ms)

PRM
No. of
samples

Prep.
(ms)

Query
(ms)

Total
(ms)

No. of
samples

RRT-JML
Step
size

Goal
bias

bugtrap (14)
bugtrap (22)
bugtrap (50)
input150 (7)
input150 (7)
input200 (5)
input300 (7)
input300 (7)

245
482 †
746
10
216
89
32 †
478 †

5000
5000
125 000
5000
5000
5000
5000
5000

256
270
32 368
176
176
203
145
145

3
3
7
2
2
5
0.3
0.3

259
273
32 375
178
178
208
145.3
145.3

37 009
156 276
500 000
4309
7635
18 757
3538
57 619

0.05
0.01
0.01
0.05
0.05
0.05
0.05
0.05

0.5
0.1
0.1
0.5
0.5
0.5
0.5
0.5

Obstacle
input ﬁle
(robot radius)

Disc(GBF)
Time
(ms)

PRM
No. of
samples

Prep.
(ms)

Query
(ms)

Total
(ms)

No. of
samples

Step
size

Goal
bias

bugtrap (15)
bugtrap (25)
input200 (5)
input300 (3)

30
18
15
29

25 000
125 000
5000
5000

2135
22 594
23 438
765

9
3
7
2

2144
22 597
23 445
767

N/A
N/A
N/A
N/A

Time
(ms)
922
24 092
134 912
270
375
1624
398
2390

RRT-JML
Time
(ms)

0 (*)
11 052
1001
11 686
899 054
2 694 907
2245

RRT-OOP
Time
(ms)
277
796
60 000
17
62
151
14
945
RRT-OOP
Time
(ms)
3979
60 000
2335
1129

we are the third. In some cases we are much faster than all others. In particular, for the instance of ‘NO PATH’ (No. 8),
our method stopped and reported ‘NO PATH’ easily in 746 ms, while for PRM we gave up after trying 125 000 samples
(32 375 ms), for RRT-JML we gave up after trying the run of 500 000 samples (1 34 912 ms), and for RRT-OOP we gave up
after using up the maximum allowed run-time of 60 000 ms. Clearly our method is much more advantageous.
Finally, we compared our disc robot with PRM and RRT-OOP (we do not have the RRT-JML code for disc robot). For both
PRM and RRT-OOP, the robot must be a polygon; we approximated the disc robot by a same-radius regular 20-gon. The
results are shown in the bottom portion of the bottom table. Note that for the row of No. 4, PRM used 25 000 samples since
no path was found for 5000 samples. For the row of No. 5, which is an instance of ‘NO PATH’, for PRM we gave up after
using 125 000 samples, and for RRT-OOP we gave up after using up the maximum allowed run-time of 60 000 ms. From the
table, we can see that clearly our method is signiﬁcantly faster than all others in all instances.

604

C. Wang et al. / Computational Geometry 48 (2015) 589–605

8. Conclusions
The motion planning literature has a bipolar nature—many algorithms are theoretically sound but unimplementable, others are practical but lack theoretical foundations or proper implementation. The dominant approach based on randomization
offer some theoretical guarantees but they have issues: there are no guarantees in case of NO PATH, and “expansiveness”
assumptions [18] are non-veriﬁable. This paper takes up the classic subdivision paradigm to develop a theoretically sound
alternative. To aid the development of such algorithms, we introduce soft predicates and demonstrated their use in subdivision planners. We introduced the concept of resolution-exact planners, and designed the ﬁrst examples of such algorithms.
We also show the inherent indeterminacy of resolution-exactness. Finally, our implementations validate the claims that our
theory is practical; the experiments demonstrate that our approach is competitive with PRM in speed, despite our much
stronger guarantees.
According to Zhang et al. [45], implementations of exact motion planning algorithms are only known for simple planer
robots (like ladders or discs) and up to 3 degrees of freedom. Thus it is important to pay attention to implementability. We
propose to give up exactness for the weaker notion of resolution-exactness. Little is lost by this step, since exact algorithms
are ill-matched to the inherent inaccuracies of physical systems. But we have much to gain: Subdivision algorithms are more
holistic, integrating the concerns of topological correctness with geometric accuracy into one algorithm.
The techniques of this paper can be extended to robots with complex geometry (e.g., the “gear” robot [45]). We could
decompose the complex robot geometry into a union of (possibly overlapping) triangles. If we now have soft predicates for
each of the triangle robots, we could compose them into a soft predicate for the complex robot. This remarkable decomposition property of soft predicates has no analogue in exact algorithms. A subtlety is that the triangle robots are not free to
choose its origin; this freedom was exploited in Section 6 above. This extension will be described in a followup work.
Several open problems are raised by this research. (1) Clearly, a more general theory of subdivision planners can be
developed; see our companion paper [44] where many of the ideas here are generalized. (2) We can extend our work to
subdivision of SE(3) = R3 × SO(3), and believe this too can be competitive with PRM. Note that no general exact algorithms
have been implemented for SE(3). (3) Note that we have not tried to compute the connected components of STUCK boxes.
Doing this can lead to fast termination in the case of “NO PATH”. However, maintaining this information runs into interesting
issues of computational topology. Edelsbrunner and Delﬁnado’s work on computing the Betti number of a 3-complex offers
some clues here [11]. (4) General investigation of various search strategies, including probabilistic ones is needed.
We plan to explore other variants of our search strategies with an eye to simplicity, implementability, and correctness.
Our approach can be extended to more demanding motion planning problems such as kinodynamic problems or those with
differential constraints.
Acknowledgements
We thank Prof. Jyh-Ming Lien and his student Zhonghua Xi for sharing their RRT code with us, which was used to
conduct some of the experiments in this paper.
References
[1] M. Barbehenn, S. Hutchinson, Eﬃcient search and hierarchical motion planning by dynamically maintaining single-source shortest paths trees, IEEE
Trans. Robot. Autom. 11 (2) (1995).
[2] M. Barbehenn, S. Hutchinson, Toward an exact incremental geometric robot motion planner, in: Proc. Intelligent Robots and Systems 95, vol. 3, IEEE/RSJ
Intl. Conf., 5–9 Aug 1995, Pittsburgh, PA, USA, 1995, pp. 39–44.
[3] R. Bohlin, L. Kavraki, A randomized algorithm for robot path planning based on lazy evaluation, in: P. Pardalos, S. Rajasekaran, J. Rolim (Eds.), Handbook
on Randomized Computing, Kluwer Academic Publishers, 2001, pp. 221–249.
[4] M. Brady, J. Hollerbach, T. Johnson, T. Lozano-Perez, M. Mason, Robot Motion: Planning and Control, MIT Press, 1982.
[5] R.A. Brooks, T. Lozano-Perez, A subdivision algorithm in conﬁguration space for ﬁndpath with rotation, in: Proc. 8th Intl. Joint Conf. on Artiﬁcial
Intelligence, vol. 2, San Francisco, CA, USA, Morgan Kaufmann Publishers Inc., 1983, pp. 799–806.
[6] M. Burr, F. Krahmer, SqFreeEVAL: an (almost) optimal real-root isolation algorithm, J. Symb. Comput. 47 (2) (2012) 153–166.
[7] M. Burr, F. Krahmer, C. Yap, Continuous amortization: a non-probabilistic adaptive analysis technique, Electron. Colloq. Comput. Complex. TR09 (December 2009) 136.
[8] J. Canny, Computing roadmaps of general semi-algebraic sets, Comput. J. 36 (5) (1993) 504–514.
[9] E.-C. Chang, S.W. Choi, D. Kwon, H. Park, C. Yap, Shortest paths for disc obstacles is computable, in: 21st ACM Symp. on Comp. Geom., June 5–8, Pisa,
Italy, 2005, pp. 116–125.
[10] H. Choset, K.M. Lynch, S. Hutchinson, G. Kantor, W. Burgard, L.E. Kavraki, S. Thrun, Principles of Robot Motion: Theory, Algorithms, and Implementations,
MIT Press, Boston, 2005.
[11] C. Delﬁnado, H. Edelsbrunner, An incremental algorithm for Betti numbers of simplicial complexes on the 3-sphere, Comput. Aided Geom. Des. 12
(1995) 771–784.
[12] B. Donald, P. Xavier, Provably good approximation algorithms for optimal kinodynamic planning: robots with decoupled dynamics bounds, Algorithmica
14 (1995) 443–479.
[13] S.J. Fortune, A sweepline algorithm for Voronoi diagrams, Algorithmica 2 (1987) 153–174.
[14] GNU MP Homepage, Since 1991, GNU MP (=GMP) is a free C++ library for arbitrary precision arithmetic on integers, rationals and ﬂoating point
numbers, URL http://gmplib.org.
[15] D. Halperin, L. Kavraki, J.-C. Latombe, Robotics, in: J.E. Goodman, J. O’Rourke (Eds.), Handbook of Discrete and Computational Geometry, CRC Press LLC,
1997, pp. 755–778, Chap. 41.
[16] K. Hauser, Motion planning for legged and humanoid robots, PhD thesis, Department of Computer Science, Stanford University, 2008.

C. Wang et al. / Computational Geometry 48 (2015) 589–605

605

[17] M. Hemmer, O. Setter, D. Halperin, Constructing the exact Voronoi diagram of arbitrary lines in three-dimensional space, in: Algorithms—ESA 2010, in:
Lecture Notes in Computer Science, vol. 6346, Springer, Berlin/Heidelberg, 2010, pp. 398–409.
[18] D. Hsu, J.-C. Latombe, H. Kurniawati, On the probabilistic foundations of probabilistic roadmap planning, Int. J. Robot. Res. 25 (7) (2006) 627–643.
[19] L. Kavraki, P. Švestka, C. Latombe, M. Overmars, Probabilistic roadmaps for path planning in high-dimensional conﬁguration spaces, IEEE Trans. Robot.
Autom. 12 (4) (1996) 566–580.
[20] J.-C. Latombe, Robot Motion Planning, Kluwer Academic Publishers, 1991.
[21] S.M. LaValle, Planning Algorithms, Cambridge University Press, Cambridge, 2006.
[22] R.E. Moore, Interval Analysis, Prentice Hall, Englewood Cliffs, NJ, 1966.
[23] MPFR Homepage, Since 2000, MPFR is a C++-library for multi-precision ﬂoating-point computation with exact rounding modes, URL http://www.mpfr.
org/.
[24] C. Ó’Dúnlaing, C.K. Yap, A “retraction” method for planning the motion of a disc, J. Algorithms 6 (1985) 104–111. Also, Chap. 6 in: Sharir, Schwartz,
Hopcroft (Eds.), Planning, Geometry, and Complexity, Ablex Pub. Corp., Norwood, NJ, 1987.
[25] E. Plaku, K. Bekris, L. Kavraki, OOPS for motion planning: an online open-source programming system, in: IEEE Intl. Conf. Robotics and Automation,
2007, pp. 3711–3716.
[26] J.H. Reif, H. Wang, Nonuniform discretization for kinodynamic motion planning and its applications, SIAM J. Comput. 30 (2000) 161–190.
[27] M. Sagraloff, When Newton meets Descartes: a simple and fast algorithm to isolate the real roots of a polynomial, in: Proc. ISSAC 2012, 2012,
pp. 297–304.
[28] M. Sagraloff, C.K. Yap, A simple but exact and eﬃcient algorithm for complex root isolation, in: I.Z. Emiris (Ed.), 36th Int’l Symp. Symbolic and Alge.
Comp., June 8–11, San Jose, California, 2011, pp. 353–360.
[29] O. Salzman, M. Hemmer, B. Raveh, D. Halperin, Motion planning via manifold samples, in: Proc. European Symp. Algorithms (ESA), 2011.
[30] J.T. Schwartz, M. Sharir, On the piano movers’ problem: I. The case of a two-dimensional rigid polygonal body moving amidst polygonal barriers,
Commun. Pure Appl. Math. 36 (1983) 345–398.
[31] J.T. Schwartz, M. Sharir, On the piano movers’ problem: II. General techniques for computing topological properties of real algebraic manifolds, Adv.
Appl. Math. 4 (1983) 298–351.
[32] J.T. Schwartz, M. Sharir, J. Hopcroft (Eds.), Planning, Geometry and Complexity of Robot Motion, Ablex Series in Artiﬁcial Intelligence, Ablex Publishing
Corp., Norwood, New Jersey, 1987.
[33] M. Sharir, C. O’D’únlaing, C. Yap, Generalized Voronoi diagrams for moving a ladder I: topological analysis, Commun. Pure Appl. Math. XXXIX (1986)
423–483. Also: NYU-Courant Institute, Robotics Lab., No. 32, Oct 1984.
[34] M. Sharir, C. O’D’únlaing, C. Yap, Generalized Voronoi diagrams for moving a ladder II: eﬃcient computation of the diagram, Algorithmica 2 (1987)
27–59. Also: NYU-Courant Institute, Robotics Lab., No. 33, Oct 1984.
[35] V. Sharma, C. Yap, Near optimal tree size bounds on a simple real root isolation algorithm, in: 37th Int’l Symp. Symbolic and Alge. Comp., ISSAC’12,
July 22–25, 2012, Grenoble, France, 2012, pp. 319–326.
[36] G. Varadhan, S. Krishnan, T. Sriram, D. Manocha, Topology preserving surface extraction using adaptive subdivision, in: Proc. Symp. on Geometry
Processing, SGP’04, 2004, pp. 235–244.
[37] G. Varadhan, D. Manocha, Star-shaped roadmaps—a deterministic sampling approach for complete motion planning, in: Robotics: Science and Systems,
2005, pp. 25–32.
[38] G. Varadhan, D. Manocha, Accurate Minkowski sum approximation of polyhedral models, Graph. Models 68 (4) (2006) 343–355.
[39] C. Yap, V. Sharma, J.-M. Lien, Towards exact numerical Voronoi diagrams, in: 9th Proc. Int’l. Symp. of Voronoi Diagrams in Science and Engineering,
ISVD, Rutgers University, NJ, June 27–29, 2012, IEEE, 2012, pp. 2–16, Invited talk.
[40] C.K. Yap, Algorithmic motion planning, in: J. Schwartz, C. Yap (Eds.), Advances in Robotics, in: Algorithmic and Geometric Issues, vol. 1, Lawrence
Erlbaum Associates, 1987, pp. 95–143.
[41] C.K. Yap, An O (n log n) algorithm for the Voronoi diagram for a set of simple curve segments, Discrete Comput. Geom. 2 (1987) 365–394. Also:
NYU-Courant Institute, Robotics Lab., No. 43, May 1985.
[42] C.K. Yap, Robust geometric computation, in: J.E. Goodman, J. O’Rourke (Eds.), Handbook of Discrete and Computational Geometry, 2nd edition, Chapman
& Hall/CRC, Boca Raton, FL, 2004, pp. 927–952, Chap. 41.
[43] C.K. Yap, In praise of numerical computation, in: S. Albers, H. Alt, S. Näher (Eds.), Eﬃcient Algorithms, in: Lect. Notes in C.S., vol. 5760, Springer-Verlag,
2009, pp. 308–407.
[44] C.K. Yap, Soft subdivision search in motion planning, in: Proceedings, Robotics Challenge and Vision Workshop, RCV 2013, 2013, Best Paper Award,
sponsored by Computing Community Consortium (CCC); in: Robotics Science and Systems Conference, RSS 2013, Berlin, Germany, June 27, 2013, 2013,
The full paper is available from http://cs.nyu.edu/exact/papers/.
[45] L. Zhang, Y.J. Kim, D. Manocha, Eﬃcient cell labelling and path non-existence computation using C-obstacle query, Int. J. Robot. Res. 27 (11–12) (2008).
[46] D. Zhu, J.-C. Latombe, New heuristic algorithms for eﬃcient hierarchical path planning, IEEE Trans. Robot. Autom. 7 (1991) 9–20.

