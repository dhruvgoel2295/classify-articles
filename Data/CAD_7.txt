Computer-Aided Design 70 (2016) 13–22

Contents lists available at ScienceDirect

Computer-Aided Design
journal homepage: www.elsevier.com/locate/cad

Automatic generation of LEGO building instructions from multiple
photographic images of real objects✩
Takuya Kozaki, Hiroshi Tedenuma, Takashi Maekawa ∗
Department of Mechanical Engineering, Yokohama National University, Japan

highlights

graphical

abstract

• Even beginners are able to build
realistic complex LEGO models.

• Our system allows reconstruction
of portable large scale models with
color information.
• Easy adjustment of the trade-off
between model strength and the
total number of bricks is possible.

article

info

Keywords:
3D reconstruction
LEGO
Shape from silhouette
Simulated annealing

abstract
We introduce a system to reconstruct large scale LEGO models from multiple two dimensional images
of objects taken from different views. We employ a unit voxel with an edge length ratio of 5:5:6 for the
shape from silhouette method that reconstructs an octree voxel-based three dimensional model with
color information from images. We then convert the resulting voxel model with color information into a
LEGO sculpture. In order to minimize the number of LEGO bricks, we use a stochastic global optimization
method, simulated annealing, to hollow the model as much as possible but keep its strength for portability.
Several real complex LEGO models are provided to demonstrate the effectiveness of the proposed method.
© 2015 Elsevier Ltd. All rights reserved.

1. Introduction
LEGO has attracted many people, as a toy, as a hobby, even as
an educational tool for all generations all over the world. However, the design and construction of large scale LEGO models is not
easy for beginners. Here we define ‘‘large scale’’ models as those
consisting of 1000–10,000 bricks. The upper limit comes from the
portability of the models. We present a method for reconstructing
a LEGO model from several two dimensional (2D) images of a complex object taken from different views so that even beginners are

✩ This paper has been recommended for acceptance by Scott Schaefer and Charlie
C.L. Wang.
∗ Corresponding author. Tel.: +81 45 339 3930.
E-mail address: maekawa@ynu.ac.jp (T. Maekawa).

http://dx.doi.org/10.1016/j.cad.2015.06.020
0010-4485/© 2015 Elsevier Ltd. All rights reserved.

able to build realistic complex models. The data acquisition system consists of a camera on a tripod and a computer-controlled
turntable, as shown in Fig. 1. We employ the shape from silhouette
(SFS) method that reconstructs an octree voxel-based 3D model
with color information from images. In addition, we employ a unit
voxel with an edge length ratio of 5:5:6, which is the ratio used for
a unit LEGO brick, instead of the 1:1:1 ratio used in the traditional
SFS method. The resulting solid voxel model, consisting of unit voxels with edge length ratios of 5:5:6, are then converted to a hollow
LEGO model consisting of larger bricks with interior supports based
on the stochastic global optimization method, simulated annealing
(SA). The hollowed LEGO models are in average 30% lighter than the
solid ones and have strength for portability.
This paper makes the following contributions:

• We introduce a novel system to reconstruct portable large
scale LEGO models with color information from 2D images of

14

T. Kozaki et al. / Computer-Aided Design 70 (2016) 13–22

Fig. 1. Data acquisition system. (For interpretation of the references to color in this
figure legend, the reader is referred to the web version of this article.)

complex objects using SFS and by exploring the search space
using SA.
• Our algorithm allows for easy adjustment of the trade-off
between model strength and the total number of bricks used
for construction. This leads us to design a lighter model without
losing its strength for portability.
The remaining part of this paper is organized as follows. In
Section 2, we review related work. In Section 3, we present a
method to reconstruct a solid LEGO model consisting of unit LEGO
bricks from several 2D images. The solid LEGO model is converted
to a hollow model consisting of larger bricks using SA in Section 4.
The energy functionals used in the SA are discussed in Section 5.
In Section 6, we demonstrate the effectiveness of our method
using some complex examples. Finally, we conclude the paper in
Section 7.
2. Related work
Kim et al. [1] provided an excellent review of previous work
on automated LEGO assembly construction. They reviewed the
problem definition, formulation, and a variety of approaches to
solve the problem. Readers are referred to the references therein.
Silva et al. [2] presented a method to voxelize surface models
and then convert them to LEGO representations that are rendered
using realistic graphics techniques. However, the connectivities
between bricks were not presented.
Gower et al. [3] suggested six important factors related to the
connectivity of bricks and discussed implementation strategies
for several penalty functions that can be incorporated into SA;
however, the ideas presented in the paper were not implemented
but left for future studies.
Funes and Pollack [4] integrated a model of the physical properties of LEGO structures with an evolutionary process based on a
genetic algorithm (GA) that freely combines different shapes and
sizes into structures that are evaluated by how well they perform
the desired function. Their focus was on buildable designs, and the
method was applied to the construction of 2D bridges, scaffolds,
and cranes.
Zijl and Smal [5] discussed the modeling of the LEGO construction problems using cellular automata with emphasis on efficient
cluster evaluation. A cellular automaton is a collection of ‘‘states’’
on a grid of a specified shape that evolves through a number of discrete time steps according to a set of rules based on the states of the
neighboring cells [6]. However, the method cannot handle colored
models.
Testuz et al. [7] voxelize a 3D mesh, and merge the resulting
voxels to form larger bricks. They then analyze and repair structural problems using a graph-based algorithm and finally output

a set of building instructions. They also extended the system so
that hollow models can be constructed while fulfilling the limits of
the number of bricks of each size. However, hollowing the models,
satisfying the brick type numbers, and the usage of colored bricks
were not included in the optimization pipeline.
Ono et al. [8] applied the conventional scan line method to
generate the voxel representation from the polygonal data, and
then deleted the internal voxels. Finally, they adjusted the tree
structure, which they refer to as a legograph, to convert the voxel
representation into a LEGO brick representation based on the
greedy algorithm. However, there are cases where the connection
between bricks is not guaranteed.
Zometool models, which are different from LEGO models, are
also recreational model assemblies for use at home. Zimmer et al.
[9] introduced an algorithm that approximates 2-manifold surfaces with Zometool models. Starting from a rough initial approximation, the Zometool operators are iteratively selected within a
stochastic framework guided by an energy functional measuring
the quality of the approximation.
In summary, none of the previous work generates building instructions of portable, complex hollow LEGO models in color from
multiple 2D images of real objects.
3. Reconstruction method
Most of the research on LEGO construction assumes that the
triangular mesh model or the voxel model associated with color
information is already given. However, this assumption may not
always be applicable. In this paper, we employ recent advances in
computer vision and geometric modeling techniques to facilitate
the reconstruction of a voxel model from images of objects and
generate building instructions for LEGO models.
3.1. Data acquisition system
Our data acquisition system consists of a camera (EOS Kiss X4)
placed on a tripod and a computer-controlled turntable, which
is considerably more cost-effective than a laser scanner. We use
the SFS method [10–12], which constructs an octree voxel-based
3D model from silhouette images of an object captured during
rotation on the turntable. The camera is fixed, so it can only capture
information in the scene that is visible to the camera during the
rotation of the object. Thus, complete object information has to
be acquired by inverting the object, which is then recaptured
via another round of rotations [13]. Using the two sets of object
silhouette images collected during rotation (see Fig. 2(a)–(c)), we
can reconstruct a complete voxel model, as shown in Fig. 2(d).
We have improved the method by Nanya et al. [13], which
integrates the two incomplete voxel models by reducing the
errors in the system, namely, camera calibration errors, silhouette
extraction errors, and errors caused by the iterative closest point,
so that we can simply apply the set intersection of the two voxel
models to integrate them into a single voxel model.
3.2. Scaling effect
The relation between the voxel size and LEGO unit brick size can
be determined as follows. Let us denote the characteristic linear dimension of an object as L. If we denote the length of the root-voxel
as L, and the octree depth in SFS as k, then the length of the smallest unit voxel is L/2k . If the side length of a unit LEGO is h, then the
reconstructed LEGO model has a size of 2k h. Fig. 3 shows a zebra
model with three different octree depths (k = 6, 7, and 8). Because
the horizontal length of the unit LEGO brick is h = 8 mm, the horizontal length of the zebra model will be approximately 512, 1024,
and 2048 mm. Because our method is based on the SFS method, all

T. Kozaki et al. / Computer-Aided Design 70 (2016) 13–22

15

Fig. 4. Nine colors used for LEGO modeling. (For interpretation of the references to
color in this figure legend, the reader is referred to the web version of this article.)

Fig. 2. Reconstruction method: (a) The back of the zebra model is visible to the
camera. (b) The belly of the zebra model is visible to the camera. (c) Two sets of
circular camera centers are represented by points. (d) Integrated voxel model with
a voxel edge length ratio of 5:5:6.

background pixels must be excluded from the averaging computation.
We use 6177 basic LEGO bricks of nine colors, namely, bright
red (B red), bright yellow (B yellow), dark green (D green), bright
blue (B blue), white, black, reddish brown (R brown), bright orange
(B orange), and bright yellowish green (B Y green), as shown in
Fig. 4.
We convert the RGB color space of the object images to the
CIE L∗ a∗ b∗ color space, which describes all the colors visible to the
human eye, using OpenCV functions [14]. The three coordinates of
CIE L∗ a∗ b∗ , namely, L∗ , a∗ , and b∗ , represent the lightness of the
color (L∗ = 0 indicates black, and L∗ = 100 indicates diffuse
white), colors between green (−a∗ ) and red (+a∗ ), and colors
between blue (−b∗ ) and yellow (+b∗ ), respectively. Next, for each
pixel, we compute the difference between the CIE L∗ a∗ b∗ values of
the voxel color and the nine LEGO colors, i.e., L∗ , a∗ , and b∗ .
Let us denote the difference as Di :
Di =


(L∗bi − L∗v )2 + (a∗bi − a∗v )2 + (b∗bi − b∗v )2 ,

(1)

where subscripts b and v stand for brick and voxel, respectively,
and i = 1, . . . , 9 represent the nine LEGO colors. We assign the
color to brick i that gives the lowest Di .
4. Automated generation of LEGO building instructions
Fig. 3. Three different octree depths: 6, 7, and 8.
Table 1
Number of unit bricks for solid models at three different octree depths: 6, 7, and 8.

# of unit bricks

Octree 6

Octree 7

Octree 8

7894

55 255

408 597

the reconstructed models have detailed surface color information
captured in the images. Therefore, we can provide color information to the LEGO model up to the image resolution.
The square–cube law describes the relationship between the
area and volume of an object as its size changes. When the size
of an object is scaled up by a factor of α , the surface area increases
by a factor of α 2 , while the volume increases by a factor of α 3 . Table 1 tabulates the total number of unit bricks required to build the
solid zebra model shown in Fig. 3 for octree depths k = 6, 7, and
8. Accordingly, if the octree depth k increases, the cross section of
the LEGO model increases by a factor of 22k , while the weight of the
model increases by a factor of 23k . As a consequence, models with
large k may be unbuildable unless we hollow the solid structure.
For example, the legs of insects become unbuildable as k becomes
large.

Because our focus is on LEGO models at large scales, their insides must be hollowed in order to reduce the number of inside
bricks required according to the square-cubic law and create a
lighter model for portability. The initial boundary unit LEGO bricks,
which contain color information, should be also replaced by larger
bricks without changing the boundary shape or color. Once the
solid LEGO model consisting of unit bricks is reconstructed by the
procedures described in Section 3, we hollow the model and replace unit bricks with larger bricks based on SA by minimizing the
energy functional. Our strategy is to build the LEGO model layerby-layer, as done in additive manufacturing. Therefore, our output
building instructions provide a brick placement diagram for each
layer.
4.1. Basic LEGO bricks
We restrict our LEGO construction scheme by employing seven
basic brick sizes, 1 × 1, 1 × 2, 1 × 3, 1 × 4, 2 × 2, 2 × 3, and
2 × 4. The numbers represent the number of rows × columns of the
studs of each basic LEGO brick, as depicted in Fig. 5. Although the
shapes of the bricks are the same, we distinguish between bricks
with stud configurations, 1 × 2, 1 × 3, 1 × 4, 2 × 3, and 2 × 4, and
the transposed configurations, 2 × 1, 3 × 1, 4 × 1, 3 × 2, and 4 × 2,
in the assembly process, resulting in 12 different kinds of bricks to
select for construction.

3.3. Coloring
4.2. SA
Colors are assigned to the voxels when they are projected onto
the images. The centroids of the surfaces of the integrated voxels
that can be seen from the camera center are projected back onto
the corresponding images through the rays connecting the centroids and camera center. The average of the RGB colors of the pixel
closest to the intersection point of the ray and its surrounding pixels is chosen to be the color of the voxel. We note here that the

The SA method [15] is a stochastic global optimization method
that simulates the physical behavior of glass during annealing.
First, the glass (a system being optimized) is melted by heating
it above the melting temperature so that the atoms can move
more freely. The specimen is then cooled down in steps so that
at each reduced temperature the atoms can rearrange themselves

16

T. Kozaki et al. / Computer-Aided Design 70 (2016) 13–22

Algorithm 1 SA for LEGO construction

Fig. 5. Basic LEGO bricks.

Fig. 6. Graph structure: (a) Overall graph structure of the zebra model. (b) Close-up
view of (a). (For interpretation of the references to color in this figure legend, the
reader is referred to the web version of this article.)

to attain equilibrium [16]. An SA algorithm consists of two nested
loops, as described in Algorithm 1. The outer loop sets the
temperature according to the cooling schedule, and the inner loop
runs a Metropolis Monte Carlo simulation [17] at the temperature
specified by the outer loop.
We start the optimization scheme with an initial solid LEGO
model consisting of unit bricks with color information assigned to
the surface boundary bricks. For each iteration we evaluate the energy functional Eq. (2), described in Section 5, for the current configuration. The system attains equilibrium when the search point
is at or close to the local minimum, which can be found when there
are only small changes in the energy functional after a certain number of iterations. If the system is not in equilibrium, then one of
the three local operators, Remove(B), Merge(B), or Split(B), is randomly selected and applied to a randomly selected brick from the
current configuration until there is no change in the configuration.
We give detailed descriptions regarding these three local operators
in Section 4.4. In the following, we explain several functions used
in Algorithm 1.

• CalculateEnergy(M): calculates the energy functional of the
current configuration M.

• SelectBrickRandomly(M , B): selects a brick B randomly from
current configuration M.

• Random(0, 1): returns a random number between 0 and 1.
• iRandom(0, 2): returns a randomly selected integer between 0
and 2.

• ApplyLocalOperator(B): if iRandom(0, 2) returns 0, 1, or 2,
then this function chooses Remove(B), Merge(B), or Split(B),
respectively.

4.3. Graph representation
It is convenient to represent the brick configuration M as a
graph, where each brick represents a node and each connectivity
between two bricks represents an edge [7]. Cooler color nodes represent smaller bricks, while warmer color bricks represent larger
bricks. Similarly, cooler color edges represent smaller connectivities, while warmer color edges represent larger connectivities. This
graph representation makes it easy to find all neighboring bricks
during the evaluation of local operations. Fig. 6 shows the graph
structure of the zebra model.

Require: Initial configuration M, Initial temperature T0 , Decay
factor α , Boltzmann’s constant k, n=1, j=0
1: Mold = M
2: Eold = CalcualateEnergy(Mold )
3: while n > 0 do
4:
n=0
5:
for i = 0 to Model.size() do
6:
B = SelectBrickRandomly(M )
7:
Mnew = ApplyLocalOperator (B)
8:
Enew = CalcualateEnergy(Mnew )
9:
∆E = Enew − Eold
10:
if ∆E < 0 then
11:
Mold = Mnew
12:
n++
13:
else
14:
if exp(−∆E /kTj ) > Random(0, 1) then
15:
Mold = Mnew
16:
n++
17:
end if
18:
end if
19:
end for
20:
j++
21:
Tj = T0 · α j
22: end while
4.4. Local operators
In order to reduce the energy level during the annealing process,
three local operators are used to modify the current configuration
namely, Remove(B), Merge(B), and Split(B). We list brief descriptions of the three local operators as follows:
1. Remove(B): Randomly selected brick B is removed from current
configuration M. If one of the upper layer bricks that is
connected with the selected brick B loses its connection with
the lower layer, we do not conduct the Remove operation.
2. Merge(B): Randomly selected brick B in current configuration M
is merged into a randomly selected space S whose left bottom
corner coincides with that of B. The size of S is one of the 12 brick
sizes described in Section 4.1. If the size of B is larger than that of
S, we do nothing. If an interior brick is merged with a boundary
brick, the color information is transferred to the resulting brick.
Fig. 7(a) shows an example of a randomly selected space S
that has the size of a 4 × 2 brick. Fig. 7(b) illustrates a 3 × 1
brick B, a unit empty space, and a 4 × 1 brick that are merged
into a 4 × 2 brick, assuming that the empty unit space is not on
the boundary.
Fig. 7(c) and (d) show examples where the merging operation is abandoned. Suppose a randomly selected 3 × 1 brick B
next to another 3 × 1 brick on the right and 1 × 4 brick on the
top, as shown in Fig. 7(c), are chosen to be merged into a space
of 4 × 2 brick size S. In this case, the top brick does not fit within
S, therefore the bricks are not merged. Fig. 7(d) illustrates an example where bricks with different colors are not merged.
3. Split(B): Randomly selected brick B is split into smaller pieces
according to the randomly selected combinations shown in
Fig. 8. When the boundary brick is split into smaller bricks, the
resulting boundary bricks keep their color information, but the
interior bricks lose their color information.
When a 2 × 3 (or 3 × 2) brick is split into 2 × 2 and 2 × 1
(or 2 × 2 and 1 × 2) bricks, we place the 2 × 2 brick on the bottom (left). If one of the split bricks is not connected to the lower
layer, we do not conduct the Split operation.

T. Kozaki et al. / Computer-Aided Design 70 (2016) 13–22

Fig. 7. Merge(B): (a) Randomly selected space S of the same size as a 4 × 2 brick. (b)
Randomly selected 3 × 1 brick B is located in the bottom left corner of S. The rest of
S contains a unit empty space and a 4 × 1 brick. (c) Randomly selected 3 × 1 brick B
is located in the bottom left corner of S. The rest of S contains a 3 × 1 brick and 1 × 4
brick at the top. In this case, the top brick does not fit within S, therefore the bricks
are not merged. (d) Bricks with different colors are not merged. (For interpretation
of the references to color in this figure legend, the reader is referred to the web
version of this article.)

Fig. 8. All possible combinations of the Split operator. (For interpretation of the
references to color in this figure legend, the reader is referred to the web version of
this article.)

5. Energy functional

E (M ) = w1 ED (M ) + w2 EV (M ) + w3 EH (M ) + w4 EM (M ),

(2)

where wi (i = 1, . . . , 4) are the weights. The first term ED (M ) measures the distances from the boundary bricks in order to hollow
the input solid voxel model. The second and third terms EV (M )
and EH (M ) measure the vertical and horizontal connectivities of
the LEGO bricks, respectively, where higher values indicate lower
connectivities. Because SA minimizes the energy, higher connectivities between the bricks are generated. The fourth term EM (M )
measures the bending moments acting on the cantilever type of
brick configuration. If the bending moment is high, the model may
collapse.

to solve this equation. First, 3D grids (bricks) with a h:h:1.2h spacing are generated over the LEGO model, and then the bricks that
coincide with the model boundary are extracted and their centroids are assigned a zero distance, i.e., d(x) = 0. Eq. (3) is then
discretized on the basis of the upwind scheme. FMM systematically constructs the solution d using only upwind values, that is,
from smaller to larger values of d. Initially, the front starts from
the bricks that contain boundary and merges with other bricks to
form iso-distance contours [20]. Fig. 9 illustrates the propagation of
the fronts represented by iso-distance contours, where cool colors
indicate small distances from model boundary Q.
The energy functional based on distance from the bricks is defined as:
Nu

(d(xi ) − d(xm )),

where Nu is the total number of unit bricks used in the solid LEGO
model, and d(xm ) is the mean distance of all the unit bricks from
the model boundary. The subtraction of d(xm ) from d(xi ) forces the
shell thickness of the model to be d(xm ), which, in general, keeps
the strength needed for portability.
5.2. Vertical connectivity functional EV
The second term measures the local vertical connectivities,
where higher values indicate lower connectivities. The more connectivities that exist between upper and lower bricks, the smaller
EV becomes. The functional is given by
N 
1

i=1 j=0

The output of the SFS method is a solid voxel model consisting
of unit voxels with edge length ratio of 5:5:6, i.e. unit LEGO bricks.
If we hollow out the solid LEGO model as much as possible under
the condition that it does not collapse during assembly or transport, then the resulting LEGO model will be light and portable. In
order to hollow the model, we need to determine the interior distance field from the model boundary.
Let Q = {q1 , . . . , qm } denote the set of centroids of the boundary unit bricks of the solid LEGO model. The distance function
d(x) = dist (x, Q) to Q can be formulated as a boundary value problem, which describes the motion of a surface in a direction normal
to the boundary unit bricks:
(3)

where d(x) = 0, x ∈ Q. Eq. (3) is known as the Eikonal equation. Sethian [18,19] developed the fast marching method (FMM)

(4)

i =1

EV ( M ) =

5.1. Distance functional ED

|∇ d(x)| = 1,

Fig. 9. Distance field of the zebra model represented by iso-distance contours,
where cool colors indicate small distances from the model boundary. (For
interpretation of the references to color in this figure legend, the reader is referred
to the web version of this article.)

ED ( M ) =

We consider the following energy functional E (M ) for configuration M that consists of a linear combination of four separate energy functionals:

17


1−

NijV
NiS


,

(5)

where N is the total number of bricks used in the current
configuration M , NiS denotes the number of studs in brick Bi , and
NijV denotes the number of studs that are connected with upper
(j = 0) and lower (j = 1) bricks. Fig. 10(a) illustrates the case
where a 1 × 3 brick is sandwiched by 1 × 3 bricks.
In this

 case
V
NiS = 3 and Ni0
= Ni1V = 3, yielding

1

j =0

1−

NijV
NiS

= 0.

Because the energy functional for brick Bi is zero, one might think
that the algorithm induces simple columns of bricks that may cause
structural problems. However, the role of this energy functional
is to increase the vertical connectivity between upper and lower
bricks, not to increase the horizontal connectivity. Fig. 10(b)
illustrates the case where a 1×3 brick is sandwiched
by 1×4bricks.
V
In this case, NiS = 3 and Ni0
= Ni1V = 2, thus

1

j =0

1−

NijV
NiS

= 32 .

18

T. Kozaki et al. / Computer-Aided Design 70 (2016) 13–22

Fig. 10. Vertical connectivity functional: (a) Both upper and lower layers are
connected to 3 × 1 bricks. (b) Both upper and lower layers are connected to 4 × 1
bricks.

Fig. 12. Moment functional: (a) The left end of the 1 × 4 brick is fixed to the lower
brick and is subjected to the vertical load from the upper 1 × 4 brick. The inner
summation of Eq. (8) results in 10, while in (b), it results in 2.

Fig. 13. Energy evaluation (a) before and (b) after the merge operation is applied
to Bi .
Fig. 11. Horizontal connectivity functional: (a) The 4 × 2 brick Bi has 16
horizontal surrounding studs. (b) The upper side of Bi (blue) has a single horizontal
connectivity with the surrounding bricks, yielding Hi0 = 1, while the lower side
yields Hi1 = 3, leading to the inner summation of Eq. (6) to be 28
. (c) The red
16
cross indicates the stud that is connected to the upper bricks, while the blue
crosses indicate studs that are connected to lower bricks. (For interpretation of the
references to color in this figure legend, the reader is referred to the web version of
this article.)

5.3. Horizontal connectivity functional EH
The third term measures the horizontal connectivity. The more
connectivities brick Bi has with the surrounding bricks, the smaller
the energy EH (z ) becomes. Because the maximum size brick used in
this research is 2 × 4 or 4 × 2, the number of maximum surrounding
studs is 16, as depicted in Fig. 11(a). By setting the denominator of
EH to 16, the minimization scheme automatically induces larger
bricks into the configuration.
EH ( M ) =

N 
1 

i=1 j=0

1−

Hi,j
16



.

(6)

For example, the upper side of Bi (the blue brick) in Fig. 11(b)
and (c) has a single horizontal connectivity with the surrounding
bricks, yielding Hi0 = 1, while the lower side of Bi has three horizontal connectivities with the surrounding bricks, yielding Hi1 = 3.
28
Hence, the inner summation of Eq. (6) becomes 16
.
5.4. Moment functional EM

Table 2
Energy evaluation.
ED
Old

4

New

4

NiC

Li = Wi +

 Lij
j =1

NijS

,

(7)

where Wi is the weight of brick Bi itself represented by the number
of studs, Lij is the load acting on the j-th brick that is connected to
Bi from one layer above, NiC is the number of studs that are con-

EH
58
16
28
16

EM
1
0

Total
146
16
96
16

nected with the upper layer bricks, and NijS is the number of studs
that support Lij . We apply Eq. (7) to each brick in configuration M
one-by-one from the top second layer to the lowest layer. Moment
EM can be obtained as follows:
C

EM (M ) =

Ni
N 

Lij × Rij
i=1 j=0

NijS

,

(8)

where Rij is the armlength and NijS is the number of studs of Bi that
are connected with the upper layer brick Bj . Fig. 12(a) shows a 1 × 4
brick fixed to the lower brick at the left end that is subjected to a
vertical load from the upper 1 × 4 brick. The numbers on the brick
are the distances from the fixed end. In case (a), the inner summation of Eq. (8) results in 10, while in case (b), it is 2.
5.5. Energy evaluation
As described in Algorithm 1, SA repeats local operations, therefore the energy evaluation should also be conducted locally as well
in order to save computational time as follows:
E=

The fourth term measures the bending moment acting on
cantilever-type brick structures. We define the bending moment
acting on the brick as the multiplication of the loads acting on it,
which originate from the weights of the upper bricks and the arm
lengths from their fixed ends. Starting from the top second layer,
the loads from the weights become larger as the layer moves downwards. We calculate the load acting on each brick starting from the
top second layer. Note that the bricks of the top layer have no loads.
The following equation is used to estimate load Li acting on brick Bi :

EV
1
2
1
4

Enew −

Eold ,

(9)

where Enew and Eold denote energy increase caused by local
operations for the current and previous steps, respectively. When
evaluating the energy, the energy change in the related bricks must
also be updated. Fig. 13(a) and (b) illustrates the brick configuration before and after the Merge operation is applied to brick Bi , and
Table 2 tabulates the energy functionals before and after the application of the Merge operator.
6. Results
In this section, we first examine the structural integrity of the
LEGO model with respect to the choice of decay factor and four
weights. Then, we demonstrate the effectiveness of our algorithm
by applying it to three models, namely, a frog, panda, and zebra. All the computations were performed on an Intel Core i7 950
(3.07 GHz) PC with 12 GB RAM.

T. Kozaki et al. / Computer-Aided Design 70 (2016) 13–22

19

Table 3
Structural integrity with respect to decay factor and weights. Modified decay factor and weights are in bold font.
Modified α and wi

Tuned values

α

w1

w2

w3

w4

All weights

Decay factor

α

0.9999

0.9

0.9999

0.9999

0.9999

0.9999

0.9999

Weights

w1
w2
w3
w4

2.0
0.8
1.0
1.5

2.0
0.8
1.0
1.5

1.0
0.8
1.0
1.5

2.0
1.5
1.0
1.5

2.0
0.8
0.5
1.5

2.0
0.8
1.0
2.0

1.0
1.5
0.5
2.0

Computational results

Run time (min)
Void ratio (%)
# of Iter.
# of bricks

50.6
35.5
10 538
2375

0.48
23.0
72
3262

69.6
33.7
10 752
2411

50.6
35.5
11 681
2350

113.4
35.6
19 457
2463

62.2
34.6
11 439
2453

116.6
28.7
19 660
2868

Table 4
Computational results of the three models.
Model

# of total basic
bricks

Void
ratio (%)

Weight Run
(kg)
time (min)

Frog (6)
Panda (6)
Zebra (7)

1053
2375
7842

31.3
35.5
33.6

1.6
3.7
11.9

14.3
50.6
440.6

Table 5
Volumetric percentages of the seven basic bricks and colors used in the construction
of the frog model (%).
Color

1×1

1×2

1×3

1×4

2×2

2×3

2×4

Black
White
B red
R brown
D green
B Y green
Other

0.04
0.30
0.02
0.02
0.54
1.55
1.03

0.20
1.03
0
0
0.68
2.82
0.68

0
1.79
0
0.06
0.72
3.28
0.66

0
2.31
0
0
0.64
3.90
2.63

0.08
0.64
0
0
0
1.51
0.40

0.24
2.39
0
0
1.20
5.25
2.63

0.32
14.3
0
0.16
2.55
27.7
15.8

Table 6
Volumetric percentages of the seven basic bricks and colors used in the construction
of the panda model (%).
Color

1×1

1×2

1×3

1×4

2×2

2×3

2×4

Black
White
R brown
Other

0.61
1.36
0.04
1.36

1.62
2.59
0.04
1.07

1.77
3.06
0.03
0.81

2.81
4.61
0.04
2.40

0.81
2.08
0
0.98

2.59
5.49
0
4.96

8.30
26.6
0
24.0

6.1. Decay factor and weights
From practical experience, we have observed that the choice of
decay factor α in the cooling schedule and the four weights wi (i =
1, . . . , 4) in the energy functional significantly affect the structural
integrity of the resulting LEGO model. In all experiments, the
weights and parameters were fixed as follows: w1 = 2.0, w2 =
0.8, w3 = 1.0, w4 = 1.5, initial temperature T0 = 1.0, decay
factor α = 0.9999, and Boltzmann’s constant k = 1. These
parameters were set so as to reduce the total number of bricks
without losing the strength needed for portability.
Although typical values for α lie between 0.8 and 0.99 [21],
we used α = 0.9999. This causes the structure to cool down
very slowly, allowing the bricks to rearrange themselves to attain
better structural integrity. The experiments below compare the
computational results for α = 0.9 and 0.9999 for the panda
model (see Section 6.2). Even though the computational result with
α = 0.9 converges faster, requiring fewer iterations, the number of
bricks used in the construction increases by a factor of 1.37 and the
void ratio decreases by 35% compared with α = 0.9999 as listed
in Table 3. The void ratio is defined as the number of unit bricks
removed to the number of unit bricks in the solid model.
Table 3 also presents the computational results achieved by
modifying one weight while keeping the other weights unchanged.

Table 7
Volumetric percentages of the seven basic bricks and colors used in the construction
of the zebra model (%).
Color

1×1

1×2

1×3

1×4

2×2

2×3

2×4

Black
White
Other

0.84
1.36
1.63

1.37
2.82
1.14

1.43
4.18
0.92

1.39
4.26
3.67

0.67
1.63
1.12

2.37
5.89
5.80

6.66
22.80
28.05

This allows us to observe the influence of each weight on the
structural integrity. Finally, we modified all four weights at once,
and compare the results with those given by the tuned weights.
For all five cases (except when the vertical connectivity functional
w2 is varied), the run time, void ratio, number of iterations, and
number of bricks are better when using the tuned values. Although
the number of bricks decreases slightly when w2 is modified, the
structural integrity weakens as the number of edges in the graph
representation decreases from 4450 to 4107.
Even though the tuned parameters and weights may not be
optimal, the above discussion indicates that the proposed method
can fail with respect to structural integrity if these parameters and
weights are not selected properly.
6.2. Models
In Table 4, we list the total number of basic bricks used for the
construction, void ratio, weight in kilograms, and run time in minutes for the frog (octree depth 6, see Fig. 14), panda (octree depth
6, see Fig. 15), and zebra (octree depth 7, see Fig. 16) models. We
also tabulate the number of bricks for each of the seven basic bricks
as well as for each color used in the construction for each of the
three models in Tables 5, 6, and 7, respectively. The term ‘‘other’’
represents colors that were used for the internal bricks. It is clear
from Tables 5–7 that the larger size bricks are more used than the
smaller bricks. This clearly shows that EH is effective.
6.3. Buildability
There are many previous works that have studied the automatic
generation of LEGO models using computers, however, none of
these methods show the real construction of LEGO models at large
scales (1000–10,000 bricks) based on their algorithm. In actual
construction, we often encounter the buildability problem. As in
additive manufacturing technology, supporting bricks are required
to build overhanging structures.
We distinguish between internal and external supporting
bricks. Internal bricks support internal overhang structures such as
the back of the panda and zebra models. These must be determined
before construction and cannot be removed after construction, and
hence remain in the final model. Fig. 18 shows the supporting
bricks (colored purple) inside the panda model. In our algorithm,
internal supporting bricks are automatically generated in the
SA framework. Although internal supporting bricks exist for

20

T. Kozaki et al. / Computer-Aided Design 70 (2016) 13–22

Fig. 14. Original and reconstructed frog model (octree depth 6).

Fig. 16. Original and reconstructed zebra model (octree depth 7).

its back has a saddle shape. Naturally, the panda model has more
strength in the vertical direction than the zebra model. Fig. 19(b)
illustrates how it can support a 65 kg person.
7. Conclusion

Fig. 15. Original and reconstructed panda model (octree depth 6).

buildability, nonetheless they help increase the rigidity of the brick
structures to some extent. On the other hand, external supporting
bricks, such as those for the belly of the panda and zebra models,
can be constructed by the builder during the construction of the
external overhanging structures and removed after construction.
Fig. 17 shows the LEGO building instructions for the panda
model with an octree depth of 6. The building instructions consist
of 25 layers, starting from the four legs. The red-edged rectangles
represent bricks of the previous layer, while the blue-edged
rectangles with inside color represent the size and the color of the
bricks to be placed at the current layer. The first 10 layers involve
bricks without lower layers that require external supporting bricks.
In those situations, we can build structures using bricks of any color
and remove them after the construction.

The proposed system allows us to reconstruct large scale LEGO
models from multiple 2D images of objects taken from different
views. SA, a stochastic global optimization method, is employed to
hollow out the model without losing its strength for portability.
While our reconstruction method is already highly effective, it
still has a number of limitations that require further research:

• The SFS method cannot remove voxels in concave regions that
do not appear in the silhouettes.

• Even if we hollow out the models, very thin structures such as
the legs of insects are still difficult to construct because of the
square–cube law.
• Noise due to specularities (white bricks in the black portions
of the panda model) and shadows (black bricks in the white
portions of the panda model) on the images are not completely
removed.
We provided an outline of the concept of our algorithm, and
applied the algorithm to construct complex objects in LEGO at large
scales. However, there are several possibilities for extensions of our
algorithm, and we list a few of them.

6.4. Portability

• The algorithm could be extended to automatically generate

One of the key objectives of this paper is to build a model
that has sufficient strength for portability. In other words, reconstructed models, which have 1000–10,000 bricks, must not collapse when being carried. The reconstructed zebra model is about
80 cm in length and can be easily carried, as shown in Fig. 19(a).
The panda model has relatively short legs and its back has a convex
cupped shape, while the zebra model has relatively long legs and

• Because of the hollowing process, the resulting LEGO model

external supporting bricks.
may lose its stability and be unable to stand unsupported. To
prevent such cases, we should consider balance in the optimization.
• We plan to combine a photometric stereo method to SFS so that
we can remove voxels in concave regions that do not appear in
the silhouettes.

T. Kozaki et al. / Computer-Aided Design 70 (2016) 13–22

21

Fig. 17. LEGO building instructions for panda model starting from the lowest layer. (For interpretation of the references to color in this figure legend, the reader is referred
to the web version of this article.)

Fig. 18. Cross section of the panda model: (a) The yellow brick in the panda model
cannot be placed without the supporting column. (b) Close-up view of the red circle
in (a). (For interpretation of the references to color in this figure legend, the reader
is referred to the web version of this article.)

Acknowledgments
This work is supported by the Japan Society for the Promotion of
Science, Grants-in-Aid for Scientific Research under grant number
15H03944. We would like to thank Hui Lin, Takuma Imai, Kentaro
Shida, Masahito Takezawa, Naoki Enami, Yuhi Sasaki, Takato Sato,
Seungki Kim and Sayuri Nakazawa for their assistance.

Fig. 19. Portability and strength test.

22

T. Kozaki et al. / Computer-Aided Design 70 (2016) 13–22

References
[1] Kim JW, Kang KK, Lee JH. Survey on automated LEGO assembly construction.
In: 22nd international conferences in central Europe on computer graphics,
visualization and computer vision. 2014. p. 89–96.
[2] Silva LF, Pamplona VF, Comba JLD. Legolizer: A real-time system for modeling
and rendering LEGO representations of boundary models. In: 2009 XXII
Brazilian symposium on computer graphics and image processing (SIBGRAPI).
IEEE; 2009. p. 17–23.
[3] Gower R, Heydtmann A, Petersen H. LEGO: Automated model construction.
1998. p. 81–94.
[4] Funes P, Pollack JB. Componential structural simulator, Tech. rep., Technical
report CS-98-198. Brandeis University Department of Computer Science;
1998.
[5] van Zijl L, Smal E. Cellular automata with cell clustering. In: Proceedings of
automata 2008 workshop. 2008. p. 425–41.
[6] Weisstein EW. Cellular automaton. From MathWorld—A Wolfram Web
Resource. URL: http://mathworld.wolfram.com/CellularAutomaton.html.
[7] Testuz R, Schwartzburg Y, Pauly M. Automatic generation of constructable
brick sculptures. In: Proc. eurographics. Vol. 13. 2013. p. 81–4.
[8] Ono S, Alexis A, Chang Y. et al. Automatic generation of LEGO from the
polygonal data. In: International workshop on advanced image technology.
2013. p. 262–67.
[9] Zimmer H, Lafarge F, Alliez P, Kobbelt L. Zometool shape approximation. Graph
Models 2014;76(5):390–401.
[10] Laurentini A. The visual hull concept for silhouette-based image understanding. IEEE Trans Pattern Anal Mach Intell 1994;16(2):150–62.

[11] Atsushi K, Sueyasu H, Funayama Y, Maekawa T. System for reconstruction
of three-dimensional micro objects from multiple photographic images.
Comput-Aided Des 2011;43(8):1045–55.
[12] Hirano D, Funayama Y, Maekawa T. 3D shape reconstruction from 2D images.
Comput-Aided Des Appl 2009;6(5):701–10.
[13] Nanya T, Yoshihara H, Maekawa T. Reconstruction of complete 3D models by
voxel integration. J Adv Mech Des Syst Manuf 2013;7(3):362–76.
[14] Nara institute of science and technology. OpenCV programming book
production team, OpenCV programming book, Mainichi Communications.
2007.
[15] Kirkpatrick S, Gelatt CD, Vecchi MP, et al. Optimization by simmulated
annealing. Science 1983;220(4598):671–80.
[16] Maekawa T, Noda T, Tamura S, Ozaki T, Machida K. Curvature continuous path
generation for autonomous vehicle using B-spline curves. Comput-Aided Des
2010;42(4):350–9.
[17] Metropolis N, Rosenbluth AW, Rosenbluth MN, Teller AH, Teller E. Equation
of state calculations by fast computing machines. J Chem Phys 1953;21(6):
1087–92.
[18] Sethian JA. A fast marching level set method for monotonically advancing
fronts. Proc Natl Acad Sci 1996;93(4):1591–5.
[19] Sethian JA. Level set methods and fast marching methods: evolving interfaces
in computational geometry, fluid mechanics, computer vision, and materials
science. Vol. 3. Cambridge University Press; 1999.
[20] Yoshihara H, Yoshii T, Shibutani T, Maekawa T. Topologically robust B-spline
surface reconstruction from point clouds using level set methods and iterative
geometric fitting algorithms. Comput Aided Geom Design 2012;29(7):422–34.
[21] Aarts E, Korst J, Michiels W. Simulated annealing. In: Burke EK, Kendall G,
editors. Search methodologies: introductory tutorials in optimization and
decision support techniques. Springer US; 2005. p. 187–210.

