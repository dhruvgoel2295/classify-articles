Computational Geometry 48 (2015) 673–687

Contents lists available at ScienceDirect

Computational Geometry: Theory and
Applications
www.elsevier.com/locate/comgeo

Separating bichromatic point sets by L-shapes
Farnaz Sheikhi a , Ali Mohades a,∗ , Mark de Berg b , Mansoor Davoodi c
a

Laboratory of Algorithms and Computational Geometry, Faculty of Mathematics and Computer Science, Amirkabir University of Technology,
Tehran, Iran
b
Department of Computer Science, TU Eindhoven, PO Box 513, 5600 MB, Eindhoven, The Netherlands
c
Department of Computer Science and Information Technology, Institute for Advanced Studies in Basic Sciences (IASBS), Zanjan, Iran

a r t i c l e

i n f o

Article history:
Received 21 December 2012
Accepted 3 February 2014
Available online 29 June 2015
Keywords:
Separability
Bichromatic point sets
L-shape

a b s t r a c t
Given a set R of red points and a set B of blue points in the plane, we study the problem
of determining all angles for which there exists an L-shape containing all points from B
and no points from R. We propose a worst-case optimal algorithm to solve this problem in
O (n2 ) time and O (n) storage, where n = | R | + | B |. We also describe an output-sensitive
algorithm that reports these angles in O (n8/5+ε + k log k) time and O (n8/5+ε ) storage,
where k is the number of reported angular intervals and ε > 0 is any ﬁxed constant.
© 2015 Elsevier B.V. All rights reserved.

1. Introduction
Background. In a separability problem in R2 one is given two colored sets of objects, a set R of red objects and a set
B of blue objects, and a class S of curves. The curves are usually either inﬁnite curves (such as lines) or closed curves
(such as circles), so that they partition the plane into two regions. The goal is now to decide whether there is a curve
in S that is a separator for R and B, that is, a curve that partitions the plane such that R and B lie in different regions.
If such a placement is possible, one often also wants to compute all separators, or the separator minimizing some cost
function. Geometric separability arises in applications where classiﬁcation is required, such as machine learning and image
processing.
There has been a fair amount of work on different kinds of separators, both in the plane and in higher dimensions.
For separability in the plane where the objects to be separated are points—this is the topic of our paper—the following
results are known. The most basic version of the problem is where the class S is the class of all lines. The problem of
deciding whether the two point sets can be separated by a line can be solved in linear time, as shown by Megiddo [14].
Seara [18] showed how to compute in linear time all orientations for which there exists a line separating the two point
sets. O’Rourke et al. [17] studied a different type of separators, namely circles. They presented a linear-time algorithm for
deciding whether the two point sets can be separated by a circle, and they also gave algorithms for ﬁnding the smallest
and the largest separating circle. The problem of ﬁnding a convex polygon with minimum number of edges separating the
two point sets, if it exists, was solved by Edelsbrunner and Preparata [6] in O (n log n) time. Fekete [7] showed that the
problem of determining a simple polygon with a minimum number of edges separating the two point sets is NP-hard, and
a polynomial-time approximation algorithm was provided by Mitchell [15]. Separability problems have been studied for
separators in the form of strips and wedges [9] as well. A thorough study is presented by Seara [18].

*

Corresponding author.
E-mail addresses: f.sheikhi@aut.ac.ir (F. Sheikhi), mohades@aut.ac.ir (A. Mohades), mdberg@win.tue.nl (M. de Berg), mdmonfared@iasbs.ac.ir
(M. Davoodi).
http://dx.doi.org/10.1016/j.comgeo.2015.06.008
0925-7721/© 2015 Elsevier B.V. All rights reserved.

674

F. Sheikhi et al. / Computational Geometry 48 (2015) 673–687

Separability has also been studied for rectangular separators. This has applications in urban scene reconstruction, which
seeks to reconstruct buildings from LIDAR data. The idea is, roughly, to ﬁrst cluster the data points, then project the points
from each cluster onto a suitable plane, and ﬁnally ﬁnd the building facets (typically walls and roofs) corresponding to the
clusters [11–13]. Since walls and roofs are often rectangles or other rectilinear shapes, the task is to ﬁnd a suitable rectilinear
shape enclosing the points. Sometimes there are also points that are known to not be part of the facet being reconstructed.
We then seek a shape that includes the points in the facet (positive samples) while excluding the points known to not be in
the facet (negative samples). The distinction between the positive and negative samples is represented by the color assigned
to them, thus leading to separability problems for rectilinear shapes. Following this motivation, Van Kreveld et al. [12,13]
recently studied the separability problem in the plane for the case where the separator is a (not necessarily axis-aligned)
rectangle. They proposed an O (n log n) time algorithm to compute all orientations for which a rectangular separator exists.
They also required that the rectangle tightly ﬁts the blue point set. More precisely, the rectangle should be δ -covered by
the blue points, meaning that it is contained in the union of the radius-δ disks centered at the blue points. They mentioned
the case of a non-convex separator, namely an L-shape, as an open problem. This is the topic of our paper, except that we
do not require the L-shape to be δ -covered. Extending it to take this extra condition into account is an interesting open
problem. Next we deﬁne the problem more precisely and we state our results.
Exact problem statement and results. We deﬁne an axis-aligned L-shape to be the set-theoretic difference M \ M of two
axis-aligned rectangles M and M such that the top-right corners of M and M coincide. More precisely, an L-shape is
deﬁned as Cl(Int( M ) \ Int( M )), where M and M are closed rectangles with M
M that share their top-right corner. (Here
Cl(·) and Int(·) denote the closure and interior, respectively, of a planar set.) Note that an L-shape is a closed set, that is,
it includes its boundary and that an L-shape can degenerate into a rectangle. An L-shape with orientation θ is deﬁned as an
axis-aligned L-shape that has been rotated in counterclockwise direction over an angle of θ . Now, given a blue point set B
and a red point set R, we wish to ﬁnd all angles θ ∈ [0, 2π ) for which there exists an L-shape L with orientation θ such
that B ⊂ L and R ∩ L = ∅. From now on, we call such an L-shape a blue L-shape. The orientations for which a blue L-shape
exists form a collection of subintervals of [0, 2π ). We present two algorithms for computing this collection of intervals.
The ﬁrst algorithm is an algorithm running in O (n2 ) time and using O (n) storage. We prove that this algorithm is worstcase optimal by showing that there are point sets that admit (n2 ) disjoint intervals for which there exists a blue L-shape.
The second algorithm is an output-sensitive algorithm which uses O (n8/5+ε + k log k) time and O (n8/5+ε ) storage, where
k is the number of reported angular intervals and ε > 0 is any ﬁxed constant. (Our results are based on two preliminary
papers [20,21]. Compared to these preliminary results, the running time of the ﬁrst algorithm has been slightly improved
so that it is now worst-case optimal. The lower bound is completely new.)
2. Preliminaries
Terminology and notation. Our global strategy will be to do a rotational sweep: we increase θ from 0 to 2π and we report
the angular intervals for which there is a blue L-shape while we sweep. It will be convenient to think about the sweep
as rotating the coordinate frame. Thus, we deﬁne the xθ -axis and the y θ -axis as the coordinate axes after the coordinate
frame has been rotated over an angle θ in counterclockwise direction. We denote the coordinates of a point p in the rotated
coordinate frame by xθ ( p ) and y θ ( p ). Whenever we talk about the top-right corner of a rectangle, we mean the top-right
corner with respect to the current coordinate frame.
For an angle θ , we denote the minimum bounding rectangle with orientation θ of the blue point set B by M B (θ). In
other words, M B (θ) is the axis-aligned bounding box of B in the rotated coordinate frame. Let R θ := R ∩ M B (θ) be the set
of red points inside M B (θ), and deﬁne M R (θ) to be the smallest rectangle with orientation θ that contains R θ and shares
its top-right corner with M B (θ). Note that L θ := M B (θ) \ M R (θ) is an L-shape.
To determine whether L θ contains all points from B, we will deﬁne a so-called step-shape. We say that a point q dominates another point p (at orientation θ ) if xθ (q) ≥ xθ ( p ) and y θ (q) ≥ y θ ( p ), and we say that a point b i ∈ B is maximal (at
orientation θ ) if there is no other point b j ∈ B that dominates b i . The step-shape is now deﬁned as the region in M B (θ)
consisting of all points that are dominated by a blue point. The step-shape is a closed shape, bounded by the staircase
that connects the maximal blue points, and by parts of the boundary of M B (θ)—see Fig. 1. Using the step-shape, we can
characterize when L θ contains all the blue points. To this end, we deﬁne the red witness as the lower-left corner of M R (θ);
note that the red witness is the reﬂex corner of L θ . We denote the red witness by w θ . Then L θ contains all blue points if
and only if the red witness w θ lies outside or on the step-shape. However, note that despite containing all blue points in
this case, L θ is not blue as it contains red points on its boundary. But, here we can slightly shrink L θ (by slightly enlarging M R (θ)) to obtain an L-shape not containing any red points. The shrunk L-shape still contains all blue points if and only
if the red witness did not lie on the boundary of the step-shape. So we have the following observation.
Observation 1. There exists a blue L-shape in the orientation θ if and only if the red witness w θ lies outside the step-shape.
The global strategy. As remarked earlier, our global strategy is to perform a rotational sweep. While we sweep, we will
maintain the following information:

F. Sheikhi et al. / Computational Geometry 48 (2015) 673–687

675

Fig. 1. Points b1 , b2 and b3 are the maximal blue points at the orientation θ . The staircase is shown by narrow blue lines, and the shaded region shows
the step-shape. The red witness w θ is shown by a cross. (For interpretation of the colors in this ﬁgure, the reader is referred to the web version of this
article.)

• The rectangle M B (θ). More precisely, we maintain the set of blue points on the boundary of M B (θ). (Except at events
there are at most four such points.)

• The step-shape or, more precisely, the staircase bounding the step-shape from the right.
• The red witness w θ , or, more precisely, the two red points deﬁning w θ .
While we do the sweep, we are interested in the angles where the red witness crosses the staircase; these angles deﬁne
the angular intervals we have to report. Next we discuss the various events that arise during the sweep.
Blue-rect event: this event occurs when the set of blue points deﬁning M B (θ) changes. This happens when the blue point
with the maximum or minimum xθ -coordinate (or the maximum or minimum y θ -coordinate) changes.
Blue-sc event: this event occurs when the staircase changes, that is, when the set of maximal blue points changes.
Red-set event: this event occurs when R θ , the set of red points inside M B (θ), changes.
Witness event: this event occurs when the points deﬁning the red witness w θ change. This happens when the red point
in R θ with the minimum xθ -coordinate changes, and when the red point in R θ with the minimum y θ -coordinate
changes. It can be triggered by a red-set event, or by two red points that were already in R θ swapping order along
the xθ -axis or y θ -axis.
Crossing event: this event occurs when the red witness w θ crosses the staircase.
Note that all these events take place at angles deﬁned by pairs of points: blue-rect events and blue-sc events take place
at angles deﬁned by two blue points, red-set events take place at angles deﬁned by a red and a blue point, witness events
occur at angles deﬁned by a red and a blue or two red points, and crossing events occur at angles deﬁned by a red and
a blue point. Thus, one way to compute all angles for which there exists a blue L-shape is to consider all (n2 ) angles
deﬁned by a pair of points in B ∪ R (even though not all such angles necessarily deﬁne an event), sorting them to get
(n2 ) subintervals of [0, 2π ) in order, and examining whether there exists a blue L-shape in each of these subintervals.
In preliminary versions [20,21] of this paper it has been shown that this approach leads to algorithms that use O (n)
storage and have O (n2 log n) [20] or O (n2 α (n)) [21] running time, where α (n) is the extremely slow-growing inverse of the
Ackermann function [19]. In the present paper we will give an algorithm with running time O (n2 ), while still using only
O (n) storage.
3. A worst-case optimal algorithm
The idea of the ﬁrst algorithm is to pre-compute all blue-rect, blue-sc, red-set, and witness events (from now on, we
refer to these events as non-crossing events), and then compute all the crossing events occurring between two consecutive
non-crossing events. In the following subsections, we ﬁrst describe how to pre-compute the non-crossing events, then we
describe an algorithm that achieves the optimal O (n2 ) time complexity but uses O (nα (n)) storage, and ﬁnally we reﬁne the
algorithm so that it uses only linear storage.
3.1. Pre-computing non-crossing events
Computing the blue-rect events is easy: after computing the convex hull of the blue points in O (n log n) time [4], we can
ﬁnd the blue-rect events by using rotating calipers [22], leading to the following lemma.
Lemma 2. There are O (n) blue-rect events in total, and they can be computed in O (n log n) time and using O (n) storage.
Next we turn our attention to the blue-sc events. Recall that these events occur when the set of maximal blue points
changes, as we rotate the coordinate frame. Bae et al. [3] have proved that the set of maximal points changes at most O (n)
times during a full rotation from θ = 0 to θ = 2π ; they also presented an algorithm to compute all these changes in O (n2 )
time, using O (n) storage. However, we can also use an algorithm by Avis et al. [2], who studied the same problem; their
algorithm runs in O (n log n) time and O (n) storage. We can conclude the following lemma.

676

F. Sheikhi et al. / Computational Geometry 48 (2015) 673–687

Fig. 2. Computing red-set events. (For interpretation of the colors in this ﬁgure, the reader is referred to the web version of this article.)

Lemma 3. There are O (n) blue-sc events in total, and they can be computed in O (n log n) time and using O (n) storage.
To ﬁnd the red-set events—these are the events where a red point r enters or exits the rectangle M B (θ)—we observe
that they occur at angles deﬁned by the tangent lines from r to the convex hull of the blue points [12]. We denote this
convex hull by C H B . (If r lies inside C H B , then it will always be in R θ and consequently in the rectangle M B (θ). Hence,
these points can be ignored.) After computing C H B , we can test if r lies inside C H B in O (log n) time and, if not, we can
compute the tangent lines from r in O (log n) time. A red point r which is outside C H B can enter or exit M B (θ) if the
angle between the two tangents from r to C H B is greater than or equal to π /2. Thus, we only consider these red points,
ignoring the rest. Let r be such a red point, and as illustrated in Fig. 2, let be a tangent from r to C H B . Now deﬁne θ to be
the counterclockwise angle that makes with the positive x-axis. Then, the angles (θ + i · (π /2)) mod 2π , for i = 0, 1, 2, 3,
correspond to red-set events. Let
be the other tangent from r to C H B . Then, the red-set events corresponding to
can
be computed similarly. The only difference is that in this case we take θ as the counterclockwise angle that
makes with
the positive y-axis. This leads to the following lemma.
Lemma 4. There are O (n) red-set events in total, and they can be computed in O (n log n) time and using O (n) storage.
To compute the witness events, we proceed as follows. The red witness w θ is deﬁned by the red point in R θ with the
minimum xθ -coordinate and the red point in R θ with the minimum y θ -coordinate. For each red point r, deﬁne the function
f r (θ) as follows:

f r (θ) =

xθ (r )
if r ∈ R θ
undeﬁned otherwise

Recall that the angles at which a red point r may enter or leave the rectangle M B (θ), and thus become or cease to be a
point of R θ , correspond to the tangents from r to C H B . Each of these two tangent lines can induce four events where r
enters or leaves M B (θ). (This is the case because M B (θ) = M B (θ + π /2) = M B (θ + π ) = M B (θ + 3π /2). We still have to do
a full rotation, however, because the top-right corner of M B (θ) is different in each of these rotated coordinate frames.) So,
we can have eight events in total, partitioning [0, 2π ) into nine intervals, at most ﬁve of which can correspond to angles
where r is inside M B (θ). Hence, f r (θ) consists of at most ﬁve pieces, and after having computed all red-set events we can
compute each f r (θ) in O (1) time. So, over all points r ∈ R we have O (n) pieces of functions. The point of R θ with the
minimum xθ -coordinate is given by the lower envelope of these functions. Note that any two pieces intersect in at most
one point. Namely, we can only have f r (θ) = f r (θ) if θ is the orientation orthogonal1 to the line through r and r .
It is known that the complexity of the lower envelope of O (n) curves such that any two curves intersect in at most one
point is O (nα (n)) [19]. Hence, the minimum xθ -coordinate changes O (nα (n)) times. We can ﬁnd these events by computing
the lower envelope in O (n log n) time [8]. Similarly, the minimum y θ -coordinate changes O (nα (n)) times, and we can ﬁnd
the changes in O (n log n) time. We get the following lemma.
Lemma 5. There are O (nα (n)) witness events in total, and they can be computed in O (n log n) time and using O (nα (n)) storage.
3.2. A quadratic-time algorithm using O (nα (n)) storage
Our algorithm works roughly as follows. After pre-computing all non-crossing events using Lemmas 2–5, we sort them
in increasing order of the angle at which they occur. To initialize the rotational sweep, we set θ := 0 and we initialize
M B (θ), the staircase, and the red witness w θ . The most time consuming part of the initialization is the computation of the

1

In fact, there are two opposite orientations orthogonal to this line. Thus, the pieces can intersect twice. However, by treating the angles [0, π ) and

[π , 2π ) separately, we can reduce this to the case of a single intersection.

F. Sheikhi et al. / Computational Geometry 48 (2015) 673–687

677

Fig. 3. The grid G θ used to detect crossing events in a sweep interval. (For interpretation of the colors in this ﬁgure, the reader is referred to the web
version of this article.)

maximal blue points—the points deﬁning the staircase—which takes O (n log n) time. Now we start our rotational sweep. We
go through the non-crossing events in order, and handle them according to their type: if the event is a blue-rect event we
update M B (θ), if it is a blue-sc event we update the staircase, and if it is a witness event then we update the red witness.
Our task is now to detect the crossing events occurring between two consecutive non-crossing events. Recall that the
crossing events occur when the red witness crosses the horizontal or the vertical (with respect to the current coordinate
frame) edges of the staircase. Thus, potential crossing events take place when the red witness crosses the horizontal or
the vertical (with respect to the current coordinate frame) lines through the points deﬁning the staircase. In other words,
potential crossing events take place at angles deﬁned by a red point and a blue point, where the red point is one of the
points deﬁning the red witness and the blue point is one of the maximal blue points in the current coordinate frame.
We have pre-computed the non-crossing events, but we cannot afford to pre-compute and sort all (n2 ) potential crossing
events. To solve this we proceed as follows. Let θ1 , θ2 , . . . , θs be the sorted sequence of angles corresponding to the blue-rect
events, the blue-sc events, and the red-set events—we do not use the witness events here, except for the ones that are also
red-set events—and deﬁne θ0 := 0 and θs+1 = 2π . The angles θi partition [0, 2π ) into O (n) sweep intervals, and we will
detect the crossing events in each sweep interval using a grid-based approach.
Computing crossing events in a sweep interval. Let [θi , θi +1 ) be the current sweep interval to process. The crossing events in

[θi , θi +1 ) are detected as follows.

First we process the event corresponding to θi : if θi corresponds to a blue-rect event then we update M B (θ), if it
corresponds to a blue-sc event then we update the staircase, and if it corresponds to a red-set event that is also a witness
event then we update the red witness w θ .
Now we let θ increase from θi to θi +1 . As θ increases, the witness point w θ and the staircase move, and we need to
detect the events where w θ crosses the staircase. Consider the grid G θ inside M B (θ) that is deﬁned by the lines through
the edges of the blue staircase, as shown in Fig. 3.
As θ increases, the grid lines move. Since there are no blue-sc events inside the sweep interval [θi , θi +1 ), the grid lines
move in a continuous fashion. Similarly, w θ moves in a continuous fashion: there can be witness events inside [θi , θi +1 ),
but no witness events triggered by red-set events, and this implies that w θ moves continuously. Because the grid G θ and
the witness w θ move continuously as θ increases from θi to θi +1 , we can easily trace w θ through the grid and detect the
crossing events. The details are explained next.
Deﬁne C θ as the cell of G θ containing w θ . First we determine C θi , that is, the grid cell that contains w θ at the start
of the sweep interval [θi , θi +1 ). Let b1 , b2 , . . . be the maximal blue points during [θi , θi +1 ), numbered from left to right.
Determining C θi can be done in O (log n) time by two binary searches on the staircase, one using the y θ -coordinate and the
other using the xθ -coordinate of w θi . Tracing w θ through the grid means keeping track of the cell C θ . Note that all crossing
events take place at angles where C θ changes, and that it is easy to check whether such a change corresponds to a crossing
event.
Now suppose that we know the current cell C θ and we wish to know when C θ changes, that is, when w θ moves to a
neighboring cell. Let b j and b j +1 be the maximal blue points determining the top and bottom of C θ , let b j and b j +1 be the
maximal blue points determining the left and right side of C θ , and let r and r be the red points deﬁning w θ —see Fig. 3.
Using the points b j , b j +1 , b j , b j +1 and r , r , we can determine in O (1) time the angle θ ∗ at which w θ leaves C θ . Indeed,
the angle θ ∗ is the minimum among the four potential angles: the angle deﬁned by the line (b j , r ), the angle deﬁned by
the line (b j +1 , r ), the angle deﬁned by the line orthogonal to (b j , r ), and the angle deﬁned by the line orthogonal to
(b j +1 , r ). (Here ( p , q) denotes the line through two given points p , q.)
Recall, however, that the points r , r deﬁning w θ can change within a sweep interval. When this happens before the
angle θ ∗ is reached, then the computation above is invalid. Thus, apart from θ ∗ , we also need to consider θwitness , which is
the angle corresponding to the next witness event. In addition, we need to take θi +1 , the angle where the current sweep
interval ends, into account. Recall that we have pre-computed the witness events and other non-crossing events, and kept

678

F. Sheikhi et al. / Computational Geometry 48 (2015) 673–687

them in order. Thus, using these sorted lists we can have access to θwitness in O (1) time. Having θ ∗ , θwitness , and θi +1
available, the next event to handle is the one which occurs soonest. Three cases arise:
Case 1: the angle θ ∗ is the angle corresponding to the next event. In this case, w θ crosses the boundary of C θ at the angle θ ∗
before any other event. The angle θ ∗ corresponds to a potential crossing event. To handle this event ﬁrst we
update C θ : if w θ crosses the line deﬁned by b j (b j +1 , or b j , or b j +1 ), then we set j := j − 1 (or j := j + 1, or
j := j − 1, or j = j + 1, respectively). This takes O (1) time. We can also test in O (1) time whether we have a
crossing event. If so, a new output interval gets started when w θ crosses the staircase from below to above, and
the current output interval gets terminated when w θ crosses the staircase from above to below.
Finally, we repeat the procedure in the new cell C θ . (This involves computing the new angle θ ∗ at which w θ
leaves the new cell C θ , that is, repeating the computation with the updated values j , j .)
Case 2: the angle θwitness is the angle corresponding to the next event. In this case, we update the points r , r deﬁning w θ , and
we recompute the angle θ ∗ using the new points r , r . This takes O (1) time. We also need to go to the next
witness event in the list of the pre-computed witness events to update θwitness . This takes O (1) time as well. We
continue the procedure in the same cell C θ by handling the next event which will be determined by comparing
the angle θi +1 and the new angles θ ∗ and θwitness .
Case 3: the angle θi +1 is the angle corresponding to the next event. In this case, w θ stays in the same cell until the end of
[θi , θi +1 ). Thus, we are done with the current sweep interval, and can proceed to process [θi +1 , θi +2 ). Handling
this case takes O (1) time as well.
To summarize, by tracing w θ through the grid G θ , we can ﬁnd the crossing events in the sweep interval [θi , θi +1 ) in
order, and output the subintervals of [θi , θi +1 ) for which there exists a blue L-shape. After having done this for all of the
O (n) sweep intervals we are done.
Note that the output intervals that are reported are all open since the red witness is not allowed to be on the staircase.
Recall that we report the output intervals sweep interval by sweep interval. Now, besides the output intervals that have
both endpoints in a single sweep interval, there may be output intervals that start in one sweep interval but end in another
sweep interval. Thus, when we reach the end of a sweep interval, there can be an output interval that is still pending. Such
an interval will be completed when its endpoint (a crossing event) is reached in a later sweep interval, and this output
interval will be reported at that time.
Degenerate cases. Before we analyze the running time of the algorithm, we brieﬂy discuss the case when there are three or
more collinear points, and several events happen simultaneously. This is, in fact, easy to deal with: We use the “simulation
of simplicity (SoS)” technique [5], so we can proceed as if we do not have degenerate cases. (Intuitively, it means that ties
are broken arbitrarily, but in a globally consistent manner.) Then we get a number of output intervals in each sweep interval.
As explained earlier these output intervals are all open. The ones that have “inﬁnitesimal length” are caused by SoS. Thus,
by a post-processing in each sweep interval we discard the output intervals with “inﬁnitesimal length”, and report the rest.
This way we can easily deal with degeneracies.
Complexity analysis. Pre-computing all non-crossing events (blue-rect, blue-sc, red-set, and witness events) takes O (n log n)
time by Lemmas 2–5, and sorting them can be done in the same amount of time. After this, the rotational sweep that
detects the crossing events starts. The sweep is done in O (n) sweep intervals, deﬁned by the blue-rect, blue-sc, and red-set
events. The initialization at the start of each sweep interval takes O (log n) time, to determine the grid cell containing the
red witness w θ . Each event within a sweep interval takes O (1) time. The total number of events over all sweep intervals
is O (n2 ), because each event corresponds to the angle deﬁned by a pair of points. Hence, the total time for the whole
algorithm is O (n2 ). The total amount of working storage is dominated by the storage we need to store the O (nα (n))
pre-computed witness events. This leads to the following result.
Lemma 6. Let B be a set of blue points and let R be a set of red points in the plane, with n := | B | + | R |. Then, we can compute all
angular intervals for which there is a blue L-shape in O (n2 ) time and using O (nα (n)) storage.
3.3. A quadratic-time algorithm using linear storage
The algorithm described so far uses O (nα (n)) storage because it pre-computes and stores all witness events. We need
the witness events because within a sweep interval we want to trace the red witness w θ through the grid G θ . Instead of
pre-computing the witness events, we can also proceed as follows.
Recall that the red witness is deﬁned by r , r , which are the points of R θ with minimum y θ - and xθ -coordinate, respectively. The witness events are the events where r or r changes. Obviously, r and r are vertices of CH( R θ ), the convex hull
of R θ . Now we observe that R θ does not change within a sweep interval, because the red-set events are used (together with
the blue-rect and blue-sc events) to deﬁne the sweep intervals. This implies we can simply proceed as follows. Consider the
point r; the point r can be dealt with in a similar manner. At the start of the sweep interval [θi , θi +1 ) we ﬁnd the vertex of

F. Sheikhi et al. / Computational Geometry 48 (2015) 673–687

679

Fig. 4. The blue point set B used in the lower-bound construction (not to scale). (For interpretation of the colors in this ﬁgure, the reader is referred to the
web version of this article.)

CH( R θi ) with the minimum y θi -coordinate, which is the point r at that moment. This can be done in O (log n) time. As θ
increases, the vertex with the minimum y θ -coordinate may change. The new minimum vertex must then be a neighboring
vertex, and so we can compute in O (1) time the angle at which this happens. Thus every event during the sweep interval
can still be handled in O (1) time, assuming that we have CH( R θ ) available at the start of the sweep interval.
Fortunately this is easy to ensure: we compute CH( R θ ) at the start of the whole rotational sweep (that is, for θ = 0),
store it in the Overmars-Van Leeuwen dynamic convex-hull data structure [16], and then update the convex hull at each
red-set event in O (log2 n) time. Note that the Overmars-Van Leeuwen data structures maintains an explicit representation
of the convex hull, so we can indeed walk from a vertex to its neighbors in O (1) time. Since we have O (n) red-set events,
the overhead in maintaining the convex hull is O (n log2 n) time. We can conclude with the following theorem.
Theorem 7. Let B be a set of blue points and let R be a set of red points in the plane, with n := | B | + | R |. Then we can compute all
angles for which there is a blue L-shape, in a sorted order in O (n2 ) time and using O (n) storage.
4. The lower bound
In the previous section we described an O (n2 ) time algorithm to ﬁnd, given a blue point set B and a red point set R of
total size n, all subintervals of [0, 2π ) for which there exists a blue L-shape. We call such intervals blue subintervals from
now on. In this section we show that our algorithm is worst-case optimal by describing sets B and R for which the number
of blue intervals is (n2 ). To slightly simplify notation, the total number of points used in the construction will be 3n + 5,
rather than just n; clearly this is suﬃcient to prove the asymptotic lower bound.
The blue point set B = {b0 , . . . , bn+4 } is deﬁned as follows; see also Fig. 4.

• For 0 ≤ i ≤ n, we have bi = (i , −i ).
• Furthermore, bn+1 = (n4 + 2n, −n4 − 2n), bn+2 = (−n4 − n, −3n4 − 5n), bn+3 = (−3n4 − 4n, −n4 − 2n), and bn+4 =
(−n4 − n, n4 + n).
Observation 8. For 0 ≤ θ < π /4, the bounding rectangle M B (θ) is deﬁned by the points bn+1 , . . . , bn+4 , and the blue staircase consists
of the points bn+4 , b0 , . . . , bn , bn+1 . Thus, there are no blue-rect events and no blue-sc events during the angular interval [0, π /4).
The idea of the overall construction is to place n pairs of red points such that each pair induces (n) blue intervals as θ
increases from 0 to π /4. More precisely, there will be pairs r j , r j , for j = 1, . . . , n, and angles 0 = θ0 < θ1 < . . . < θn < π /4
such that

680

F. Sheikhi et al. / Computational Geometry 48 (2015) 673–687

Fig. 5. The placement of the red pair r j , r j . (For interpretation of the colors in this ﬁgure, the reader is referred to the web version of this article.)

(i) During the interval (θ j −1 , θ j ) the point r j is the lowest red point in R θ and the point r j is the leftmost red point in R θ .
(In other words, for θ ∈ (θ j −1 , θ j ) the point r j has the minimum y θ -coordinate among the points in R θ , and r j has the

minimum xθ -coordinate among those points.) Thus, during the interval (θ j −1 , θ j ) the red witness is (xθ (r j ), y θ (r j )).
(ii) During the interval (θ j −1 , θ j ), the red witness crosses the blue staircase (n) times, thus creating (n) blue intervals.
Next we specify the positions of the red points. Consider the pair r j , r j . As illustrated in Fig. 5, we deﬁne the positions of
r j , r j with respect to the rotated coordinate frame at angle θ j −1 using parameters B j and D j > 0 such that

( xθ j−1 (r j ), y θ j−1 (r j ) ) = ( B j , 0)
and

( xθ j−1 (r j ), y θ j−1 (r j ) ) = (−1, D j ).
The parameters B j , D j will be chosen such that B j , D j ≈ n4 ; the exact values will be speciﬁed later. Note that the fact that
the y θ j−1 (r j ) = 0 means that r j lies on a line at angle θ j −1 with the x0 -axis. Also note that the position of the blue points
b0 , . . . , bn in the rotated coordinate frame is given by xθ j−1 (b i ) = i ε j and y θ j−1 (b i ) = −i ε j , where

√

√

ε j = 2 · sin(π /4 − θ j−1 )

and ε j = 2 · cos(π /4 − θ j −1 ).
We now specify a condition under which the red witness, assuming it is deﬁned by r j , r j , will create (n) blue intervals.
More precisely, we give a condition under which the red witness crosses each step of the staircase in between b0 and bn .
Lemma 9. Suppose that B j , D j > 0, and that

iε j
B j − iε j

<

1 + iε j
D j + iε j

<

(i + 1)ε j
B j − (i + 1)ε j

for all i = 0, 1, . . . , n − 1,

(1)

and that

arctan

nε j
B j − nε j

≤ θ j − θ j −1 .

(2)

Then the red witness w j := (xθ (r j ), y θ (r j )) crosses all the vertical and horizontal staircase edges in between b0 and bn in order from
top to bottom as θ increases from θ j −1 to θ j .
Proof. Let s v (b i , θ) and sh (b i , θ) be the vertical and horizontal staircase steps incident to b i at angle θ respectively, and let
v (b i , θ) and h (b i , θ) be the lines containing these steps respectively. The line h (b i , θ) contains the red point r j at angle
θ = θ j −1 + arctan((i ε j )/( B j − i ε j )). Similarly, the line v (bi , θ) contains the red point r j at angle θ = θ j −1 + arctan((1 + i ε j )/
( D j + i ε j )). Now, for w j to cross all steps from b0 to bn in order as θ increases from θ j −1 to θ j , the point w j must start
above or on h (b0 ) and to the left of v (b0 ), which is indeed the case. Then, for i = 0, 1, . . . , n − 1 the point w j must ﬁrst
cross h (b i ), then cross v (b i ), and then cross h (b i +1 ). Hence, we must have

F. Sheikhi et al. / Computational Geometry 48 (2015) 673–687

iε j

θ j −1 + arctan

< θ j −1 + arctan

B j − iε j

1 + iε j
D j + iε j

< θ j −1 + arctan

681

(i + 1)ε j
B j − (i + 1)ε j

,

which is equivalent to

iε j

<

B j − iε j

1 + iε j
D j + iε j

<

(i + 1)ε j
B j − (i + 1)ε j

.

The last crossing must happen at the latest at angle θ j , so we must also have

θ j −1 + arctan

nε j
B j − nε j

✷

≤ θ j.

Lemma 9 can be used to pick B j , D j such that we can create (n) blue intervals within each angular interval [θ j −1 , θ j ).
However, we also need to make sure that the pair r j , r j actually deﬁnes the red witness during this angular interval. To
show that this can be done we will show how to place the pairs r j , r j one by one, that is, how to choose B j , D j for
j = 1, 2, . . . , n.
We start with r1 , r1 . Here we set B 1 = n4 + 2n − n2 , D 1 = n4 + n. Note that θ0 = 0, so ε1 = ε1 = 1. The condition from
Lemma 9 now states that we should have

i
n4

+ 2n

− n2

−i

<

i+1
n4

+n+i

<

i+1
n4

+ 2n − n2 − (i + 1)

for all i = 0, 1, . . . , n − 1.

It is easy to check that this holds for suﬃciently large n. Now deﬁne θ1 to be the angle at which r1 leaves M B (θ). Thus,
θ1 = arctan(n/(n3 + 2)). Then all crossings induced by the pair r1 , r1 happen before angle θ1 , because (for n ≥ 2) the last
condition from Lemma 9 is satisﬁed:

θ1 = arctan

n
n3 + 2

≥ arctan

1
n3 + 1 − n

.

We also need to make sure that r1 is inside the blue rectangle M B (θ1 ), which is indeed the case. In fact, r1 is inside M B (θ)
for all 0 ≤ θ < π /4.
Now assume we have placed pairs r1 , r1 up to r j −1 , r j −1 and we wish to place the pair r j , r j . Recall that we place r j on
the xθ j−1 -axis; see Fig. 6. We deﬁne θ j as the angle at which r j leaves M B (θ).
Observation 10. At angles θ > θ j −1 all points r1 , . . . , r j −1 are outside M B (θ). Hence, from θ = θ j −1 until θ = θ j the point r j is the
lowest red point inside M B (θ).
We place r j on the line through the point bn+4 parallel to the xθ j−1 -axis. Thus r j enters M B (θ) at the same time that
r j −1 leaves M B (θ).
Observation 11. At angle θ = θ j −1 the point r j enters M B (θ). When that happens, r j is the leftmost red point inside M B (θ). It remains

the leftmost red point inside M B (θ) until θ = θ j , when r j +1 enters M B (θ) and takes over as the leftmost red point.
The values B j and D j are chosen as follows:

B j := (n4 + 2n) · (cos θ j −1 − sin θ j −1 ) − n2 ,
and

D j := (n4 + n) · (cos θ j −1 + sin θ j −1 ).
To study the crossings induced by r j , r j , ﬁrst we bound the angle θ j using Lemma 12, then in Lemma 13 we compare θ j
and the angles corresponding to crossings of the red witness induced by r j , r j with the staircase.
Lemma
12. For n large√
enough we have 0 = θ0 < θ1 < . . . < θn < 2/n < π /12. Moreover, for 1 < i ≤ n and n large enough we have
√
2/2 < εi < 1 < εi < 2.
Proof. It follows from the construction that 0 = θ0 < θ1 < . . . < θn . To prove the ﬁrst part of the lemma it thus suﬃces to
show that θ j < 2/n for 1 ≤ j ≤ n.

682

F. Sheikhi et al. / Computational Geometry 48 (2015) 673–687

Fig. 6. General view of the point sets constructing the lower bound. (For interpretation of the colors in this ﬁgure, the reader is referred to the web version
of this article.)

First, consider θ1 . We have θ1 = arctan n/(n3 + 2) . When n tends to inﬁnity, n/(n3 + 2) tends to zero. In this case,
arctan n/(n3 + 2) < 2n/(n3 + 2). Hence, θ1 < 2/n2 . Now consider θ j for j > 1. As illustrated in Fig. 7, we have tan(θ j −

√
θ j −1 ) = n2 /(s + s ), where sin(π /4 + θ j −1 ) = (s + s )/( 2(n4 + 2n)). Hence,
n2

θ j = θ j −1 + arctan √
Since sin(π /4 + θ j −1 ) >

arctan

1
2

√

2(n4 + 2n) sin(π /4 + θ j −1 )

2 we have

n2

√

2(n4 + 2n) sin(π /4 + θ j −1 )

Thus, for large value of n we have

θ j < θ j −1 + arctan
< θ j −1 +

2n

n2
n4

+ 2n

2

n4 + 2n

< θ1 + ( j − 1) ·

.

2n2
n4 + 2n

2

< 2/n + ( j − 1) · 2/n2
≤ 2/n.
This proves the ﬁrst part of the lemma.

< arctan

n2
n4 + 2n

.

F. Sheikhi et al. / Computational Geometry 48 (2015) 673–687

683

Fig. 7. Comparing θ j −1 and θ j . (For interpretation of the colors in this ﬁgure, the reader is referred to the web version of this article.)

To prove that for 1 < i ≤ n and n large enough we have

√

√

√

2/2 < εi < 1 < εi <

√

2, we proceed as follows. Note that

εi = 2 · cos(π /4 − θi−1 ) and εi = 2 · sin(π /4 − θi−1 ). Further, according to the ﬁrst part of the lemma we have θi−1 < 2/n.
√
√
√
Hence, for n large enough we have 0 < θi −1 < π /12, and consequently we get 2/2 < εi < 1 < εi < 6/2 < 2 which
completes the proof.

✷

Next we argue that all crossings of the red witness induced by r j , r j with the staircase happen before angle θ j , which
we can do using Lemma 9 as shown next.
Lemma 13. During the interval [θ j −1 , θ j ) the red witness is deﬁned by r j , r j and it crosses

(n) steps of the staircase.

Proof. The fact that the red witness is deﬁned by r j , r j during the interval [θ j −1 , θ j ) follows from Observations 10 and 11.
Thus, it remains to plug the values of B j and D j into Lemma 9, and check that they satisfy the conditions. Recall that we
already checked this for j = 1, so now assume j > 1.
We start with Condition (1). Deﬁne

E := i ε j · (n4 + n) · (cos θ j −1 + sin θ j −1 ) + i ε j ,
and

E := (1 + i ε j ) · (n4 + 2n) · (cos θ j −1 − sin θ j −1 ) − n2 − i ε j ,
and
2

E := (i + 1)ε j · (n4 + n) · (cos θ j −1 + sin θ j −1 ) + i ε j + ε j + i ε j .
Then Condition (1) is equivalent to E < E < E . We ﬁrst prove E < E . To this end, note that (cos θ j −1 + sin θ j −1 ) =
and ε j , ε j = (1) by Lemma 12, which implies that it suﬃces to consider the n4 -terms on both sides and prove that

(1)

(1 + i ε j )n4 · (cos θ j −1 − sin θ j −1 ) < (i + 1)ε j n4 · (cos θ j −1 + sin θ j −1 ).
This follows from Lemma 12.
Next we show that E < E . Since 1 ≤ i ≤ n and

ε j , ε j = (1), this means we must show

i ε j n4 · (cos θ j −1 + sin θ j −1 ) + O (n3 ) < (1 + i ε j )n4 · (cos θ j −1 − sin θ j −1 ).
√
√
Recall that ε j = 2 · cos(π /4 − θ j −1 ) = cos θ j −1 + sin θ j −1 and ε j = 2 · sin(π /4 − θ j −1 ) = cos θ j −1 − sin θ j −1 . Hence,
i ε j n4 · (cos θ j −1 + sin θ j −1 ) = in4 · (cos θ j −1 + sin θ j −1 )2

= in4 · (1 + 2 sin θ j −1 cos θ j −1 )
and

(3)

684

F. Sheikhi et al. / Computational Geometry 48 (2015) 673–687

(1 + i ε j )n4 · (cos θ j −1 − sin θ j −1 ) = (1 + i (cos θ j −1 − sin θ j −1 )) · n4 · (cos θ j −1 − sin θ j −1 )
= n4 · (cos θ j −1 − sin θ j −1 ) + in4 · (cos θ j −1 − sin θ j −1 )2
√
= n4 · 2 sin(π /4 − θ j −1 ) + in4 · (1 − 2 sin θ j −1 cos θ j −1 )
Thus, we can rewrite Inequality (3) as

4n4 i sin θ j −1 · cos θ j −1 + O (n3 ) <

√

2n4 sin(π /4 − θ j −1 ).

(4)

Next we show that Inequality (4) is satisﬁed for 1 ≤ i ≤ n/20, which proves that the red witness crosses the staircase (n)
times. To this end, observe that since θ j −1 < π /4 we have sin θ j −1 < θ j −1 . Combining this with the fact that θ j −1 < 2/n by
Lemma 12, we get for i < n/20 that

4n4 i sin θ j −1 · cos θ j −1 + O (n3 ) < (4/10)n4 + O (n3 ).
On the other hand, since θ j −1 < π /12 by Lemma 12 we have for n large enough that

√

2n4 sin(π /4 − θ j −1 ) >

√

2n4 sin(π /6) =

1√
2

2n4 .

We can conclude that Inequality (4) (and, hence, Condition (1) of Lemma 9) is satisﬁed for 1 ≤ i ≤ n/20.
It remains to prove that Condition (2) of Lemma 9 holds. (Note that we only showed Condition (1) for i ≤ n/20, but
it follows directly from the proof of Lemma 9 that this implies that the red witness crosses the blue staircase (at least)
n/20 times, provided Condition (2) holds. In fact, we could replace n by n/20 in Condition (2).) Now we need to prove
that tan(θ j − θ j −1 ) ≥ nε j /( B j − nε j ) . As illustrated in Fig. 7, tan(θ j − θ j −1 ) = n2 /(s + s ), where s = tan θ j −1 · (n4 + 2n) ·

(cos θ j −1 − sin θ j −1 ) and s = (n4 + 2n)/cos θ j −1 . Substituting these quantities we get
tan(θ j − θ j −1 ) =

n2 cos θ j −1

(n4 + 2n) · sin θ j −1 · (cos θ j −1 − sin θ j −1 ) + n4 + 2n

.

Further,

nε j
B j − nε j

=

nε j

(n4 + 2n) · (cos θ j −1 − sin θ j −1 ) − n2 − nε j

Because θ j −1 < 2/n and

√

2/2 < ε j < ε j <

√

.

2 by Lemma 12, it is easy to see that for large value of n we have nε j /

( B j − nε j ) ≤ tan(θ j − θ j −1 ). As a result, Condition (2) of Lemma 9 can be satisﬁed which completes the proof. ✷
This concludes our proof that our construction produces

(n2 ) blue intervals as θ increases from 0 to π /4.

Theorem 14. For any n suﬃciently large, there are sets R and B of total size n such that there are
which R and B admit a blue L-shape.

(n2 ) disjoint angular intervals for

5. An output-sensitive algorithm
In the previous sections we have given an algorithm that reports all intervals for which there exists a blue L-shape in
O (n2 ) time, and we have seen that there are sets of points such that the number of such intervals is (n2 ). Hence, our
algorithm is worst-case optimal. There are situations, however, where the number of output intervals is signiﬁcantly less
than quadratic. Thus, in this section we propose an output-sensitive algorithm for computing the intervals for which there
exists a blue L-shape. The proposed output-sensitive algorithm outperforms the worst-case optimal algorithm in terms of
time complexity when the output size is subquadratic. The main idea of the proposed output-sensitive algorithm is to use
the fact that the number of non-crossing events (blue-rect, blue-sc, red-set, and witness events) is small, and the number of
crossing events is proportional to the output size. Thus, we will pre-compute the non-crossing events, and then compute all
crossing events by using some data-structuring techniques. Recall that pre-computing all non-crossing events can be done
in O (n log n) time and O (nα (n)) storage, as explained in Section 3.1.
Our output-sensitive algorithm now works as follows. After pre-computing all non-crossing events, we start our rotational
sweep. During the rotational sweep, we handle each of the non-crossing events in the normal way. However, we also need
to detect the crossing events, as follows.
Consider two consecutive non-crossing events, and let θi and θi +1 denote the angles at which these events take place.
Then we need to report all the crossing events taking place at angles θ , where θi ≤ θ < θi +1 . To this end, we store the
staircase in a suitable data structure, as explained next. The staircase consists of horizontal edges (parallel to the xθ -axis)

F. Sheikhi et al. / Computational Geometry 48 (2015) 673–687

685

Fig. 8. Concepts used in studying the situation where the red witness crosses a horizontal edge e. (a) The initial structure for the angle θi := 0. (b)
Illustrating the conditions to have e crossed by the red witness at the angle θ ∈ [θi , θi +1 ). (For interpretation of the colors in this ﬁgure, the reader is
referred to the web version of this article.)

and vertical edges (parallel to the y θ -axis). We explain how to store the horizontal edges; the vertical edges can be handled
similarly. Let p and p be two consecutive blue points along the staircase, where p has larger y θ -coordinate, and consider
the horizontal staircase edge e incident to p. Thus, the right endpoint of e is p, and the left endpoint has the same
y θ -coordinate as p and the same xθ -coordinate as p . Now suppose the red witness is deﬁned by red points r and r , with
r having larger y θ -coordinate. Thus, the red witness is the point (xθ (r ), y θ (r )). See Fig. 8(a).
This red witness crosses e for some θ ∈ [θi , θi +1 ) if and only if the following conditions are met: (i) the angle that
( p , r ), the line through p and r, makes with the (original) positive x-axis is θ , and (ii) xθ ( p ) ≤ xθ (r ) ≤ xθ ( p ). See Fig. 8(b).
We now map the edge e to the point (x0 ( p ), y 0 ( p ), x0 ( p ), y 0 ( p )) in R4 . Now, for any given red points r and r deﬁning
the red witness and angles θi and θi +1 , there is a region Q (r , r , θi , θi +1 ) in R4 with the property that the red witness
crosses a horizontal staircase edge e if and only if (x0 ( p ), y 0 ( p ), x0 ( p ), y 0 ( p )) ∈ Q (r , r , θi , θi +1 ). Thus, we store the points
of Q (r , r , θi , θi +1 ) in a dynamic data structure D so that we can perform a range query with the range Q (r , r , θi , θi +1 ).
Note that D must be updated at each blue-sc event.
Lemma 15. Conditions (i) and (ii) can be expressed as a Boolean formula whose terms are polynomials in the coordinates

(x0 ( p ), y 0 ( p ), x0 ( p ), y 0 ( p )).
Proof. To prove this we focus on the interval [0, π /2). This can be generalized to the interval [0, 2π ) as well. Let θ be the
angle that ( p , r ) makes with the positive x-axis. Condition (i) states that we must have θ ∈ [θi , θi +1 ). In other words, we
y (r )− y ( p )
must have tan θi ≤ tan θ < tan θi +1 . Recall that tan θ = x0 (r )−x 0( p ) . Substituting tan θ in the above inequalities, Condition (i)
0
0
can be expressed as conjunction of the following two inequalities:

y 0 (r ) − y 0 ( p ) − x0 (r ) · tan θi + x0 ( p ) · tan θi ≥ 0

(5)

x0 (r ) · tan θi +1 − x0 ( p ) · tan θi +1 − y 0 (r ) + y 0 ( p ) > 0

(6)

and

Now for Condition (ii) we should have xθ ( p ) ≤ xθ (r ) ≤ xθ ( p ). To express these we proceed as follows. Let θ ( p ) be the
line passing through p , whose angle with the (original) positive x-axis is π /2 + θ . To satisfy Condition (ii), the intersection
of θ ( p ) and the x-axis should lie to the left of the intersection of θ (r ) and the x-axis. Further, the intersection of θ (r )

686

F. Sheikhi et al. / Computational Geometry 48 (2015) 673–687

and the x-axis should lie to the left of the intersection of θ ( p ) and the x-axis. The intersection of θ ( p ) and the x-axis can
be written as follows: x = y 0 ( p ) · tan θ + x0 ( p ). Substituting tan θ , Condition (ii) can be expressed as conjunction of the
following two inequalities:

y 0 ( p ) y 0 (r ) − y 0 ( p ) + x0 ( p ) x0 (r ) − x0 ( p ) ≤ y 0 (r ) y 0 (r ) − y 0 ( p ) + x0 (r ) x0 (r ) − x0 ( p )

(7)

y 0 (r ) y 0 (r ) − y 0 ( p ) + x0 (r ) x0 (r ) − x0 ( p ) ≤ y 0 ( p ) y 0 (r ) − y 0 ( p ) + x0 ( p ) x0 (r ) − x0 ( p )

(8)

and

Therefore, Conditions (i) and (ii) can be expressed as conjunction of Inequalities (5), (6), (7), and (8).

✷

Hence, Q (r , r , θi , θi +1 ) is a semi-algebraic set of constant complexity. Thus, the data structure D is a data structure
for range searching with semi-algebraic sets in Rd for d = 4, and we can get the following performance [1,10]: for any
n ≤ m ≤ nb and any ﬁxed ε > 0, we can obtain O (n1+ε /m1/b + t ) query time (where t is the number of answers) with a
structure using O (m1+ε ) storage and with O (m1+ε /n) update time, where b = 2d − 4 + ε = 4 + ε . The number of queries we
have to do is equal to the total number of non-crossing events, and so the number of queries is O (nα (n)). We therefore set
m := n8/5 . This way each query takes O (n3/5+ε + t ) time and each update takes O (n3/5+ε ) time. After performing a query
and reporting t crossing events, we need to sort the crossing events in O (t log t ) time to ﬁnd the angular intervals we have
to report. This gives an overall time for our algorithm of O (n8/5+ε + k log k), where k is the number of reported angular
intervals. We obtain the following theorem.
Theorem 16. Let B be a set of blue points and let R be a set of red points in the plane, with n := | B | + | R |. Then, for any ﬁxed ε > 0,
we can compute all k angular intervals for which there is a blue L-shape in O (n8/5+ε + k log k) time and O (n8/5+ε ) storage.
6. Conclusion
We studied the following problem, which was raised by Van Kreveld et al. [12]: given a bichromatic point set in the plane
of size n, determine all angles for which there exists an L-shape completely separating points of one color from the other.
We proposed a worst-case optimal O (n2 ) time algorithm that uses O (n) storage, and an output-sensitive algorithm that
reports these angular intervals in O (n8/5+ε + k log k) time and O (n8/5+ε ) storage, where k is the number of reported angular
intervals and ε > 0 is any ﬁxed constant. One obvious open problem is to see if the running time of our output-sensitive
algorithm can be improved. Another interesting problem is to develop algorithms for more general separators, for example
orthoconvex polygons.
Acknowledgements
We would like to thank Günter Rote for helpful discussions on the topic.
References
[1] P.K. Agarwal, J. Matoušek, On range searching with semi-algebraic sets, Discrete Comput. Geom. 11 (1994) 393–418.
[2] D. Avis, B. Beresford-Smith, L. Devroye, H. Elgindy, E. Guévremont, F. Hurtado, B. Zhu, Unoriented -maxima in the plane: complexity and algorithms,
SIAM J. Comput. 28 (1999) 278–296.
[3] S.W. Bae, C. Lee, H.-K. Ahn, S. Choi, K.-Y. Chwa, Maintaining extremal points and its applications to deciding optimal orientations, in: Proc. of the 18th
Int. Sympos. Alg. Comput., ISAAC, 2007, pp. 788–799.
[4] M. de Berg, O. Cheong, M. van Kreveld, M. Overmars, Computational Geometry: Algorithms and Applications, 3rd edition, Springer-Verlag, 2008.
[5] H. Edelsbrunner, E.P. Mücke, Simulation of simplicity: a technique to cope with degenerate cases in geometric algorithms, ACM Trans. Graph. 9 (1)
(1990) 66–104.
[6] H. Edelsbrunner, F.P. Preparata, Minimum polygonal separation, Inf. Comput. 77 (1988) 218–232.
[7] S. Fekete, On the complexity of min-link red-blue separation, 1992, manuscript.
[8] J. Hershberger, Finding the upper envelope of n line segments in O (n log n) time, Inf. Process. Lett. 33 (1989) 169–174.
[9] F. Hurtado, M. Noy, P.A. Ramos, C. Seara, Separating objects in the plane with wedges and strips, Discrete Appl. Math. 109 (2001) 109–138.
[10] V. Koltun, Almost tight upper bounds for vertical decompositions in four dimensions, J. ACM 51 (5) (2004) 699–730.
[11] M. van Kreveld, T. van Lankveld, M. de Rie, (α , δ)-sleeves for the reconstruction of rectilinear building facets, in: Progress and New Trends in 3D
Geoinformation Sciences (Proceedings of 3D GeoInfo), in: Lect. Notes Geoinf. Cartogr., Springer, 2013, pp. 231–247.
[12] M. van Kreveld, T. van Lankveld, R. Veltkamp, Identifying well-covered minimal bounding rectangles in 2D point data, in: Proc. of the 25th European
Workshop on Computational Geometry, 2009, pp. 277–280.
[13] T. Lankveld, M. van Kreveld, R. Veltkamp, Identifying rectangles in laser range data for urban scene reconstruction, Comput. Graph. 35 (3) (2011)
719–725.
[14] N. Megiddo, Linear-time algorithms for linear programming in R3 and related problems, SIAM J. Comput. 12 (4) (1983) 759–776.
[15] J.S.B. Mitchell, Approximation algorithms for geometric separation problems, Technical Report, State University of New York at Stony Brook, 1993.
[16] M.H. Overmars, J. van Leeuwen, Maintenance of conﬁgurations in the plane, J. Comput. Syst. Sci. 23 (2) (1981) 166–204.
[17] J. O’Rourke, S.R. Kosaraju, N. Megiddo, Computing circular separability, Discrete Comput. Geom. 1 (1) (1986) 105–113.
[18] C. Seara, On geometric separability, Ph.D. Thesis, Univ. Politècnica de Catalunya, 2002.
[19] M. Sharir, P.K. Agarwal, Davenport-Schinzel Sequences and Their Geometric Applications, Cambridge University Press, 1995.

F. Sheikhi et al. / Computational Geometry 48 (2015) 673–687

687

[20] F. Sheikhi, M. de Berg, A. Mohades, M. Davoodi, Finding monochromatic L-shapes in bichromatic point sets, in: Proc. of the 22nd Canadian Conference
on Computational Geometry, 2010, pp. 269–272.
[21] F. Sheikhi, A. Mohades, M. Davoodi, An improved algorithm for ﬁnding monochromatic L-shapes in bichromatic point sets, in: Proc. of the Contemporary Issues in Computer and Information Sciences, Zanjan, Iran, 2011, pp. 36–39.
[22] G. Toussaint, Solving geometric problems with the rotating calipers, in: Proc. of the IEEE MELECON, A10.02/1–4, 1983.

