Artiﬁcial Intelligence 175 (2011) 1877–1910

Contents lists available at ScienceDirect

Artiﬁcial Intelligence
www.elsevier.com/locate/artint

On the complexity of core, kernel, and bargaining set ✩
Gianluigi Greco a , Enrico Malizia b , Luigi Palopoli b , Francesco Scarcello b,∗
a
b

Dipartimento di Matematica, Università della Calabria, I-87036 Rende (CS), Italy
DEIS, Università della Calabria, I-87036 Rende (CS), Italy

a r t i c l e

i n f o

a b s t r a c t

Article history:
Received 4 November 2010
Received in revised form 10 June 2011
Accepted 13 June 2011
Available online 16 June 2011
Keywords:
Coalitional games
Compact representations
Computational complexity
Solution concepts
Bounded treewidth

Coalitional games model scenarios where players can collaborate by forming coalitions in
order to obtain higher worths than by acting in isolation. A fundamental issue of coalitional
games is to single out the most desirable outcomes in terms of worth distributions,
usually called solution concepts. Since decisions taken by realistic players cannot involve
unbounded resources, recent computer science literature advocated the importance of
assessing the complexity of computing with solution concepts. In this context, the paper
provides a complete picture of the complexity issues arising with three prominent solution
concepts for coalitional games with transferable utility, namely, the core, the kernel, and
the bargaining set, whenever the game worth-function is represented in some reasonably
compact form. The starting points of the investigation are the settings of graph games
and of marginal contribution nets, where the worth of any coalition can be computed
in polynomial time in the size of the game encoding and for which various open
questions were stated in the literature. The paper answers these questions and, in addition,
provides new insights on succinctly speciﬁed games, by characterizing the computational
complexity of the core, the kernel, and the bargaining set in relevant generalizations
and specializations of the two settings. Concerning the generalizations, the paper shows
that dealing with arbitrary polynomial-time computable worth functions—no matter of
the speciﬁc game encoding being considered—does not provide any additional source of
complexity compared to graph games and marginal contribution nets. Instead, only for
the core, a slight increase in complexity is exhibited for classes of games whose worth
functions encode NP-hard optimization problems, as in the case of certain combinatorial
games. As for specializations, the paper illustrates various tractability results on classes of
bounded treewidth graph games and marginal contribution networks.
© 2011 Elsevier B.V. All rights reserved.

1. Introduction

Coalitional games were introduced by von Neumann and Morgenstern [59] in order to reason about scenarios where players can collaborate by forming coalitions with the aim of obtaining higher worths than by acting in isolation. In the Transferable Utility (TU) setting, coalition worths can be freely distributed amongst agents, while in the Non-Transferable Utility
(NTU) setting coalitions are allowed to distribute worths only in some speciﬁed conﬁgurations, called consequences [62].

✩
Preliminary versions of parts of this paper appeared in the Proceedings of the 20th and of the 21st International Joint Conferences on Artiﬁcial
Intelligence (Malizia et al., 2007 [53]; Greco et al., 2009 [38]).
Corresponding author.
E-mail addresses: ggreco@mat.unical.it (G. Greco), emalizia@deis.unical.it (E. Malizia), palopoli@deis.unical.it (L. Palopoli), scarcello@deis.unical.it
(F. Scarcello).

*

0004-3702/$ – see front matter
doi:10.1016/j.artint.2011.06.002

© 2011

Elsevier B.V. All rights reserved.

1878

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

In this paper, we consider only the classical TU setting, and thus by saying game we always mean hereafter coalitional
game with transferable utility. Such a game can abstractly be modeled as a pair G = N , v , where N is a ﬁnite set of players,
and v is a function associating with each coalition S ⊆ N a certain worth v ( S ) ∈ R that players in S obtain by collaborating
with each other. The outcome of G is an imputation, i.e., a vector of payoffs (xi )i ∈ N meant to specify the distribution of the
total worth v ( N ) granted to each player in N. Imputations are required to be eﬃcient, i.e.,
i ∈ N xi = v ( N ), and individually
rational, i.e., xi v ({i }), for each i ∈ N. In the following, the set of all imputations of G is denoted by X (G ).
It is easily seen that, for any given coalitional game G , the set X (G ) may even contain inﬁnitely many payoff vectors.
Therefore, a fundamental problem is to single out the most desirable ones in terms of appropriate notions of worth distributions, which are usually called solution concepts. Traditionally, this question was studied in economics and game theory with
the aim of providing arguments and counterarguments about why such proposals are reasonable mathematical renderings
of the intuitive concepts of fairness and stability. Well-known and widely-accepted solution concepts are the Shapley value,
the core, the kernel, the bargaining set, and the nucleolus (see, e.g., [62]). Each solution concept deﬁnes a set of outcomes that
are referred to with the name of the underlying concept. For instance, the “core of a game” is the set of those outcomes
satisfying the conditions associated with the concept of core.
1.1. Coalitional games from the AI perspective: Complexity and representation issues
Solution concepts for coalitional games have been brought to the attention of the computer science community, by
considering them from a computational point of view, in a seminal study by Megiddo [57]. There, it has been observed that
the naïve approach of explicitly listing all associations of coalitions with their worths in the speciﬁcation of coalitional games
makes the “game theory approach” hardly applicable in practice, due to the exponential blow-up of the input representation
w.r.t. the number of involved players. In fact, Megiddo [57] showed the importance of conceiving succinct representations of
coalitional games, and taking into consideration computational complexity issues when analyzing classical solution concepts,
with the aim of exhibiting eﬃcient algorithms for their calculation. In particular, Megiddo [57] exhibited polynomial-time
algorithms for computing the nucleolus and the Shapley value of cost allocation games over trees.
Another inﬂuential study on complexity issues related to coalitional games is due to Kalai and Zemel [48], who showed
polynomial-time algorithms for computing an imputation in the core of ﬂow games.
Deng and Papadimitriou [26] took a step further to use computational complexity in the analysis of coalitional games, by
arguing that decisions taken by realistic agents cannot involve unbounded resources to support reasoning, and suggesting to
formally capture the bounded rationality principle [76] by assessing the amount of resources needed to compute solution
concepts in terms of their computational complexity [26,47]. In this context, Deng and Papadimitriou [26] were interested
not only in exhibiting eﬃcient algorithms, but also in characterizing those scenarios where such algorithms are unlikely to
exist due to the inherent complexity of the solution concepts. In particular, they again noticed that computational questions
are of interest whenever worth functions are encoded in some succinct way, e.g., when they are given in terms of polynomially computable functions over some combinatorial structure. However, to the end of assessing the intrinsic complexity
of solution concepts, calling for succinct speciﬁcations is not only motivated by the practical diﬃculty of explicitly listing
all associations of coalitions with their worths, but also because with an explicit encoding the input sizes are so large that
complexity problems are trivially—and in fact artiﬁcially—easy. Coalitional games whose worth functions are encoded by
means of some succinct representation mechanism are hereinafter called compact games.
Coalitional games gained popularity in the context of multi-agent systems and artiﬁcial intelligence research since the
nineties, when they had been recognized by these research communities as very natural models to understand and reason
about cooperative action. In particular, inspired by the approach of Deng and Papadimitriou [26], the questions of ﬁnding
representation schemes to compactly encode worth functions and assessing over them the complexity of various solution
concepts have motivated most of the research on coalitional games in the AI ﬁeld. In fact, research works facing these
questions can be classiﬁed into two main groups, depending on the kinds of representation schemes being adopted (cf. [1])1 :
1. Representation schemes that are succinct, but not complete (i.e., such that there are coalitional games that cannot
be captured by such representations). Complexity analysis have been conducted on several prominent schemes of this
kind, including graph games [26], traveling salesman games [31], ﬂow games [24], matching games [49], facility location
games [37], skill games [9], threshold games [5,28,30], minimum cost spanning tree games [33], combinatorial optimization
games (see [25] and the references therein), games on combinatorial structures [12], voting games [68], games in multi-issue
domains [17], linear production games [63], bin packing games [32], permutation games [77], path disruption games [8], and
(vertex) connectivity games [10].
2. Representation schemes that are complete, but not succinct (i.e., such that there are coalitional games requiring exponential space—in the worst case—to be encoded in such representations). Inﬂuential proposals thereof are marginal
contribution nets [44], read-once (and general) marginal contribution nets [29], games with synergies among coalitions [18],
and multi-attribute games [45].

1

Details on the various representations mentioned here will be given in Section 3.1.

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

1879

Fig. 1. The graph game in Example 1.1.

In this paper, we continue along the line of analyzing the computational complexity of reasoning about compact coalitional games, by focusing on three prominent solution concepts—the core, the kernel, and the bargaining set. The starting
points of the investigation of our analysis are the settings of graph games and of marginal contribution nets, which are
representative of the two perspectives discussed above. Various open questions were in fact stated in the literature about
these classes of games. Here, we give an answer to these questions and, in addition, we provide new insights about compact games, by characterizing the computational complexity of the three solution concepts over relevant generalizations or
specializations of the basic settings.
In order to clearly illustrate our contribution, a brief introduction to the classes of games considered throughout the
paper is provided next.
1.2. Compactly speciﬁed games: Graph games and marginal contribution nets
Graph games. The setting of graph games is precisely the one analyzed by Deng and Papadimitriou [26]. In graph games,
worths for coalitions over a set N of players are deﬁned based on a weighted undirected graph G = ( N , E ), w , whose
nodes in N correspond to the players, and where the list w encodes the edge weighting function, so that w (e ) ∈ R is the
weight associated with the edge e ∈ E. Then, the worth of an arbitrary coalition S ⊆ N is deﬁned as the sum of the weights
associated with the edges contained in S, i.e., as the value v ( S ) = e∈ E |e⊆ S w (e ).
Example 1.1. Consider the graph game (induced by the weighted graph) depicted on the left of Fig. 1 over the players in
{a, b, c , d}. The subgraphs induced over the set of nodes {a, b, c } and {a, b, d} are reported on the right of the ﬁgure—for the
moment, please ignore the dashed lines. It is easily seen that the coalition {a, b, c } gets a worth v ({a, b, c }) = 2 + 2 + 1 = 5,
while the coalition {a, b, d} gets a worth v ({a, b, d}) = 3 + 2 − 1 = 4. Moreover, note that the graph encodes 24 coalition
worths, via 5 weights only. In this representation, O (n2 ) weights succinctly encode the 2n coalition worths, where n is the
number of players.
Within the setting of graph games, Deng and Papadimitriou [26] characterized the intrinsic complexity of various tasks,
mainly focusing on problems related to the core. For instance, they showed that checking whether the core is non-empty and
whether a payoff vector belongs to the core are co-NP-complete problems. Moreover, they provided a polynomial-time computable closed-form characterization for the Shapley value, and showed that this value coincides with the (pre)nucleolus.
Finally, they completed the picture of the complexity issues arising with graph games by showing the NP-hardness of deciding whether a payoff vector belongs to the bargaining set and by conjecturing the following two results for graph games:
(C1) Deciding whether a payoff vector belongs to the kernel is NP-hard; and
(C2) Deciding whether a payoff vector belongs to the bargaining set is 2P -complete.
Marginal contribution networks. A class of compact games that received considerable attention in the last few years is
that of (games encoded via) marginal contribution networks, proposed by Ieong and Shoham [44].
A marginal contribution network (short: MC-net) M consists in a set {r1 , . . . , rn } of rules involving a number of Boolean
variables that represent (and thus will be called) players. For each 1 i n, the rule r i has the form {patterni } → valuei ,
where patterni is a conjunction that may include both positive and negative literals, and valuei is the additive contribution
associated with this pattern. A rule is said to apply to a coalition S if all the players whose literals occur positively in the
pattern belong to S, and all the players whose literals occur negatively in the pattern do not belong to S. The value v ( S )
for a coalition S in the coalition game induced by M is given by the sum of the values of all rules that apply to S. If no
rule applies, then the value for the coalition is set to zero, by default.
Example 1.2. Consider the marginal contribution network consisting of the following three rules {a ∧ b} → 5, {b} → 2, and
{a ∧ ¬b} → 3, over the players in {a, b}. This network deﬁnes a coalitional game such that: v ({a}) = 3 (the third rule applies),

1880

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

Fig. 2. The MC-net in Example 1.3: Its agent graph (left), and its incidence graph (right).

v ({b}) = 2 (the second rule applies), and v ({a, b}) = 5 + 2 = 7 (both the ﬁrst and the second rules apply, but not the third
one).
Ieong and Shoham [44] suggest to graphically represent the “structure” of player interactions in MC-nets via their associated agent graphs. The agent graph associated with a marginal contribution net M is the undirected graph AG( M ) whose
nodes are the players of the game, and where, for each rule r i : {patterni } → valuei , every pair of players (nodes) occurring
in patterni are connected by an edge in AG( M ). The clique in the agent graph induced by these players weighs valuei .
Example 1.3. The agent graph associated with the marginal contribution network of Example 1.2 is deﬁned over the nodes
a and b, with an edge connecting them.
For a slightly more involved example, consider instead the marginal contribution network M consisting of the rules
r1 : {a ∧ b ∧ c } → 2, r2 : {c ∧ d ∧ e } → 1, r3 : {e } → −1, over the players in {a, b, c , d, e }. Then, the agent graph AG( M )
associated with M is the one depicted on the left of Fig. 2.
Note that, for any graph game G = ( N , E ), w , there is an equivalent MC-net representation having the same size, and
whose “structure” is preserved in that its associated agent graph coincides with G. Indeed, given any game speciﬁed via the
graph G = ( N , E ), w , we can just create the rule {i ∧ j } → w (e ), for each edge e = {i , j } ∈ E (cf. [44]). However, the converse
is not true, since MC-nets allow to express any arbitrary coalitional game, while graph games are not fully expressive. For
instance, graph games cannot model a scenario where a group of agents S has value 1 if and only if | S | > | N |/2 (see [44]
for details on the expressiveness of the frameworks).
In the light of the above observations, hardness results for graph games immediately hold over marginal contribution networks. For instance, checking whether a payoff vector is in the core and checking whether the core is non-empty
are co-NP-hard problems on MC-nets. Symmetrically, membership results for MC-nets also hold for graph games, even
when they are established over some “structurally” restricted classes of games (because the structure is preserved). For instance, for marginal contribution networks associated with acyclic agent graphs or, more generally, with agent graphs having
bounded treewidth [70], Ieong and Shoham [44] showed that deciding whether a payoff vector is in the core and deciding the
non-emptiness of the core are feasible in polynomial time. Therefore, these feasibility results immediately apply to acyclic
graph games (and, more generally, to graph games having bounded treewidth).
Moreover, Ieong and Shoham [44] proved that checking whether a payoff vector is in the core of a game encoded via
marginal contribution networks is in co-NP (as for the class of graph games). However, they left as an intriguing open
problem the following (which, in fact, does not follow from the corresponding result for graph games):
(O1) Is the problem of deciding core non-emptiness over MC-nets in co-NP?
1.3. Contributions
In this paper, we analyze the computational complexity of the core, the kernel, and the bargaining set over graph games
and marginal contribution networks. In particular, we show that conjectures (C1) and (C2) by Deng and Papadimitriou [26]
are correct, and we provide a positive answer to question (O1) by Ieong and Shoham [44]. In detail, as our main technical
contributions, we show that:

• For graph games (and for marginal contribution networks), deciding whether a payoff vector is in the kernel is NP-hard,

and actually 2P -complete;
• For graph games (and for marginal contribution networks), deciding whether a payoff vector is in the bargaining set is
P
2 -complete; and,
• For marginal contribution networks, deciding whether the core is non-empty is in co-NP.
These main achievements are summarized in Table 1. Note that the complexity of the problems of deciding the membership of a payoff vector in the core, in the kernel, and in the bargaining set (In-Core, In-Kernel, and In-BargainingSet,
respectively) are now completely characterized for graph games and marginal contribution networks. Moreover, observe
that the non-emptiness problem makes sense only for the core, given that the kernel and the bargaining set are always
non-empty over coalitional games, unless there is no imputation at all (see, e.g., [62]).

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

1881

Table 1
Summary of results. Hardness results on membership problems hold even if the payoff vector is actually an
imputation.
Problem

Graph games

MC-nets

In-Core

co-NP-complete [26]

co-NP-complete [44]

P
2 -complete
P
2 -complete

In-Kernel
In-BargainingSet

co-NP-complete [26]

Core-NonEmptiness

P
2 -complete
P
2 -complete

co-NP-complete

Hardness shown by Ieong and Shoham [44].

Table 2
Summary of results for P, wNPopt , and NPopt -representations.
Problem

P and wNPopt -representations

NPopt -representations

In-Core

co-NP-complete

D P -complete

In-Kernel
In-BargainingSet
Core-NonEmptiness

P
2 -complete
P
2 -complete

P
2 -complete
P
2 -complete

co-NP-complete

P
2 -complete

These achievements are only a part of the overall research reported in the paper. Indeed, we go beyond and study the
computational issues arising in relevant generalizations and specializations of the settings of graph games and MC-nets.
Generalizations. We consider an abstraction of compact coalitional games that is based on assuming that the worth
function is provided as an oracle operating over some given structure encoding the game. In particular, based on the computational properties of the oracle, we consider two different representation schemes:
(1) P-representations, where oracles encode functions computable in (deterministic) polynomial time w.r.t. the size of the
game. Graph games and MC-nets are two notable examples of games that can be encoded via P-representations.
(2) NPopt -representations, where oracles are powerful enough to encode NP-hard optimization problems. Combinatorial
optimization games [25] are the most notable class of games that can be encoded via NPopt -representations.
Moreover, we also consider the following restriction of the latter setting:
(3) weak NPopt -representations (short: wNPopt -representations), where the worth v ( N ) associated with the whole set N of
players is explicitly provided as an input in the game speciﬁcation, or can be computed easily (read: polynomial time)
from it, while there are no further requirements on v ( S ), for any S ⊂ N. This setting, which comprises for instance the
setting studied by Conitzer and Sandholm [18] of games with synergies among coalitions where the total worth is given
as an input, naturally arises in those scenarios where players divide some given worth that is known beforehand to all
of them.
A summary of the complexity results for the above three representations is reported in Table 2. It is easily seen that
hardness results reported in Table 1 provide lower bounds for the complexity of the problems with P, wNPopt , and NPopt representations. Notably and surprisingly, however, one may observe that nothing has to be paid for dealing not only with
arbitrary P-representations, but even with the more powerful class of wNPopt -representations. This means, in particular, that
as long as the worth v ( N ) is easily computable or given in input, the cost of computing the worth of any coalition S ⊂ N
(which generally amounts to solving an NP-hard optimization problem) has no impact on the intrinsic complexity of the
three solution concepts. An increase in complexity is instead exhibited for NPopt -representations, but just with the core.
In particular, note that membership results in Table 2 for NPopt -representations immediately entail membership results
for many problems over well-studied classes of games for which no upper bound was known. For instance, this is the case
for core-related problems over traveling salesman games [31], whose precise complexity is listed as an open problem by
Okamoto [61].
Specializations. Finally, in the last part of the paper, by following the perspective adopted by Ieong and Shoham [44], we
analyze the complexity of the solution concepts in “structurally restricted” marginal contribution networks. Our starting
point of the investigation is the observation that the agent-graph encoding often obscures the actual intricacy of the game.
For instance, classes of marginal nets with only one rule involving all the players of the game do not fall in the tractable
classes analyzed by Ieong and Shoham [44], though all solution concepts can trivially be computed over them.

1882

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

Table 3
Tractability over classes of games having bounded treewidth (btw).
Problem\btw classes

Graph games

MC-nets (agent graph)

MC-nets (incidence graph)

In-Core

P [44]

P [44]

P (small values)

In-Kernel

P (small values)

P (small values)

P (small values)

In-BargainingSet

open

open

open

Core-NonEmptiness

P [44]

P [44]

P (small values)

Motivated by this observation, our ﬁrst contribution is to propose a novel encoding based on the incidence graph of a
marginal contribution network,2 and show that this encoding is always preferable to the agent graph one. Formally, the
incidence graph IG( M ) of a marginal contribution network M is a bipartite graph, whose set of nodes consists of the
players and rules in M, and where there is an edge between a player p and a rule r if and only if p occurs in the pattern
of r. As an example, Fig. 2 reports on the right the incidence graph associated with the MC-net of Example 1.3—note that
IG( M ) is acyclic, while AG( M ) contains cycles. More generally, we shall observe that there are MC-nets whose incidence
encodings are acyclic while the corresponding agent graphs have unbounded treewidth, and that if an agent graph has
bounded treewidth, then the corresponding incidence representation has bounded treewidth too.
Based on this encoding, we then embark on a systematic study of the complexity of the solution concepts over classes
of marginal contribution nets whose incidence graphs (and, hence, agent graphs) have treewidth bounded by some ﬁxed
constant. In particular, we establish several tractability results by showing that such concepts can be expressed in terms of
optimization problems over Monadic Second Order Logic (MSO) formulae, and by subsequently applying Courcelle’s Theorem
[19] and its generalization to optimization problems due to Arnborg et al. [2].
A summary of our results is reported in Table 3. Note that, in order to get tractable classes via the logic-based approach
of Arnborg et al. [2], it turns out that the values occurring in the network must be “small”, that is, polynomially bounded in
the size of the game or, equivalently, given in unary. Thus, tractability islands identiﬁed in this paper for the core (problems
In-Core and Core-NonEmptiness) are eventually incomparable to those singled out by Ieong and Shoham [44]. In particular,
our islands lead to pseudo-polynomial algorithms when values are not small, and thus the question is open about whether
(full) polynomial-time algorithms exist for MC-nets whose incidence graphs have bounded treewidth.
Note also that the logic-based approach allowed us to derive tractability results for the kernel of marginal contribution
networks under the incidence graph encoding. Of course, such results immediately apply to the agent graph encoding—
just recall from above that incidence encodings have been proved to be more general than agent graphs—and, in turn, to
graph games—just recall from the previous section that any graph game can be encoded as a marginal contribution network
having the same (agent graph) structure. Notably, these results concerning the kernel are the ﬁrst structural tractability
results exhibited in the literature for this solution concept.
Finally, we point out that a characterization of the bargaining set in terms of optimization problems over Monadic Second
Order Logic is missing in the paper. In fact, we leave as an open problem whether In-BargainingSet remains intractable
over acyclic games and when, moreover, small values are considered.
1.4. Organization
The rest of the paper is organized as follows. Preliminaries on computational complexity are reported in Section 2. An
abstract framework for compact games is discussed in detail in Section 3. The complexity of the kernel, bargaining set, and
core is analyzed in Sections 4, 5, and 6, respectively. Structural tractability results are discussed in Section 7 and, eventually,
a few ﬁnal remarks and discussions on some open research issues are reported in Section 8.
2. Preliminaries on computational complexity
In this section we recall some basic deﬁnitions about complexity theory, and refer the reader to the work by Johnson
[46] for additional details.
2.1. The complexity of decision problems
Decision problems are maps from strings (encoding the input instance over a ﬁxed alphabet, e.g., the binary alphabet

{0, 1}) to the set {“yes”, “no”}. The class P is the set of decision problems that can be solved by a deterministic Turing
machine in polynomial time with respect to the input size, that is, with respect to the length of the string that encodes the
input instance. For a given input x, its size is usually denoted by x .
Throughout the paper, we shall often refer to computations carried out by non-deterministic Turing machines. We recall
that these are Turing machines that, at some points of the computation, may not have one single next action to perform,

2

This is inspired by the incidence graph encoding of constraint satisfaction problems (see, e.g., [41]).

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

1883

but a choice between several possible next actions. A non-deterministic Turing machine answers a decision problem if, on
any input x, (i) there is at least one sequence of choices leading to halt in an accepting state if x is a “yes” instance (such a
sequence is called accepting computation path); and (ii) all possible sequences of choices lead to a rejecting state if x is a
“no” instance. The class of decision problems that can be solved by non-deterministic Turing machines in polynomial time
is denoted by NP.
Problems in NP enjoy a remarkable property: any “yes” instance x has a certiﬁcate for it being a “yes” instance, which
has polynomial length and which can be checked in polynomial time (in the size x ). As an example, deciding whether a
Boolean formula Φ over the variables X 1 , . . . , X n is satisﬁable, i.e., deciding whether there exists some truth assignment to
these variables making Φ true, is a well-known problem in NP; in fact, any satisfying truth assignment for Φ is obviously
a certiﬁcate that Φ is a “yes” instance, i.e., that Φ is satisﬁable.
The class of problems whose complementary problems are in NP is denoted by co-NP. Of course, the class P is contained
in both NP and co-NP. The class D P is the class of problems that can be deﬁned as a conjunction of two problems, one
from NP and one from co-NP, while its complement co-D P is the class of problems that can be deﬁned as the disjunction
of two problems, one from NP and one from co-NP. Thus, D P and co-D P are supersets of both NP and co-NP.
Throughout the paper, we shall also refer to a type of computation called computation with oracles. Intuitively, oracles
are subroutines which are supposed to have unit cost.
The classes kP , kP , and kP , forming the polynomial hierarchy, are deﬁned as follows: 0P = 0P = P and for all k 1,
P
k

P

= NPΣk−1 ,

P
k
P
.
k

P

= PΣk−1 , and
P
k

P
k

= coP
k)

P
k

where co-

P
k

denotes the class of problems whose complementary problem

Here,
(resp.,
models computability by a non-deterministic (resp., deterministic) polynomial-time
is solvable in
Turing machine that may use an oracle in kP−1 . Note that 1P coincides with NP, and that 1P coincides with co-NP.
We conclude by recalling the notion of reducibility among decision problems. A decision problem A 1 is polynomially
reducible to a decision problem A 2 , denoted by A 1 p A 2 , if there is a polynomial-time computable function h (called
reduction) such that, for every x, h(x) is deﬁned and x is a “yes” instance of A 1 if and only if h(x) is a “yes” instance of A 2 .
A decision problem A is hard for a class C of the polynomial hierarchy (at any level k 1, i.e., beyond P) if every problem
in C is polynomially reducible to A; if A is hard for C and belongs to C , then A is said to be complete for C . Thus, problems
that are complete for C are the most diﬃcult problems in C . In particular, they cannot belong to some lower class in the
hierarchy unless some collapse occurs.
Characterizing the precise computational complexity of a problem means understanding its sources of complexity. This
information may allow us to identify tractable instances by limiting some source of intractability, and to design and analyze
algorithms. For instance, note that any 2P -complete problem exhibits two orthogonal sources of intractability. To give an
idea of some practical consequence of this fact, assume we would like to solve such a problem on a standard (deterministic)
machine. Then, the theory tells us that we cannot design any ﬂat-backtracking algorithm for our problem, unless P = NP.
Indeed, any algorithm with a search-space tree having a polynomial number of levels (and such that moving along the tree
edges does not take exponential time) should solve a nested co-NP-hard problem to check whether a leaf node is a solution
or not. That is, checking leaf-feasibility is an intractable problem as well, and hence it requires a nested call to a further
backtracking procedure (or to another kind of procedure with an exponential-time worst case).
2.2. Complexity classes of functions
Often, we are interested in search problems where, for any given instance, a (non-Boolean) solution must be computed.
The complexity classes of functions allow us to distinguish such problems according to their intrinsic diﬃculty, which is
particularly relevant when their associated decision problems belong to the same complexity class.
Let a ﬁnite alphabet Σ with at least two elements be given. A (partial) multi-valued function f : Σ ∗ → Σ ∗ associates
no, one or several outcomes (results) with each input string. Let f (x) stand for the set of possible results of f on the
input string x; thus, we write y ∈ f (x) if y is a value of f on the input string x. Deﬁne dom( f ) = {x | ∃ y ( y ∈ f (x))}
and graph( f ) = { x, y | x ∈ dom( f ), y ∈ f (x)}. If x ∈
/ dom( f ), we say that f is undeﬁned at x. The function f is total if
dom( f ) = Σ ∗ . The function f is single-valued if | f (x)| = 1, for each x ∈ dom( f ).
We say that a multi-valued function f is polynomially balanced if, for each x, the size of each result in f (x) is polynomially bounded in the size of x. Then, the class NPMV is deﬁned as the set of all multi-valued functions f such that (i) f is
polynomially balanced and (ii) graph( f ) is in NP.
By analogy, the class NPMV g (also known as FNP [64]) is deﬁned as the class of all polynomially-balanced multi-valued
functions f for which graph( f ) is in P. If we deal with (partial) single-valued functions, we get the corresponding classes
NPSV and NPSV g , respectively [74].
A transducer is a (possibly, non-deterministic) Turing machine T on the alphabet Σ with a read-only input tape, a read–
write work tape, and a write-only output tape. For any string x ∈ Σ ∗ , we say that T accepts x if T has an accepting
computation-path on x. For each x ∈ Σ ∗ accepted by T , we denote by T (x) the set of all strings that are written by T
on the output tape in its accepting computation-paths on input string x. Thus, every transducer is associated with some
multi-valued function f (we say that T computes f ) such that, for each x ∈ Σ ∗ , f (x) = T (x) if x is accepted by T ; otherwise,
f is undeﬁned at x (i.e., x ∈
/ dom( f )).

1884

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

The class FP consists of all functions that are computed by deterministic Turing transducers in polynomial time. The
class NPMV can be equivalently characterized as the class of all multi-valued functions that can be computed by nondeterministic transducers in polynomial time.
It is worthwhile noting the difference between the two classes NPMV g and NPMV. In fact, NPMV contains more complex functions than NPMV g (assuming P = NP). For instance, consider the problem of computing the partial multi-valued
function f H that, given a graph G, outputs the Hamiltonian cycles of G (if any). This function is in NPMV g since graph( f H )
is polynomially balanced and decidable in deterministic polynomial time (for any pair G , C , just check whether C is a
Hamiltonian cycle of G). Let us consider now the weighted version of this problem, where the input graph G is edgeweighted, and the function values are the weights of the Hamiltonian cycles of G (if any). Then, this partial multi-valued
function, say f WH , belongs to NPMV but does not belong to NPMV g (unless P = NP). Indeed, deciding whether a given
pair G , w (graph, weight) belongs to graph( f WH ) is clearly NP-complete, as one needs to exhibit some Hamiltonian cycle
having weight w in order to recognize that w is a correct function value.
To conclude, we notice that, like Turing machines, transducers can use oracles while computing. In particular, in this
paper we will use the class F 2P , which contains those functions computable in polynomial time via a deterministic Turing
transducer using an NP oracle.
3. A formal framework for compact representations
Graph games and marginal contribution networks are two prominent examples of compact representations for coalitional
games, whose worth functions are deﬁned in terms of some suitable (combinatorial) structure, instead of listing the worths
of all coalitions. In fact, several other compact representations have been proposed in the literature, as we illustrated in
Section 1. In this section, we shall provide a unifying framework for them, which will be the basis for our subsequent
complexity analysis.
A compact representation R deﬁnes suitable encodings for a class of coalitional games, denoted by C (R). Formally, any
representation R deﬁnes an encoding function ξ R and a worth function v R such that, for any coalitional game G ∈ C (R),
ξ R (G ) is the encoding of the game G , and v R (ξ R (G ), S ) is the worth associated with the coalition S according to G . Note
that v R is total and single-valued.
As an example, let us denote by GG the graph game representation. Then, any coalitional game G ∈ C (GG ) is encoded
as a weighted graph ξ GG (G ), and the worth function v GG (ξ GG (G ), S ) is computed for every coalition S by taking the
sum of the weights of all edges of ξ GG (G ) included in S. Similarly, for the case of the marginal contribution nets compactrepresentation MCN , any game G is encoded by a set of rules ξ MCN (G ), and the function v MCN (ξ MCN (G ), S ) computes
the worth of S as the sum of the values of those rules in ξ MCN (G ) that apply to coalition S.
Whenever a compact representation R is understood, we can just write G instead of ξ R (G ), and v ( S ) instead of
R
v (ξ R (G ), S ). While doing so, we are identifying the game with its actual representation (by furthermore ignoring the
actual procedure underlying the computation of the worth values). In fact, this is very popular in the literature. For instance,
the naming “marginal contribution network” usually denotes a coalitional game rather than—more formally—its encoding.
Similarly, the weighted graph underlying the deﬁnition of a graph game is usually identiﬁed with the game itself.
3.1. Computational-based classiﬁcation of games representations
The framework we are going to illustrate is based on classifying any compact representation R on the basis of the
computational properties of the associated worth function v R . In particular, two basic kinds of representation will be
considered, corresponding to polynomial-time functions and to functions powerful enough to encode NP-hard optimization
problems. A weak variant of this latter setting will also be discussed.
3.1.1. P-representations
Let us start with the computationally cheapest representation.
Deﬁnition 3.1. Let R be a compact representation for coalitional games. We say that R is a polynomial-time compact representation (short: P-representation) if v R belongs to FP, i.e., if it is polynomial-time computable by a deterministic transducer.
Note that both GG and MCN are based on worth functions that are eﬃciently computable. Other polynomial-time
compact representations that received considerable attention in the literature are reported below:
Minimum cost spanning tree games [57]: Let N be a set of players and consider the complete graph K N on the node set
/ N is a distinguished (supply) node. Assume that the edges of K N have associated nonnegative
N ∪ {0}, where 0 ∈
weights. Then, the function v ( S ) returns, for each coalition S ⊆ N, the cost of a minimal spanning tree on the
node set S ∪ {0}. This cost, which can be computed in polynomial time (see, e.g., [20]), reﬂects the minimum cost
of guaranteeing the connectivity of players in S with the supply node 0.
Flow games [48]: A ﬂow network is given, that is, a directed graph D = ( N , E ) with a source node s ∈ N, a sink node
t ∈ N, and where each edge in E is associated with a weight denoting its capacity. Each player controls one of the

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

1885

directed edges in E, and the worth v ( S ) of each coalition S ⊆ E is the value of a maximum ﬂow from s to t in
the subnetwork induced by S. Note that this is a P-representation, since a maximum ﬂow can be computed in
polynomial time (see, e.g., [20]).
Linear production games (Owen’s model) [63]: There are m resources and p ﬁnal goods, such that the price of good j is
denoted by v j . A set N of players is given, and each player i ∈ N is endowed with bki units of resource k. Linear
production technologies can be used to transform resources into goods. This is formalized via a matrix A ∈ Rm× p
such that A k, j is the units of resource of type k needed to produce one unit of good j. For each coalition S ⊆ N, its
members share their resources and, thus, the value v ( S ) is deﬁned as the maximum market value of the outputs
that can be jointly produced by the members of S, that is:

v ( S ) = max

v jxj
j

such that

j

xj

A k, j x j
0

i∈ S

bki

for each resource k
for each good j

Note that v ( S ) can be computed in polynomial time, since it is the solution of a linear program [65] (we stress
here that values A k, j ’s in the linear program are constants, since those are values explicitly expressed in the input
game representation).
Games in multi-issue domains [17]: In this representation scheme, a set N of players is concerned with a set T of independent issues that each coalition can address. In general, each issue i ∈ T is formalized as a coalitional game
having its own worth function v i : 2 N → R, which just concerns a set C i ⊆ N of players, i.e., v i ( S 1 ) = v i ( S 2 ), for
each pair of coalitions S 1 and S 2 such that S 1 ∩ C i = S 2 ∩ C i . Then, the worth v ( S ) of a coalition S ⊆ N is the sum
of the contributions over all the issues, i.e., v ( S ) = i ∈ T v i ( S ). By assuming that, for each i ∈ T , |C i | is bounded
by a ﬁxed constant, all the functions can be represented in constant space and v ( S ) can be computed in linear
time.
Multi-attribute games [45]: We are given a set N = {1, . . . , n} of agents and a set M = {1, . . . , m} of attributes, with a
matrix A ∈ Rm×n where A i , j denotes the value of attribute i for agent j. Moreover, we are given the functions
a : Rm×n × 2 N → Rm and w : Rm → R aggregating the attributes of the agents in any coalition S ⊆ N into a single
value per attribute, and grouping such aggregated values, respectively. Then, the worth v ( S ) is deﬁned as the value
w (a( A , S )). This representation is capable to describe any coalitional game, and in fact the space needed to list all
the associations of values determined by the function a is exponential in general (w.r.t. the number of players).
Indeed, just notice that a is also a function of the given coalition. However, in some relevant cases (for instance,
whenever a just sums the contributions of all the agents in the coalition), exponentially more succinct encodings
can be used, yet preserving its polynomial-time computability.
Weighted voting games [58]: A set N of players is given, together with a non-negative value q ∈ R. For each player i ∈ N,
a non-negative weight w i is additionally given, so that the worth v ( S ) of each coalition S ⊆ N is 1 if
q;
i∈ S w i
otherwise, v ( S ) = 0 holds.
Read-once (and general) marginal contribution nets [29]: The so-called general marginal contribution networks are generalizations of MC-nets, where the pattern of each rule can be an arbitrary Boolean formula (i.e., including
conjunctions, negations, and disjunctions) over the variables representing the players of the game. Read-once
nets restrict Boolean formulae to be read-once, in the sense that each variable can appear only once. Despite
the increased expressive power w.r.t. MC-nets, the worth of any coalition can be still computed in polynomial
time.
Skill games [9]: We are given a set N of agents, each one owning some skills. The agents have to perform certain tasks
from a set T , each one requiring a set of skills in order to be accomplished. Thus, each coalition S ⊆ N is capable of
carrying out the set T ( S ) ⊆ T of all those tasks whose required skills are owned by the players in S. A task value
(increasing) function u : 2 T → R is additionally given, which maps any subset of the tasks a coalition achieves to a
real value. The worth v ( S ) of S is, then, the value returned by u over all the tasks that can be carried out by S, i.e.,
v ( S ) = u ( T ( S )). This general representation requires space exponential in | T | (needed for encoding the function u).
Succinct representations are obtained whenever | T | is bounded by some ﬁxed constant, or when the task value
function u is of special forms (such as counting the total number of tasks accomplished by the coalition).
Matching games [75,49]: We are given an undirected graph G = ( N , E ). The player set is N and the value of a coalition
S ⊆ N is deﬁned as the size of a maximum matching, i.e., of a set of disjoint edges in the subgraph induced by
the nodes in S. Note that this is a P-representation, since a maximum matching can be computed in polynomial
time [34].
Path disruption games [8]: We are given a graph G = ( V , E ) and two vertices a, b ∈ V , namely the source and the target
vertices. The player set is N = V \ {a, b} and the value of a coalition S ⊆ N equals 1 if removing from G all the
vertices in S results in the vertex a to be completely disconnected from b (i.e., there is no path between them).
Otherwise the value of the coalition is 0.
(Vertex) Connectivity games [10]: We are given a graph G = ( V , E ), and a partition of V in the three sets V p (primary
vertices), V b (backbone vertices), and V s (standard vertices). The player set is V s and the value of a coalition
S ⊆ V s equals 1 if every pair of primary vertices is connected in the subgraph of G induced over the vertices in
V p ∪ V b ∪ S. Otherwise the value of the coalition is 0.

1886

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

3.1.2. NPopt -representations
In certain domains where worth functions reﬂect results of complex algorithmic procedures or combinatorial problems,
P-representations are not adequate. In these cases, more powerful representations are needed, as illustrated in the following
example.
Example 3.2. An undirected graph G = ( N , E ) is given. The player set is N and the value of a coalition S ⊆ N is deﬁned
as the size of a maximum clique in the subgraph induced by the nodes in S. Computing the size of a maximum clique is
a well-known NP-hard problem (see, e.g., [35]). Therefore, under standard complexity assumptions, such a game cannot be
encoded in any P-representation.
Note that the above class of games is just an instance of the very general framework of combinatorial games discussed
by Deng et al. [25]. Roughly, in this framework, each coalition S is associated with a system L S of (mixed-)integer linear
inequalities, which can be built in polynomial time (w.r.t. the size of the game). Let Ω( L S ) denote the set of all feasible
solutions of L S . Then, the worth of S can be deﬁned as the maximum over all these values, i.e., v ( S ) = max{ y | y ∈ Ω( S )}.
For instance, in the games of Example 3.2, given the graph G = ( N , E ), the worth function can be written as follows:

v ( S ) = max

xv
v ∈V

such that

xv + xv
x v ∈ { 0, 1 }

1 ∀{ v , v } ⊆ N s.t. { v , v } ∈
/E

∀v ∈ N

Inspired by this general framework, we propose the following NPopt -representation scheme to capture games deﬁned in
terms of optimization problems (not necessarily speciﬁed via systems of mixed-integer linear inequalities).
Deﬁnition 3.3. Let R be a compact representation for coalitional games. We say that R is an optimization non-deterministic
polynomial-time compact representation (short: NPopt -representation) if the worth function v R is such that, given a set S of
players in a game G ∈ C (R), v R (ξ R (G ), S ) = max{ w | w ∈ f R (ξ R (G ), S )}, where f R is an NPMV function (i.e., computable
by a non-deterministic transducer in polynomial time) called the feasibility function (of R).
Note that the role of f R in the above deﬁnition is to provide the values associated with all possible feasible solutions,
so that v R will select the best one among them.3 For instance, in the case of the games in Example 3.2, the feasibility
function returns the set of all sizes of possible cliques: This function is clearly a multi-valued one, and a polynomial-time
non-deterministic transducer may compute any value by just guessing (with polynomially many bits) a clique, and then
returning its size as the output.
Other representations for coalitional games proposed in the literature and based on some NP-hard optimization problem
are illustrated next. The reader may want to check that, for each of them, the associated feasibility function is computable
in NPMV:
Games with synergies among coalitions [18]: A set N of players is given together with a set W = {( B 1 , v ( B 1 )), . . . ,
( B n , v ( B n ))} of pairs where B i ⊆ N is a coalition and v ( B i ) is its associated worth (explicitly given in input).
For any coalition S ⊆ N, the worth is then given by the maximum of
( B i , v ( B i ))∈ W v ( B i ) over all the subsets W
of W such that coalitions in W form a partition of S. Conitzer and Sandholm [18] observed that this representation is capable of capturing any possible worth function, if the set W is allowed to contain exponentially may
pairs (w.r.t. the number of players). In the relevant cases where W contains just polynomially many pairs (those
that introduce “synergy”), the size of the input is exponentially more succinct, but computing the worth of any
coalition becomes NP-hard.
Traveling salesman games [31]: Let N be a set of players and consider the complete graph K N on the node set N ∪ {0},
/ N is a distinguished node. Assume that the edges of K N have associated nonnegative weights. Then, the
where 0 ∈
function v ( S ) returns, for each coalition S ⊆ N, the cost of the minimum length traveling salesman tour visiting
all nodes in S ∪ {0}, i.e., the minimum cost of connecting 0 with all the players in S with a ring structure.
Facility location games [37]: A set N of customers needs a service which can be provided by connecting them to any
facility taken from a given set F . Facilities are initially “close”. Opening (or building) a facility i ∈ F costs f i 0,
and connecting customer j to it costs c i , j 0. As additional constraints, some facilities might be given that can
handle just some ﬁxed number of customers, and certain customers might be precluded to be assigned to certain
facilities. For these games, v ( S ) returns the minimum cost of providing the service to all players in S.

3
Readers that are familiar with the theory of optimization problems might like to notice that the class of maximization functions in Deﬁnition 3.3 has
the same computational power as the class OptP [52] of those functions that can be computed as the maximum over all the values written on the branches
of an NP metric Turing machine, i.e., of a machine that halts on every branch and writes a number. These values play indeed the role of the feasible values
returned by f R . Thus, Deﬁnition 3.3 might equivalently be restated by saying that R is an NPopt -representation if v R is computable in OptP. In the paper,
we prefer to use the formulation based on a feasibility function, since we feel it is more intelligible to a wider audience, being based on standard Turing
machines.

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

1887

Combinatorial games over graphs [25]: A graph G = ( N , E ) is given, and the worth v ( S ), for each coalition S ⊆ N, is deﬁned as the solution to some (typically, NP-hard) optimization problem over the subgraph induced by S. In the
case of the games discussed in Example 3.2, the optimization problem is that of computing a clique of maximum cardinality. Among the other problems considered by [25], we mention here minimum vertex cover, maximum
independent sets, minimum edge cover, and minimum coloring.
Bin-packing games [32]: A set {1, . . . , n} of items whose nonnegative sizes are a1 , . . . , an , and a set {1, . . . , m} bins whose
b j , for all
nonnegative sizes are b1 , . . . , bm are given. It is assumed that every item ﬁts every bin, that is, ai
1 i n and 1
j m. The set N of players consists of all the items and all the bins. Let S = A ∪ B ⊆ N be a
coalition, where ∅ ⊆ A ⊆ {1, . . . , n} is a set of items, and ∅ ⊆ B ⊆ {1, . . . , m} is a set of bins. The worth function
associates with S the maximum total size of items in A that can be packed into bins in B.
Permutation games [77]: There is a set N of n players. Each player i ∈ N has a job J i and a machine M i . Any machine can
process at most one job, and ki , j is the cost for executing job J i on machine M j . For each coalition S, the worth
function is deﬁned by v ( S ) = min i ∈ S ki ,π (i ) , where the minimum is taken over all permutations π : S → S, and
the value π (i ) indicates on which machine is executed the job of player i; that is, machine M π (i ) processes job J i .
In fact, some of the classes of games discussed above include functions deﬁned in terms of minimization problems
rather than maximization ones. In these cases, the underlying coalitional games are usually cost-minimization games, where
players are not willing to maximize the worth they receive (as we presented them in the Introduction), but they are rather
interested in minimizing the cost paid when carrying out certain tasks. Cost-minimization coalitional games come in the
literature with their own speciﬁc deﬁnitions for the various solution concepts. However, such deﬁnitions are completely
interchangeable with the (standard) ones for worth-maximization games, provided that each cost is viewed as the opposite
of a worth (i.e., by inverting its algebraic sign). Therefore, as often done in the literature, we can just focus on one of the two
settings only, without any loss of generality (thus, all the above classes of games actually ﬁt Deﬁnition 3.3). In particular,
we shall discuss the solution concepts as they are commonly deﬁned for worth-maximization games and, accordingly, we
have assumed optimization problems for NPopt -representations to be maximization ones.
We end the section by noticing that NPopt -representations include those cases where worth functions can be computed
on the basis of the answer to some NP-complete decision problem, rather than as the optimal solution to an optimization
problem.
Example 3.4 (Graph games with legal coalitions). Consider a slight modiﬁcation of the setting of graph games in which only
certain kinds of coalitions are allowed to form.
Let G = ( N , E ), w be a weighted graph. For a coalition S ⊆ N of nodes, let an S-cut be a pair ( S 1 , S 2 ) such that
S 1 ∪ S 2 = S and S 1 ∩ S 2 = ∅, and let the weight of ( S 1 , S 2 ) be the sum of all the weights of the edges in E having one
of their endpoints in S 1 and the other in S 2 . For a threshold σ ∈ R, we say that S is legal (w.r.t. σ ) if the weight of the
maximum S-cut is greater than σ .
As an example, consider again the graph game depicted on the left of Fig. 1 over the players in {a, b, c , d}, and let
σ = 4 be the given input threshold. Then, the weight of the maximum cut for the coalition {a, b, c } is the one illustrated
in the ﬁgure, whose weight is 4. Hence {a, b, c } is not legal. Instead, the coalition {a, b, d} is legal, since the weight of the
maximum cut for {a, b, d} is 5.
Consider now the following worth function, where M is an arbitrarily large penalty assigned to coalitions that are not
legal:

v(S) =

e ∈ E |e ⊆ S

−M

w (e )

if S is legal
otherwise

To reformulate this function as a maximization problem, it suﬃces to consider the feasibility function f such that f ( S ) =
{− M } ∪ { e∈ E |e⊆ S w (e ) | S is legal}. In fact, f is multi-valued, and its maximum value is e∈ E |e⊆ S w (e ) if and only if S is
legal. Moreover, f is computable by a non-deterministic transducer in polynomial time, given that deciding whether the
weight of the maximum cut in a graph is greater than a given threshold is an NP-complete problem [35].
In fact, this example provides a general template to deﬁne several other instances of NPopt -representations, depending
on the speciﬁc semantics underlying the notion of “legal” coalition (and, of course, on the worth assigned to such legal
coalitions). For instance, in a planning environment, legal coalitions might be those that can achieve the desired goal. In a
service composition scenario, legal coalitions might be such that a subset of their members can provide the whole set of
tasks whose interplay form the desired service, while satisfying some budget constraints.
3.1.3. wNPopt -representations
As a special case of NPopt -representations, we next consider classes of games where the worth v ( N ) associated with
the whole set N, i.e., the total available worth, is easy to compute or is directly given as a part of the input instance. For
instance, this is the case in the setting of games with synergies among coalitions [18], already described above.
Deﬁnition 3.5. Let R be a compact representation for coalitional games. We say that R is a weak NPopt -representation
(short: wNPopt -representation) if the worth function v R is such that, given a game G ∈ C (R),

1888

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

(1) v R (ξ R (G ), N ) is computable in polynomial time, where N is the whole set of players in G ; and
(2) for each coalition S ⊂ N, v R (ξ R (G ), S ) = max{ w | w ∈ f R (ξ R (G ), S )}, where the feasibility function f R is in NPMV.
Note that P-representations are clearly a special case of wNPopt -representations, where f R is a (single-valued)
polynomial-time function.
Remark 3.6. In fact, the notion of wNPopt -representation can be further generalized by lifting the cost of computing
v R (ξ R (G ), N ) from polynomial time to NPSV without affecting any of our results (but two membership proofs, which
would require a couple of straightforward modiﬁcations—an easy exercise for the interested reader). That is, such an extra
power in the function deﬁning the total worth comes for free, as far as the computational complexity of the solution concepts analyzed in this paper is concerned. However, for the sake of presentation and readability, we preferred to adopt the
more familiar polynomial-time functions.
We just observe here that, by using NPSV functions instead, we could model classes of games where computing the total
worth involves the solution of rather hard tasks. For example, one can imagine an extension of games with synergies among
coalitions where, instead of having the total worth v R (ξ R (G ), N ) as an input, this value is deﬁned as the maximum payoff
that any agent may obtain by playing some simple stochastic game [16], which can be easily seen to be an NPSV function
(see, e.g., [79]).
3.2. Expressive power of game representations
In the previous section, we have classiﬁed game representations based on the intrinsic complexity of the associated
worth functions. Here, we complete the picture by discussing the expressive power of game representations.
Let R be a game representation. If all coalitional games can be represented by R, we say that this representation is
complete. Of course, when analyzing a representation R (and comparing it with some other ones), one may ﬁrstly want to
ask whether R is complete or not. For instance, MCN is a complete representation, while GG is not. However, there are
games whose MCN encodings have size exponential in the number of players [44,29].
For comparison purposes, it is therefore relevant to look for a notion that captures expressiveness and succinctness of
the speciﬁcations, as we formalize below.
Deﬁnition 3.7. Let R1 and R2 be a pair of game representations. We say that R2 is at least as expressive (and succinct)
as R1 , denoted by R1 e R2 , if there exists a function f in FP that translates a game ξ R1 (G ) represented in R1 into an
equivalent game ξ R2 (G ) represented in R2 , that is, into a game with the same players and the same worth function as the
former one. More precisely, we require that ξ R2 (G ) = f (ξ R1 (G )) and v R1 (ξ R1 (G ), S ) = v R2 (ξ R2 (G ), S ), for each coalition
of players S in the game G .
Note that if R1 e R2 holds, then any hardness result for the complexity of reasoning problems over R1 immediately
apply to R2 , as well as any membership result for problems over R2 immediately apply to R1 . Thus, expressiveness relations can be used to derive further complexity results after the complexity of some representation has been characterized.4
It follows that it is convenient to prove hardness results for the least expressive representations and membership results
for the most expressive ones. In particular, as far as the latter kind of representations is concerned, we consider the very
general NPopt and wNPopt representations; for the former kind of representations, we focus on graph games because they
are both interesting in their own and less expressive than many other representations. For instance, it can easily be shown
that GG e MCN , and thus hardness results for graph games immediately apply to marginal contribution nets (cf. [44]).
In fact, we explicitly discuss results on marginal contribution nets, as they are a minimal natural extension of graph games
that preserves their nice features (in terms of easiness of representation), but it is able to represent any coalitional game.
Of course, if one is interested in hardness results for some representation that is incomparable with graph games (w.r.t.
the above notion of expressiveness), then our results cannot be directly applied, and ad hoc reductions should be devised.
4. The complexity of the kernel
The kernel is a solution concept introduced by Davis and Maschler [22]. To review its deﬁnition, we need to state some
preliminary concepts and notations, which will be extensively used throughout the paper.
For any coalition S ⊆ N, let | S | denote the cardinality of S, and let R S be the | S |-dimensional real coordinate space,
whose coordinates are labeled by the members of S; in particular, given a payoff vector x ∈ R S , xi denotes the component
associated with the player i ∈ S. A vector x ∈ R S is called an S-feasible vector if
i ∈ S xi = v ( S ). The value
i ∈ S xi will be
simply denoted by x( S ) in the following.

4
We are implicitly assuming to talk about complexity results beyond P that are the subject of this paper, because for tractable classes inside P we should
use translation functions below FP.

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

1889

Fig. 3. The game K (φ), where φ = (α1 ∨ ¬α2 ∨ α3 ) ∧ (¬α1 ∨ α2 ∨ α3 ).

For any pair of players i and j of a coalitional game G = N , v , we denote by Ii , j the set of all coalitions containing
player i but not player j. The excess e ( S , x) = v ( S ) − x( S ) of the generic coalition S at the imputation x ∈ X (G ) is a measure
of the dissatisfaction of S at x. Deﬁne the surplus si , j (x) of player i against player j at an imputation x as the value
si , j (x) = max S ∈Ii, j e ( S , x) = max S ∈Ii, j ( v ( S ) − x( S )).
Intuitively, the surplus of player i against j at x is the highest payoff that player i can gain (or the minimal amount i
can lose, if it is a negative value) without the cooperation of j, by forming coalitions with other players that are satisﬁed
at x; thus, si , j (x) is the weight of a possible threat of i against j. In particular, player i has more “bargaining power” than
j at x if si , j (x) > s j ,i (x); however, player j is immune to such threat whenever x j = v ({ j }), since in this case j can obtain
v ({ j }) even by operating on her own. We say that player i outweighs player j at x if si , j (x) > s j ,i (x) and x j > v ({ j }). The
kernel is then the set of all imputations where no player outweighs another one:
Deﬁnition 4.1. The kernel K (G ) of a TU game G = N , v is the set:

K (G ) = x ∈ X (G ) si , j (x) > s j ,i (x) ⇒ x j = v { j } , ∀i , j ∈ N , i = j .
Example 4.2. Let G = N , v be a TU game with N = {a, b, c }, v ({a}) = v ({b}) = v ({c }) = 0, v ({a, b}) = 20, v ({a, c }) = 30,
v ({b, c }) = 40, and v ({a, b, c }) = 42.
It is easily veriﬁed that the imputation x such that xa = 4, xb = 14, and xc = 24 is in the kernel of G . Indeed, we note
ﬁrst that every player in N receives in x a payoff strictly greater than what she is able to obtain by acting on her own. For
this reason, in order for x to belong to K (G ) it must be the case that si , j (x) s j ,i (x), for all distinct players i and j. By the
deﬁnition of the worth function, the maximum excess that a coalition S including i and excluding j can achieve is obtained
by the coalition S ∈ Ii , j such that | S | = 2. By this, si , j (x) = s j ,i (x) = 2 for all pairs of different players i , j. Thus, x ∈ K (G ).
It is well known that K (G ) = ∅, whenever X (G ) = ∅ (see, e.g., [62]). Thus, the non-emptiness problem is trivial for this
concept. Instead, as discussed by Deng and Papadimitriou [26], it is of interest to ask for the computational complexity of
deciding whether a given payoff vector belongs to the kernel. This problem was conjectured to be NP-hard by those same
authors [26], even for graph games. In the rest of the section, we ﬁrstly conﬁrm their conjecture by actually showing that
the problem is 2P -hard. Then, we shall show that the corresponding membership result holds for any class of games C (R),
where R is an arbitrary NPopt -representation.
4.1. Hardness for graph games
We show that checking whether an imputation belongs to the kernel is 2P -hard for graph games. The proof is based on
a reduction from the problem of the lexicographically maximum satisfying assignment for Boolean formulae.
Let φ = c 1 ∧ · · · ∧ cm be a 3CNF Boolean formula, that is, a Boolean formula in conjunctive normal form over the set
{α1 , . . . , αn } of variables that are lexicographically ordered (according to their indices), where each clause contains at most
three literals (positive or negated variables). Assume, w.l.o.g., that there is a clause in φ containing at least two literals.
Based on φ , we build in polynomial time the weighted graph K (φ) = ( N K , E K ), w such that (see Fig. 3 for an illustration):

1890

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

• The set N K of nodes (i.e., players) includes: a variable player αi , for each variable αi in φ ; a clause player c j , for each
clause c j in φ ; a literal player i , j (either i , j = αi , j or i , j = ¬αi , j ), for each literal i ( i = αi or i = ¬αi , respectively)
occurring in c j ; and, two special players “chall” and “sat”.

• The set E K consists of the following three types of edges.

(Positive edges): an edge {c j , i , j } with w ({c j , i , j }) = 2n+3 , for each literal i occurring in c j ; an edge {chall, αi } with
w ({chall, αi }) = 2i , for each 1 i n; an edge {sat, αi } with w ({sat, αi }) = 2i , for each 2 i n; the edge
{sat, α1 } with w ({sat, α1 }) = 21 + 20 .
(“Penalty” edges): an edge { i , j , i , j } with w ({ i , j , i , j }) = −2m+n+7 , for each pair of literals i and i occurring in
c j ; an edge {αi , j , ¬αi , j } with w ({αi , j , ¬αi , j }) = −2m+n+7 , for each variable αi occurring positively in c j and
negated in c j ; an edge {αi , ¬αi , j } with w ({αi , ¬αi , j }) = −2m+n+7 , for each variable αi occurring negated
in c j .
(“Normalizer” edge): the edge {chall, sat}, for which we set w ({chall, sat}) = 1 − e∈ E K |e={chall,sat} w (e ).
Note that the size of K (φ) (and in particular of the representation of all the weights) is polynomial in the number of
variables and clauses of φ . Two crucial properties of the above construction are stated in the following lemma, whose proof
is given in Appendix A.
Lemma 4.3. Let K (φ) = ( N K , E K ), w be the graph game associated with the 3CNF formula φ . Then:
(A) w ({chall, sat}) D + 1; and,
(B) D + w (e ) < 0, for each penalty edge e ∈ E K ,
where D = max{chall,sat}

S ⊆N

v ( S ) denotes the maximum worth over all the coalitions not covering the edge {chall, sat}.

Based on the above properties, we can now prove the main result.
Theorem 4.4. On the class C (GG ) of graph games, In-Kernel is

P
2 -hard

(even if the given payoff vector is an imputation).

Proof. Let φ = c 1 ∧ · · · ∧ cm be a satisﬁable 3CNF formula over a set {α1 , . . . , αn } of variables that are lexicographically
ordered (according to their indices). Deciding whether α1 (that is the lexicographically least signiﬁcant variable) is true in
the lexicographically maximum satisfying assignment for φ is a well-known 2P -complete problem [52].
Consider the graph game K (φ) = ( N K , E K ), w , and the imputation x that assigns 0 to all players of K (φ), but for
sat, which receives 1. In fact, x is an imputation since v ( N ) = 1 because of the weight of the edge {chall, sat} (recall that
w ({chall, sat}) = 1 − e∈ E K |e={chall,sat} w (e )).
At ﬁrst, observe that, by Deﬁnition 4.1 and since sat is the only player that receives in x a payoff strictly greater than
her worth as a singleton coalition, x ∈ K ( K (φ)) if and only if max S ∈Ii,sat e ( S , x) max S ∈Isat,i e ( S , x), for each player i = sat.
But we can notice that the following holds (the proof is given in Appendix A):

/ {sat, chall}, it holds that max S ∈Ii,sat e ( S , x)
Property 4.4.(1). For each player i ∈

max S ∈Isat,i e ( S , x).

Hence, Property 4.4.(1) further restricts the coalitions of interest and, indeed, we can conclude that x ∈ K ( K (φ)) if and
only if

max

S ∈Ichall,sat

e ( S , x)

max

S ∈Isat,chall

e ( S , x).

(1)

Now, we are going to characterize the structure of the two terms max S ∈Ichall,sat e ( S , x) and max S ∈Isat,chall e ( S , x) occurring
in Eq. (1) by establishing a connection with satisfying assignments for φ . In particular, for any truth assignment σ , we
denote by σ | φ the fact that σ satisﬁes φ , and by σ (αi ) = true (resp., σ (αi ) = false) the fact that αi evaluates to true
(resp., false) in σ . Then, we can state the following two properties, whose proofs are given in Appendix A.
Property 4.4.(2). max S ∈Ichall,sat e ( S , x) = m × 2n+3 + maxσ | φ αi |σ (αi )=true 2i .
Property 4.4.(3). max S ∈Isat,chall e ( S , x) = m × 2n+3 + maxσ | φ (|{α1 | σ (α1 ) = true}| +

i
αi |σ (αi )=true 2 ) − 1.

We can now rewrite Eq. (1) in the light of the above two properties, and conclude that x ∈ K ( K (φ)) if and only if

2i

1 + max
σ| φ

αi |σ (αi )=true

2i +

max
σ| φ

that is, x ∈ K ( K (φ)) if and only if

α1 σ (α1 ) = true

,

αi |σ (αi )=true

α1 is true in the lexicographically maximum satisfying assignment for φ . ✷

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

1891

Note that the above result can immediately be extended to all representations at least as expressive (and succinct) as
graph games.
Corollary 4.5. Let R be any compact representation such that GG

e

R (e.g., R = MCN ). On the class C (R), In-Kernel is

P
2 -hard.

Proof. From the 2P -hardness for graph games, we know that there is a polynomial-time reduction f 1 from any 2P problem
Υ to the In-Kernel problem for graph games. Moreover, recall from Section 3 that GG e R means that there exists a
polynomial-time function f 2 that translates any graph game ξ GG (G ) into an equivalent game f 2 (ξ GG (G )) belonging to
C (R), that is, into a game with the same worth function and, thus, the same kernel as the former one. Therefore, the
composition of f 1 and f 2 is a polynomial-time reduction from any 2P problem to the In-Kernel problem for games in
C (R). ✷
4.2. Membership results
Next, we show that the In-Kernel problem is in 2P , even when dealing with NPopt -representations. Before presenting
this result, we illustrate some facts of NPopt -representations that will also be used to analyze the other solution concepts.
Lemma 4.6. Let R be any compact representation for coalitional games, let G be a game in C (R) over a set N of players, and let
S ⊆ N be a coalition. Assume that the worth function v R is such that v R (ξ R (G ), S ) = max{ w | w ∈ f R (ξ R (G ), S )}, where f R is
a feasibility function computable in NPMV. Then:
(1) For any value h, checking whether v R (ξ R (G ), S ) > h (i.e., whether there is a value w ∈ f R (ξ R (G ), S ) such that w > h) is in
NP.
(2) Computing the value v R (ξ R (G ), S ) is in F 2P .
Proof. (1) For any value h, v R (ξ R (G ), S ) > h holds if and only if there is a value w ∈ f R (ξ R (G ), S ) such that w > h.
This latter property can be veriﬁed by guessing in NP the value w ∈ f R (ξ R (G ), S ) together with a certiﬁcate c that
(ξ R (G ), S ), w ∈ graph( f R ). Then, we can check in (deterministic) polynomial time that w > h and, by exploiting c, that
(ξ R (G ), S ), w belongs to the graph of the function f R .
(2) The value v R (ξ R (G ), S ) can be computed by performing a binary search over the range of the possible values for
the worth function by using an oracle, which checks whether, for any given value h in this range, v R (ξ R (G ), S ) > h holds.
Since f R is computable in NPMV, the size of v R ( S ) is polynomially bounded and, thus, the binary search converges in at
most polynomially many steps. Finally, by point (1) above, note that the oracle belongs to NP. ✷
Theorem 4.7. Let R be any NPopt -representation. On the class C (R), In-Kernel is in

P
2.

Proof. Let G ∈ C (R) be a coalitional game, and x a payoff vector. Recall from Deﬁnition 3.3 that for each coalition S ⊆ N,
v R (ξ R (G ), S ) = max{ w | w ∈ f R (ξ R (G ), S )} holds, where f R is a feasibility function computable in NPMV.
Note that, in order to check whether x is actually an imputation, we have to compute the worths associated to all the
singleton coalitions plus the worth associated to the whole set of players. This is in F 2P , by Lemma 4.6(2).
Assume now that x is an imputation. For all pairs of distinct players i and j with v ( j ) > x j , we have to check that
si , j (x) = s j ,i (x). Observe here that we can compute the value si , j (x) by means of a binary search over the range of the
possible values for the worth functions by using an oracle that, for any value h in this range, decides whether there is a
coalition S ∈ Ii , j such that e ( S , x) > h. Since the size of v R ( S ) is polynomially bounded, the above binary search allows us
to ﬁnd the maximum excess in at most polynomially many steps. To complete the proof we need to show that deciding
e ( S , x) > h is in NP for any given value h in this range. To this end, recall that e ( S , x) = v R ( S ) − x( S ). Thus, e ( S , x) > h holds
if and only if there is a feasible value w ∈ f R (ξ R (G ), S ) such that w > h + x( S ). Based on this characterization, the check
is easily seen to be in NP by Lemma 4.6(1). By this, the surplus computation is in F 2P . Thus, checking si , j (x) = s j ,i (x) for
all pairs of distinct players is in 2P . ✷
From the above result and Corollary 4.5, we immediately get the following completeness result.
Corollary 4.8. Let R be any NPopt -representation such that GG
P
2 -complete.

e

R (e.g., R = MCN ). On the class C (R), In-Kernel is

5. The complexity of the bargaining set
The concept of bargaining set was deﬁned by Aumann and Maschler [3] (see also Maschler [55]). We start by recalling
its formal deﬁnition.

1892

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

Let G = N , v be a coalitional game, and x ∈ X (G ) an imputation. Let S ⊆ N be a coalition, and y an S-feasible payoff
/ S, and yk > xk for all k ∈ S.
vector (i.e., y ( S ) = v ( S )). The pair ( y , S ) is an objection of player i against player j to x if i ∈ S, j ∈
/ T , and z is a T -feasible payoff
A counterobjection to the objection ( y , S ) of i against j to x is a pair ( z, T ) where j ∈ T , i ∈
yk for all k ∈ T ∩ S. If there does not exist any counterobjection to ( y , S ),
vector such that zk xk for all k ∈ T \ S and zk
we say that ( y , S ) is a justiﬁed objection.
Deﬁnition 5.1. The bargaining set B(G ) of a TU game G is the set of all imputations x to which there is no justiﬁed objection.
Example 5.2. Let G = N , v be the TU game already illustrated in Example 4.2, that is, N = {a, b, c }, v ({a}) = v ({b}) =
v ({c }) = 0, v ({a, b}) = 20, v ({a, c }) = 30, v ({b, c }) = 40, and v ({a, b, c }) = 42.
Consider the imputation x such that xa = 8, xb = 10, and xc = 24. An objection of player c against player a to x is
((12, 28), {b, c }). Player a can counterobject to this objection using ((8, 12), {a, b}). Another objection of player c against
player a to x is ((14, 26), {b, c }). In this case, player a cannot counterobject. The reason is that coalition {a, b} receives a
payoff 20 and this is not suﬃcient for player a to counterobject since she needs at least 8 for herself and at least 14 for
player b, in order to respond to the proposal of player c. Therefore the imputation x does not belong to B(G ). The intuitive
reason is that player a receives too much, according to this proﬁle.
Consider now the imputation x such that xa = 4, xb = 14, and xc = 24. We focus on the objections of player a against
player c. We note that, in order to object, player a has to form the coalition S = {a, b}. The excess e ( S , x) of S at x is 2,
hence players a and b have the possibility to distribute among themselves a payoff of 2 to make the objection. But player c
can always counterobject to player a because she can form the coalition T = {b, c } whose excess at x is 2 and hence she can
always match the proposal made to player b by player a in order to object. A similar argument holds for every objection of
every player against any other. Thus x ∈ B(G ).
It is well-known that K (G ) ⊆ B(G ) (hence, B(G ) = ∅, whenever X (G ) = ∅), and that C (G ) ⊆ B(G ) (see, e.g., [62]).
Thus, as in the case of the kernel, we shall just focus on the complexity of deciding whether a given payoff vector is in
the bargaining set. The problem was conjectured to be 2P -complete for graph games by Deng and Papadimitriou [26].
In this section, we show that the conjecture is indeed correct. Also, we are able to generalize the result by showing that
membership in 2P holds for any class of games C (R), where R is an NPopt -representation scheme.
5.1. Hardness for graph games
It was suggested by Maschler [55] that computing the bargaining set might be intrinsically more complex than computing
the core. The result presented in this section provides some fresh evidence that this is indeed the case for we shall show
that checking whether a payoff vector is in the bargaining set is 2P -hard, even over graph games. The reduction is from
the validity of quantiﬁed Boolean formulae.
Let Φ = (∀α )(∃β)φ(α , β) be an NQBF2,∀ formula, i.e., a quantiﬁed Boolean formula over the variables α = {α1 , . . . , αn }
and β = {β1 , . . . , βr }, where φ(α , β) = c 1 ∧ · · · ∧ cm is a 3CNF formula, and where each universally quantiﬁed variable αk ∈ α
occurs only in the two clauses c i (k) = (αk ∨ ¬βk ) and c¯i (k) = (¬αk ∨ βk )—intuitively, each variable αk enforces the truth value
of a corresponding variable βk , which thus plays its role in the formula φ(α , β). Based on Φ , we deﬁne the weighted graph
BS (Φ) = ( N BS , E BS ), w such that (see Fig. 4 for a graphical illustration):

• The set N BS of the nodes (i.e., players) includes: a clause player c j , for each clause c j ; a literal player

i, j ,

for each literal

occurring in c j ; and, two special players “chall” and “sat”.
• The set E BS of edges includes three kinds of edges.
i

(Positive edges): an edge {c j , i , j } with w ({c j , i , j }) = 1, for each literal i occurring in the clause c j ; an edge
{chall, i , j } with w ({chall, i , j }) = 1, for each literal i of the form αi or ¬αi (i.e., built over a universally
quantiﬁed variable) occurring in c j .
(“Penalty” edges): an edge {γi , j , ¬γi , j } with w ({γi , j , ¬γi , j }) = −m − 1, for each variable γi (either γi = αi or γi = βi )
occurring in c j and c j ; an edge { i , j , i , j } with w ( i , j , i , j ) = −m − 1, for each pair of literals i and i
occurring in c j ; an edge {chall, i , j } with w ({chall, i , j }) = −m − 1, for each literal i of the form βi or ¬βi (i.e.,
built over an existentially quantiﬁed variable) occurring in c j ; an edge {chall, c j } with w ({chall, c j }) = −m − 1,
for each clause c j .
(“Normalizer” edge): the edge {chall, sat} with w ({chall, sat}) = n − 1 + m − e∈ E BS |e={chall,sat} w (e ).
Note that the size of BS (Φ) (and in particular of the representation of all the weights) is polynomial in the number
of variables and clauses of Φ . Moreover, the properties summarized in the following lemma hold, whose proof is given in
Appendix B.
Lemma 5.3. Let BS(Φ) = ( N BS , E BS ), w be the graph game associated with the NQBF2,∀ formula Φ . Then:
(A) D

m;

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

Fig. 4. The game BS(Φ), where

1893

= (∀α1 )(∃β1 , β2 , β3 )(α1 ∨ ¬β1 ) ∧ (¬α1 ∨ β1 ) ∧ (β1 ∨ β2 ∨ ¬β3 ).

(B) w ({chall, sat}) > 2 × m;
(C) D + w (e ) < 0, for each penalty edge e ∈ E BS ; and,
(D) m 2 × n,
where D = max{chall,sat}

S ⊆N

v ( S ) denotes the maximum worth over all the coalitions not covering the edge {chall, sat}.

Based on the above properties, we can now prove the following result.
Theorem 5.4. On the class C (GG ) of graph games, In-BargainingSet is

P
2 -hard

(even if the given payoff vector is an imputation).

Proof. Deciding the validity of NQBF2,∀ formulae is 2P -complete [72]. Thus, given an NQBF2,∀ formula Φ = (∀α )(∃β)φ(α , β)
(where α = {α1 , . . . , αn }, β = {β1 , . . . , βr }, and φ(α , β) = c 1 ∧ · · · ∧ cm ), consider the graph game BS (Φ) = ( N BS , E BS ), w and
the imputation x that assigns m to sat, n − 1 to chall, and 0 to all other players. Note that x is an imputation, since v ( N ) =
m + n − 1 because of the weight of the edge {chall, sat} (recall that w ({chall, sat}) = m + n − 1 − e∈ E BS |e={chall,sat} w (e )).
Beforehand, we note that the following properties hold on BS(Φ) and x. The proofs of these properties are given in
Appendix B.
Property 5.4.(1). No player has a justiﬁed objection against a clause or a literal player.
Property 5.4.(2). No player has a justiﬁed objection against chall.
Property 5.4.(3). No player different from chall has a justiﬁed objection against sat.
In the light of the properties above, we can limit our attention to the objections of chall against sat. Consider an objection

( y , S ) of chall against sat to x. In particular, y chall must be greater than xchall = n − 1 and yq > 0 = xq for each q ∈ S with
q = chall. Thus, y ( S ) = v ( S ) > n − 1.
Then, because of Lemma 5.3(C), in order for such a coalition S to be such that v ( S ) > n − 1, no penalty edge must be
covered by S. Moreover, given that chall ∈ S, we have that S must contain exactly one player per universally quantiﬁed
variable so that v ( S ) = n > n − 1, i.e., | S | = n + 1 and | S ∩ {αk,i (k) , ¬αk,¯i (k) }| = 1, for each 1 k n. By this, the objection
y has to be a vector such that y ( S ) = n, y chall > n − 1, and y q > 0, for each q ∈ S with q = chall. Note that the coalition
S encodes an assignment

σ S for the variables in α such that αk evaluates to false (resp., true) in σ S if αk,i(k) (resp.,

¬αk,¯i (k) ) occurs in S—note that, in this correspondence, the truth values are inverted with respect to the membership of the

corresponding literal players in S.
Moreover, note that for each truth assignment σ for the variables in α , we may immediately build a coalition S and a
vector y such that ( y , S ) is an objection of chall against sat, and σ S = σ . Therefore, objections of chall against sat are in
correspondence with truth assignments for universally quantiﬁed variables.
We are now ready to show that Φ is valid if and only if x is in B(BS (Φ)):

1894

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

(⇒) Assume that Φ = (∀α )(∃β)φ(α , β) is valid, and let ( y , S ) be any objection of chall against sat to x. We show that
this objection is not justiﬁed, because sat has a counterobjection ( z, T ). Recall ﬁrst that S encodes an assignment σ S
over the variables in α . Then, let σ be a satisfying assignment over the variables in Φ such that αk evaluates to
true in σ if and only if it evaluates to true in σ S ; indeed, such a satisfying assignment σ exists since Φ is valid.
Based on σ , let us construct the coalition T such that T ⊆ {sat } ∪ { i , j | i evaluates to true in σ ∧ c j is a clause
where i occurs} ∪ {c 1 , . . . , cm }, T ∩ S = ∅, | T | = 2m + 1, and v ( T ) = m. In particular, T can be such that v ( T ) = m,
precisely because σ is a satisfying assignment and by construction of σ S . Moreover, consider the vector z such that
zsat = v ( T ) = xsat = m and zq = xq = 0 for each q ∈ T with q = sat (and, hence, q ∈
/ S). By construction (z, T ) is a
counterobjection to ( y , S ), which is therefore not justiﬁed in its turn.
(⇐) Let σ be an assignment over the variables in α witnessing that Φ is not valid. Let ( y , S ) be an arbitrary objection of
chall against sat to x such that σ S = σ . We claim that ( y , S ) is justiﬁed. Indeed, assume for the sake of contradiction
that ( y , S ) is not justiﬁed and let ( z, T ) be a counterobjection. Since sat ∈ T \ S and since we must have zsat xsat = m,
because of Lemma 5.3(A) we actually have that zsat = xsat . In fact, since m is the maximum available payoff over all
the coalitions not including both chall and sat, z( T ) = v ( T ) = m and the fact that ( z, T ) is a counterobjection to ( y , S )
together entail that S ∩ T = ∅. Also, these entail that T contains all clause players, exactly one literal player per clause,
so that | T | = 2m + 1. Observe now that T encodes a satisfying truth value assignment σ T for φ(α , β), because v ( T ) > 0
and hence T does not cover any penalty edge. More precisely, we let each variable γi (either γi = αi or γi = βi ) to
evaluate true (resp., false) in σ T if γi , j (resp., ¬γi , j ) occurs in T , for some clause c j . Let σ Tα denote the restriction of
σT over the variables in α . Then, since S ∩ T = ∅ and given the deﬁnition of σ S , we have that σ S = σTα . Clearly, this
contradicts the fact that σ = σ S witnesses that Φ is not valid. ✷
Again, by the same argument used for the proof of Corollary 4.5, the above result extends to compact representations
more expressive than graph games.
Corollary 5.5. Let R be any NPopt -representation such that GG
P
2 -hard.

e

R (e.g., R = MCN ). On the class C (R), In-BargainingSet is

5.2. Membership results
Checking whether a payoff vector belongs to the bargaining set has already been argued by Deng and Papadimitriou [26]
to be in 2P for graph games. Indeed, they observed that one may decide that an imputation x is not in the bargaining
set by ﬁrstly guessing in NP the objection ( y , S ), and then by calling a co-NP oracle, by which to check that there is
no counterobjection ( z, T ) to ( y , S ). However, to apply this argument one typically assumes real values to have a ﬁxedprecision. In fact, Greco et al. [39] recently proved that there always exist suitable objections and counterobjections that
may be guessed in polynomial time, so that In-BargainingSet was formally proved to be in 2P . In particular, it was shown
that the problem remains in 2P , for any arbitrary worth function that can be computed in polynomial time (thus, for classes
of games based on a P-representation scheme) and for certain kinds of worth functions computable in non-deterministic
polynomial time. Our main achievement in this section is to show that membership in 2P (surprisingly) holds on any
arbitrary NPopt -representation. To this end, we need to devise some novel technical machinery.
First, we shall provide a useful characterization of a player i having a justiﬁed objection against some player j. The result
is in the spirit of one of Maschler’s [54] and connects the existence of a justiﬁed objection of i against j to some algebraic
conditions to hold on coalitions that i and j (may) belong to.
Lemma 5.6. Let G be a coalitional game, and let x be an imputation of G . Then, player i has a justiﬁed objection against player j to x
through a coalition S ∈ Ii , j if and only if there exists a vector y ∈ R S such that:
(1) y ( S ) = v ( S );
(2) yk > xk , for each k ∈ S; and,
(3) v ( T ) < y ( T ∩ S ) + x( T \ S ), for each T ∈ I j ,i .
Proof. (⇒) Assume that player i has a justiﬁed objection against player j to x through a coalition S ∈ Ii , j . Let ( y , S ) be
such justiﬁed objection and note that, by deﬁnition, y ( S ) = v ( S ) and yk > xk for each k ∈ S hold. Assume now, for the sake
of contradiction, that (3) above does not hold. Let T¯ ∈ I j ,i be such that v ( T¯ ) y ( T¯ ∩ S ) + x( T¯ \ S ). Based on T¯ , we can build
¯

a vector z ∈ R T such that: (i) zk = xk + δ for each k ∈ T¯ \ S; and, (ii) zk = yk + δ for each k ∈ T¯ ∩ S, where

δ=

v ( T¯ ) − y ( T¯ ∩ S ) − x( T¯ \ S )

| T¯ |

0.

Note that z( T¯ ) = v ( T¯ ) holds by construction. Hence, ( z, T¯ ) is a counterobjection to ( y , S ), a contradiction.
(⇐) Assume that there is a vector y ∈ R S such that all the three conditions above hold. Consider the pair ( y , S ) (with
S ∈ Ii , j ) and note that due to (1) and (2), ( y , S ) is in fact an objection of player i against player j. We now claim that

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

1895

( y , S ) is justiﬁed. Indeed assume, for the sake of contradiction, that a counterobjection (z, T¯ ) (with T¯ ∈ I j ,i ) exists such
xk for each k ∈ T¯ \ S, and zk
yk for each k ∈ T¯ ∩ S. In this case, it holds that v ( T¯ ) = z( T¯ )
that: z( T¯ ) = v ( T¯ ), zk
y ( T ∩ S ) + x( T \ S ), which contradicts (3). ✷
Second, we need to recall the following beautiful result on families of convex sets. Remember that a set of points S ⊆ Rn
is said convex if, for every pair of points p , q ∈ S, (each point in) the straight line connecting p and q belongs to S as well.
Proposition 5.7 (Helly’s Theorem [43,69]). Let C = {c 1 , . . . , cm } be a ﬁnite family of convex sets in Rn , where m > n. If
there is a family C ⊆ C , such that |C | = n + 1 and c i ∈C c i = ∅.

m
i =1 c i

= ∅,

With the above two ingredients, we can now prove our main result about the bargaining set:
Theorem 5.8. Let R be any NPopt -representation. On the class C (R), In-BargainingSet is in

P
2.

Proof. Let G ∈ C (R) be a coalitional game, and x a payoff vector. Checking whether x is an imputation is in 2P (see the
proof of Theorem 4.7).
/ B(G ). We are
Assume now that x is an imputation, and consider the complementary problem of deciding whether x ∈
going to show that this is in 2P . In the light of Lemma 5.6, x ∈
/ B(G ) if and only if there exist two players i and j, and a
coalition S ∈ Ii , j such that the following set is non-empty:

y ( S ) = v R ξ R (G ), S ∧

W (i , j , S ) = y ∈ R S

yk > xk , ∀k ∈ S ∧
v R ξ R (G ), T < y ( T ∩ S ) + x( T \ S ), ∀ T ∈ I j ,i
Recall from Deﬁnition 3.3 that v R (ξ R (G ), S ) = max{ w | w ∈ f R (ξ R (G ), S )}, where f R is a feasibility function computable in NPMV. Thus, we can solve the problem by ﬁrst guessing in NP two players i and j, a coalition S ∈ Ii , j ,
a value w S , and a certiﬁcate c S that (ξ R (G ), S ), w S ∈ graph( f R ). Note that, by exploiting c S , we can then check
in (deterministic) polynomial time that (ξ R (G ), S ), w S belongs to the graph of the function f R , and thus that
v R (ξ R (G ), S )
w S . After this ﬁrst phase, we have then to check that (i) v R (ξ R (G ), S )
w S , and that (ii) W (i , j , S )
is non-empty. To complete the proof, it suﬃces to show that both checks are in co-NP.
Indeed, concerning (i), the complementary problem of checking that v R (ξ R (G ), S ) > w S is in NP by Lemma 4.6(1).
Concerning (ii), consider the complementary problem of checking the emptiness of W (i , j , S ), which can be equivalently
described by the following inequalities:

y ( S ) = v R ξ R (G ), S = w S ∧

W (i , j , S ) = y ∈ R S

yk > xk , ∀k ∈ S ∧
w T < y ( T ∩ S ) + x( T \ S ), ∀ T ∈ I j ,i , ∀ w T ∈ f R ξ R (G ), T
Observe now that W (i , j , S ) is deﬁned by the intersection of a ﬁnite number of convex regions of R S , which are associated to the various (in)equalities. Hence, by Helly’s Theorem, if W (i , j , S ) is empty, then there exists a subsystem of
(at most) | S | + 1 inequalities that does not admit a solution. Note that we can always add to this subsystem the equality
y ( S ) = w S plus the | S | inequalities of the form yk > xk (for each k ∈ S), as they can be built in polynomial time. Possible
remaining inequalities associated with any coalition T ∈ I j ,i can instead be obtained in non-deterministic polynomial time.
Indeed, we can guess in NP m | S | + 1 coalitions T 1 , . . . , T m from I j ,i and, for each h ∈ {1, . . . , m}, a value w T h and a certiﬁcate c T h that w T h ∈ f R (ξ R (G ), T h ). Then, we can check in polynomial time via c T h that w T h is actually a value returned
by f R (ξ R (G ), T h ). Thus, after these steps in NP, checking whether W (i , j , S ) is empty is reduced to checking whether
a system of polynomially-many linear (in)equalities admits a solution. This latter task is in polynomial time, by standard
arguments in linear programming (see, e.g., [65]). ✷
From the above theorem and Corollary 5.5, we get the following completeness result.
Corollary 5.9. Let R be any NPopt -representation such that GG
P
2 -complete.

e

R (e.g., R = MCN ). On the class C (R), In-BargainingSet is

6. The complexity of the core
The concept of the core goes back to the work by Edgeworth [27] and it was formalized by Gillies [36].

1896

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

Let G = N , v be a coalitional game, and let x be an imputation taken from the set X (G ) of all imputations of G . The
pair ( y , S ) is an objection to x if y is an S-feasible payoff vector such that yk > xk for all k ∈ S—in this case, the coalition S
is also said to block x via y.
Deﬁnition 6.1. The core C (G ) of a coalitional game G = N , v is the set of all imputations x to which there is no objection;
that is,

C (G ) = x ∈ X (G )

S ⊆ N and y ∈ R S such that y ( S ) = v ( S ) and yk > xk , ∀k ∈ S

Thus, an imputation x in the core is “stable” precisely because there is no coalition whose members will receive a higher
payoff than in x by leaving the grand coalition, i.e., the set of all players in the game.
It is easily seen that Deﬁnition 6.1 can be equivalently restated as the set of all solutions satisfying the following inequalities (see, e.g., [62]):

xi

v ( S ),

xi

v (N )

∀S ⊆ N, S = ∅

(2)

i∈ S

(3)

i∈N

In particular, the last inequality, combined with its opposite in (2), enforces the eﬃciency of solutions; moreover, inequalities in (2) over singleton coalitions enforce their individual rationality.
Example 6.2. Let G = N , v be the TU game already illustrated in Example 4.2, that is, N = {a, b, c }, v ({a}) = v ({b}) =
v ({c }) = 0, v ({a, b}) = 20, v ({a, c }) = 30, v ({b, c }) = 40, and v ({a, b, c }) = 42. Consider the imputation x such that: xa = 4,
xb = 14, and xc = 24. Since v ({b, c }) = 40 > 38 = x({b, c }), x ∈
/ C (G ).
In fact, we can show that C (G ) is empty. To this end, consider coalitions S 1 = {a, b}, S 2 = {a, c } and S 3 = {b, c } and
the worths associated with them by the worth function. To be in C (G ), an imputation x has to satisfy the following three
conditions:

xa + xb

20

xa + xc

30

xb + xc

40

Summing up these inequalities we obtain that 2xa + 2xb + 2xc 90, implying that xa + xb + xc 45. Thus, the core of G is
empty because the grand coalition would need as much worth as 45 in order to satisfy the claims of S 1 , S 2 and S 3 , while
the total available worth is just v ( N ) = 42.
Consider, instead, the game G = N , v whose worth function v is the same as that of G except for the grand coalition
for which v ( N ) = 45. Then, it is easily checked that the imputation x such that xa = 5, xb = 15, and xc = 25 is in C (G ).
In the rest of this section, we shall analyze the complexity of the core and, in particular, of the problems In-Core and
Core-NonEmptiness.
6.1. Complexity of In-Core
Recall from the Introduction that the In-Core problem consists in deciding whether, given a game G and a payoff
vector x, it is the case that x belongs to C (G ). In the setting of graph games, the problem has been proven to be co-NPhard [26]. By the same argument used for the proof of Corollary 4.5, we easily obtain the following.
Proposition 6.3. Let R be any compact representation such that GG
hard.

e

R (e.g., R = MCN ). On the class C (R), In-Core is co-NP-

Moreover, a hardness result for the class D P can be obtained in the case where NPopt -representations are considered.
Note that, in the result below, we do not reveal the hardness of any speciﬁc NPopt representation proposed in the literature,
since such analysis is outside the scope of the paper. Rather, we show that hardness for D P can emerge under the conditions
in Deﬁnition 3.3. The proof is routine, and it is reported for the sake of completeness only.
Proposition 6.4. There exists an NPopt -representation R such that, on the class C (R), In-Core is D P -hard.

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

1897

Proof. Let G = ( N , E ) be a graph. For a given value k, deciding whether the size of the maximum clique over the nodes of
G equals k is a D P -complete problem [66]. Consider the worth function v such that v ( S ) = 0, for each S ⊂ N, and where
v ( N ) is the size of the maximum clique in G. Note that the function satisﬁes the condition in Deﬁnition 3.3. Now, consider
a payoff vector x such that xi = k/| N |, for each i ∈ N. It is immediate to check that x belongs to C (G ) (in fact, that x is an
imputation) if and only if the size of the maximum clique equals k. ✷
We conclude the analysis of In-Core by showing that the lower bounds in the above two propositions are tight. In fact,
Greco et al. [39] recently showed that this problem is in co-NP for any arbitrary worth function that can be computed in
polynomial time (thus, for classes of games based on a P-representation scheme) and for certain kinds of worth functions
computable in non-deterministic polynomial time. We next generalize this result, by showing that In-Core is in co-NP over
those NPopt -representations where the worth associated with the set of all players is explicitly given as an input or can be
computed in polynomial time (i.e., over wNPopt -representations), while it is in D P over arbitrary NPopt -representations.
Theorem 6.5. Let R be any compact representation. On the class C (R), In-Core is
(1) in co-NP, if R is a wNPopt -representation; and,
(2) in D P , if R is an NPopt -representation.
Proof. Let R be any compact representation. Let G be a game in C (R), over the set N of players. Let x be a given payoff
vector, and recall that the problem In-Core is to check whether x belongs to C (G ). Consider the complementary problem
/ C (G ) holds, i.e., whether (i) i ∈ N xi = v R ( N ) or (ii) there is a coalition S ⊂ N such that i ∈ S xi <
of deciding whether x ∈
v R ( S ). We shall show that conditions (i) and (ii) can be checked in NP with P-representations and wNPopt -representations,
and that they can be checked in co-D P with NPopt -representations.
(1) In the case where R is a wNPopt -representation, (i) is checkable in polynomial time, since v R ( N ) is in polynomial time. We next show that (ii) can be checked in NP. Recall from Deﬁnition 3.5 that v R (ξ R (G ), S ) = max{ w | w ∈
R
f R (ξ R (G ), S )}, where f R is a feasibility function computable in NPMV. Therefore, for any coalition S,
i ∈ S xi < v ( S )
R
R
holds if and only if there is a value w ∈ f (ξ (G ), S ) such that
i ∈ S xi < w. We now claim that the existence of a coaliR is computable in NPMV,
tion S and a value w ∈ f R (ξ R (G ), S ) with
i ∈ S xi < w can be checked in NP. Indeed, since f
we can guess in NP not only the coalition S, but also the value w and a certiﬁcate c that (ξ R (G ), S ), w ∈ graph( f R ).
By exploiting c, we can then check in (deterministic) polynomial time that (ξ R (G ), S ), w belongs to the graph of the
function f R , i.e., that w ∈ f R (ξ R (G ), S ) actually holds. Finally, we can check that
i ∈ S xi < w holds.
(2) NPopt -representations generalize wNPopt -representations just in that the worth associated with the whole set N of
players is not given in the input, but rather is of the form v R (ξ R (G ), N ) = max{ w | w ∈ f R (ξ R (G ), N )}. Thus, from the
proof of (1) above, we already know that condition (ii) can be checked in NP, even if R is an NPopt -representation. Consider
R
now condition (i) and notice that
i ∈ N xi = v ( N ) if and only if at least one of the two following conditions holds: (i ) there
∗
R (ξ R (G ), N )
is no feasible value w ∈ f R (ξ R (G ), N ) such that
i ∈ N xi = w; (i ) there actually is a feasible value w ∈ f
such that w ∗ > i ∈ N xi . From Lemma 4.6(1), we know that (i ) is in NP. We now claim that (i ) is in co-NP. Indeed, we
can solve the complementary problem of checking whether there actually is a feasible value w ∈ f R (ξ R (G ), N ) such that
i ∈ N xi = w by guessing in NP the value w together with a certiﬁcate c, and then checking in polynomial time, by using c,
that (ξ R (G ), N ), w belongs to the graph of the worth function f R , and eventually that
i ∈ N xi = w holds. By putting it
all together, x ∈
/ C (G ) holds if and only if (i ) or (i ) or (ii) holds. Deciding whether (i ) or (ii) holds is in NP (just notice that
the problem is the disjunction of two problems in NP), while deciding whether (i ) holds is in co-NP. Thus, the complement
of In-Core is in co-D P . ✷
As for the kernel and the bargaining set, we therefore immediately get the following result.
Corollary 6.6. Let R be any wNPopt -representation such that GG
co-NP-complete.

e

R (e.g., R = MCN ). On the class C (R), In-Core is

6.2. Complexity of Core-NonEmptiness
Recall from Example 6.2 that the core of a game can be empty, even if its set of imputations is not. Therefore, it makes
sense to analyze the complexity of the Core-NonEmptiness problem of deciding whether, given a game G , C (G ) = ∅. This
problem is known to be co-NP-hard for graph games [26]. Thus, by following exactly the same line of reasoning as in the
proof of Corollary 4.5, the following can be established.
Proposition 6.7. Let R be any compact representation such that GG
NonEmptiness is co-NP-hard.

e

R (e.g., R = MCN ). On the class C (R), Core-

1898

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

In fact, for the case of graph games, the precise complexity of the non-emptiness problem for the core is known, as
Deng and Papadimitriou [26] have shown that this problem is co-NP-complete. However, it was left open whether the
membership still holds for marginal contribution networks [44] and, possibly, for more general compact representations.
In this section, we positively answer this question and show that membership in co-NP generally holds over wNPopt representations.
In order to get this result, we have to identify some succinct certiﬁcate that the core of a game is empty. Indeed, it was
observed that the “obvious” certiﬁcate of non-emptiness of the core is exponential in size [44]. Our crucial observation is
that the technical machinery that we need is Helly’s Theorem, which we have already used while analyzing the complexity
of the bargaining set. By exploiting Helly’s Theorem and the characterization of the core based on the linear inequalities in
(2) and (3), we can indeed show the following.
Theorem 6.8. Let R be any compact representation. On the class C (R), Core-NonEmptiness is
(1) in co-NP, if R is a wNPopt -representation; and,
(2) in 2P , if R is an NPopt -representation.
Proof. Let R be any compact representation, and let G be a game in C (R), over the set N of players. Recall that CoreNonEmptiness is the problem of deciding whether C (G ) is not empty, and consider the complementary problem of checking
whether C (G ) is empty. We shall show that this latter problem is in NP for wNPopt -representations, and that it is in 2P
for arbitrary NPopt -representations (recall, here, that 2P is closed under complement).
Let w ∈ R be any real number. For each coalition S ⊂ N, let ϕ S , w denote the convex set {x ∈ R N | x( S ) w }; and (for
S = N) let ϕ N , w denote the convex set {x ∈ R N | x( N ) = w }. By the characterization of the core in terms of the inequalities
(2) and (3), we have that C (G ) = ∅= S ⊆ N ϕ S , v R ( S ) .

(1) Recall ﬁrst that, in any wNPopt -representation R, for each coalition S ⊂ N, v R (ξ R (G ), S ) = max{ w | w ∈
f R (ξ R (G ), S )} holds, where f R is a feasibility function computable in NPMV. Let ( S , w ) be a pair formed by a coalition S and a value w. The pair ( S , w ) is valid if either S ⊂ N and w ∈ f R (ξ R (G ), S ), or S = N and w = v R ( N ). Let VP
be the set of all valid pairs. Note that ϕ S , w ⊇ ϕ S , v R ( S ) . Then, C (G ) = ( S , w )∈VP ϕ S , w . If C (G ) is empty then, by Helly’s
Theorem, there exists a family E ⊆ VP of | N | + 1 valid pairs (one-to-one associated with the above convex sets) such that
( S , w )∈E ϕ S , w = ∅.
In order to complete the proof, we now claim that this latter condition can be checked in NP. To this end, observe that
the system of the | N | + 1 linear inequalities deﬁning the convex sets associated with E can be built in polynomial time.
Indeed, we can guess in NP the set E together with a suitable certiﬁcate c S , w , for each ( S , w ) ∈ E . Then, for each ( S , w ) ∈ E
such that S ⊂ N, we can use the certiﬁcate c S , w to actually check in polynomial time that w ∈ f R (ξ R (G ), S ), and hence
to build the corresponding linear equality deﬁning the convex set ϕ S , w ; for each ( S , w ) ∈ E such that S = N, we check in
polynomial time that w = v R ( N ) and we build the corresponding linear equality. Finally, we check in polynomial time that
this system of (in)equalities has no solutions by standard techniques of linear programming.
(2) In the case where R is an NPopt -representation, we can apply the same line of reasoning as before, by just taking
into account the additional complexity for computing v R ( N ), which now may be a harder task. From Lemma 4.6(2), we
know that this task is in F 2P . The statement then follows, since the remaining computation is in co-NP by (1) above (and
since co-NP is contained in 2P ). ✷

The membership result (1) above and Proposition 6.7 imply that the non-emptiness problem for the core is
co-NP-complete for all P-representations and all wNPopt -representations at least as expressive as graph games. Therefore, we can now state the precise complexity of Core-NonEmptiness even over marginal contribution networks, which was
left open by Ieong and Shoham [44].
Corollary 6.9. Let R be any wNPopt -representation such that GG
is co-NP-complete.

e

R (e.g., R = MCN ). On the class C (R), Core-NonEmptiness

For the sake of completeness, note that the membership result in Theorem 6.8(2) can be tight in some cases, i.e., there
exist NPopt -representations over which Core-NonEmptiness is 2P -hard. In fact, this is a trivial observation since worth
functions satisfying Deﬁnition 3.3 can encode 2P -complete problems.5 However, it tells us nothing about the hardness of
speciﬁc NPopt representations proposed in the literature. And, in fact, analyzing such representations to check whether they
are any easier than the general case appears to be an interesting avenue of further research.

5
Indeed, they have the power of OptP functions (see the note on p. 1886), and it is known that every function in
followed by a polynomial-time calculation [52].

P
2

decomposes into an OptP function,

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

1899

6.3. A closer look at Helly’s Theorem
As we have seen, Helly’s Theorem guarantees the existence of “small” infeasibility certiﬁcates for problems based on
families of convex subsets. Actually, our historically ﬁrst proof of the computational complexity of core non-emptiness [53]
was based on a different approach that exploited the fact that the core of any coalitional game is a Polyhedron of Rn . We
believe that this proof may be of independent interest for the reader and thus we describe it in the rest of this section.
Indeed, it provides a nice geometrical and constructive view of “small” emptiness certiﬁcates for polyhedra, and thus a
geometrical interpretation of Helly’s Theorem, for those contexts where convex sets are given by linear inequalities like
those involved in the core non-emptiness problem.6
6.3.1. Preliminaries on polyhedral sets
We begin by giving some useful deﬁnitions and facts about polyhedral sets. We refer the interested reader to textbooks
on the subject for further reading (see, e.g., [42,14]).
Let n > 0 be any natural number. A Polyhedral Set (or Polyhedron) P of Rn is the intersection of a ﬁnite set S of closed
halfspaces of Rn . Note that in this paper we always assume, unless otherwise stated, that n > 0. We denote this polyhedron
by Pol(S ).
Recall that a hyperplane H of Rn is a set of points {x ∈ Rn | a T x = b}, where a ∈ Rn and b ∈ R. The closed halfspace H +
is the set of points {x ∈ Rn | a T x b}. We say that these points satisfy H + . We denote the points that do not satisfy this
halfspace by H − , i.e., H − = Rn \ H + = {x ∈ Rn | a T x < b}. Note that H − is an open halfspace. We say that H determines H +
¯ + = {x ∈ Rn | a T x b }, where a = −1 · a and b = −1 · b. Note
and H − . Deﬁne the opposite of H + as the set of points H
¯ + = H − ∪ H , since it is the set of points {x ∈ Rn | a T x b}.
that H
Let P = Pol(S ) be a polyhedron and H a hyperplane. We say that H cuts P if both H + and H − contain points of P , and
we say that H passes through P , if there is a non-empty touching set C = H ∩ P . Furthermore, we say that H supports P , or
that it is a supporting hyperplane for P , if H does not cut P , but passes through P , i.e., it just touches P (in the set C ).
Moreover, we say that H + is a supporting halfspace for P if H is a supporting hyperplane for P and P ⊆ H + . Note that
P ⊆ Pol(S ) for any set of halfspaces S ⊆ S , since the latter polyhedron is obtained from the intersection of a smaller set
of halfspaces than P . We say that such a polyhedron is a supporting polyhedron for P .
Recall that, for any set A ⊆ Rn , its dimension dim( A ) is the dimension of its aﬃne hull. For instance, if A consists of two
points, or it is a segment, its aﬃne hull is a line and thus dim( A ) = 1. By deﬁnition, dim(∅) = −1, while single points have
dimension 0. For any hyperplane H , dim( H ) = n − 1, while the intersection C of any pair of (non-parallel) hyperplanes H 1
and H 2 has dimension n − 2.
Every hyperplane H has precisely two normal vectors, while its associated halfspace H + has one normal vector, that
is, the normal vector of H that belongs to H + . The dihedral angle δ( H 1+ , H 2+ ) between two non-parallel halfspaces H 1+
and H 2+ is the smallest angle between the corresponding normal vectors. For such halfspaces, in this paper we always
consider rotations whose axis is the (aﬃne) subspace C = H 1 ∩ H 2 of dimension n − 2, so we avoid to explicitly mention
rotation axes, hereafter. Note that such rotations are uniquely identiﬁed by their amount (angle) of rotation, which is the
one available degree of freedom. Formally, deﬁne the result of a rotation of a halfspace H 1+ towards a halfspace H 2+ of an
angle −π < α < π to be the halfspace H 3+ such that δ( H 3+ , H 2+ ) = δ( H 1+ , H 2+ ) − α , and H i ∩ H j = C , ∀i , j ∈ {1, 2, 3}, i = j
(the points on the axis C of rotation are ﬁxed).
A set F ⊆ P is a face of P if either F = ∅, or F = P , or if there exists a supporting hyperplane H F of P such that F is
their touching set, i.e., F = H F ∩ P . In the latter case, we say that F is a proper face of P . A facet of P is a proper face of P
having the largest possible dimension, that is, whose dimension is dim( P ) − 1.
The following facts are well known [42]:
1. For any facet F of P , there is a halfspace H + ∈ S such that F = H + ∩ P . We say that H + generates F .
2. For any proper face F of P , there is a facet F of P such that F ⊆ F .
3. If F and F are two proper faces of P and F ⊂ F , then dim( F ) < dim( F ).
6.3.2. Separating polyhedra from a few supporting halfspaces
We start with a pair of technical results. Since coalitions correspond to the inequalities (2) and hence to the associated
halfspaces of Rn , we hereafter slightly abuse notation and use these terms interchangeably.
Lemma 6.10 (Roof Lemma). Let H 1+ , H 2+ , and H 3+ be three halfspaces such that H i ∩ H j = C = ∅, ∀i , j ∈ {1, 2, 3}, i = j, and such
that H 3+ may be obtained by rotating H 1+ towards H 2+ by β < 0, with δ( H 2+ , H 1+ ) − β < π . Then, H 1+ is a supporting halfspace for
H 2+ ∩ H 3+ , i.e., for Pol({ H 2+ , H 3+ }).

6
This section is self-contained and its results are not used in the subsequent sections. Thus, it can be skipped without troubles by a reader who is not
interested in a deeper understanding of the existence of “small” infeasibility certiﬁcates.

1900

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

Fig. 5. Rotations of halfspaces in Lemma 6.10.

Fig. 6. Construction of a certiﬁcate of emptiness for the core.

Proof. Note that H 2+ may be obtained by rotating H 1+ towards H 2+ by their dihedral angle 0 < α = δ( H 2+ , H 1+ ) < π . Thus, all
points A of H 1 \ C that belong to H 2+ are in H 3− , because H 3 is obtained by rotating those points (in the opposite direction)
by the angle β < 0. Symmetrically, all points B of H 1 \ C belonging to H 3+ are in H 2− , see Fig. 5, for a three-dimensional
illustration. Moreover, observe that all points in H 1 \ C are involved in the rotations and thus belong to either A or B. It
follows that ( H 1 \ C ) ∩ ( H 2+ ∩ H 3+ ) = ∅, whence H 1 is a supporting hyperplane. Finally, since δ( H 2+ , H 1+ ) − β < π , it is easy
to see that some point in H 2+ ∩ H 3+ is in H 1+ , and thus H 1+ is in fact a supporting halfspace for Pol({ H 2+ , H 3+ }). ✷
We next show that, whenever a full-dimensional polyhedron P = Pol(S ) of Rn is separated from some hyperplane H P ,
there exists a subset of at most n halfspaces corresponding to facets of P that deﬁne a larger polyhedron of Rn (a rough
approximation of P ), which is still separated from H P . We ﬁrst give the proof idea, with the help of Fig. 6. For the sake
of intuition, imagine that H +
P is the inequality (3) associated with the grand coalition, while the set S corresponds to the
other inequalities (2), whence in this case the core is empty. If there is a facet F of P that is parallel to H P , we are trivially
done, because its associated halfspace already provides the desired separated polyhedron, succinctly described by just one
inequality. Otherwise such a face F has a smaller dimension but, from Fact 2, there exists a facet F of P such that F ⊂ F .
In the three-dimensional example shown in Fig. 6, F is the vertex at the bottom of the diamond, H +
F is the halfspace
(anti-)parallel to H P that contains F (but it is not associated with any inequality generating P ), and F is some facet on its
+
“dark side”. Let C = H F ∩ H F , and consider the rotation of H +
F towards H F of a negative angle β (we go on the opposite
+
direction w.r.t. H F ) that ﬁrst touches P , say H F . As illustrated in Fig. 6, where the face F is an edge of the diamond,
F properly includes F and its dimension is at least d > dim( F ). From the above lemma, H +
F is a supporting halfspace of
+
,
H
)
,
called
its
roof,
which
contains
P
and
is
separated
from
H
.
However, we are not satisﬁed
the polyhedron Pol( H +
P
F
F
because we would like that such a polyhedron is described by (at most n) halfspaces taken from S , and H +
does not belong
F
to S , in general (as in our example, where it does not generate a facet of P ). Then, we proceed inductively, by observing
that H +
is a supporting halfspace for Pol( H +
, H+
)—its roof, whose faces have higher dimension than F . In the running
F
F
F
1

2

example, they are both facets of the diamond, and hence the property immediately holds. In general, the procedure may
continue, encountering each time at least one facet and one more face with a higher dimension than the current one. The
formal proof follows.

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

1901

Lemma 6.11. Let P = Pol(S ) be a polyhedron of Rn with dim( P ) = n, and H +
F a supporting halfspace of P whose touching set is F .
Then, there exists a set of halfspaces H F ⊆ S such that |H F | n − dim( F ), H +
F is a supporting halfspace of Pol(H F ), and their
touching set C is such that F ⊆ C .
Proof. The proof is by induction. Base case: If dim( F ) = n − 1 we have that the touching face F = H +
F ∩ P is a facet of P .
Thus, from Fact 1, F is generated by some halfspace H + ⊆ S such that H + ∩ P = F , as for H F . Since dim( F ) = dim( H ) =
+
dim( H F ) = n − 1, it easily follows that, in fact, H = H F holds. Thus, H +
F is trivially a supporting halfspace of H , and this
case is proved: just take H F = { H + } and note that |H F | = 1.
of P such that its
Inductive step: By the induction hypothesis, the property holds for any supporting halfspace H +
F
touching face F has a dimension d dim( F ) n − 1, for some d > 0. We show that it also holds for any supporting
halfspace H +
F of P , whose touching face F has a dimension dim( F ) = d − 1.
∈ S is the
Since F is not a facet, from Fact 2 there exists a facet F of P such that F ⊂ F . Let C = H F ∩ H F , where H +
F
P
halfspace that generates the facet F . Note that F ⊆ C . Let H +
be
the
halfspace
that
ﬁrst
touches
the
polyhedron
obtained
F
+
+
+
by rotating H +
F towards H F by some negative angle β (i.e., we are going in the opposite direction w.r.t. H F ). Then, H F
+
+
is a supporting halfspace of P , and the touching set F includes C . Since dim( P ) = n, we have that δ( H F , H F ) − β < π
and F ⊂ F (as the latter face contains some point of the polyhedron outside the axis C ⊇ F ), and thus the dimension
dim( F ) of this face is strictly greater than dim( F ), from Fact 3. Moreover, from Lemma 6.10, H +
F is a supporting halfspace
+
C
,
H
)
,
with
=
H
∩
H
as
touching
set.
of Pol( H +
F
F
F
F
By the induction hypothesis, since both dim( F ) and dim( F ) are at least d, we know that there are two sets H F ⊆ S
and H F ⊆ S such that: H +
is a supporting halfspace of Pol(H F ), with F ⊆ C , where C is their touching set; and H +
F
F
is a supporting halfspace of Pol(H F ), with F ⊆ C , where C is their touching set. In particular, Pol(H F ) ⊆ H +
and
F
, respectively. Let H F = H F ∪ H F . Then, we get Pol(H F ) ⊆ Pol({ H +
, H+
}) ⊆ H +
Pol(H F ) ⊆ H +
F .
F
F
F
Recall that F ⊆ C . Moreover, F ⊂ F and F ⊂ F , and thus F ⊆ ( F ∩ F ) ⊆ (C ∩ C ), since F ⊆ C and F ⊆ C . It follows
that the touching set of H +
F and Pol(H F ) includes F . Indeed, this touching set includes (C ∩ C ) ∩ H F ⊇ (C ∩ C ) ∩ ( H F ∩
H F ∩ H F ) = (C ∩ C ) ∩ C , and from the above observations (C ∩ C ) ∩ C ⊇ F .
|H F | + |H F | = 1 + |H F |, because dim( F ) = n − 1 and the base case applies. Moreover,
Finally, note that |H F |
1 + n − dim( F )
1+n−d=
dim( F ) > dim( F ) = d − 1 and thus, by the induction hypothesis, we obtain |H F |
n − dim( F ). ✷
Let G = N , v be a coalitional game. A coalition set S ⊆ 2 N is a certiﬁcate of emptiness (or infeasibility certiﬁcate) for the
core of G if the intersection of Pol(S ) with the grand coalition halfspace (3) is empty. In fact, this deﬁnition is motivated
by the following observation. Let P be the polyhedron of Rn obtained as the intersection of all halfspaces (2). Since S is a
subset of all possible coalitions, P ⊆ Pol(S ). Therefore, if the intersection of Pol(S ) with the grand coalition halfspace (3) is
empty, the intersection of this halfspace with P is empty, as well.
Theorem 6.12. Let G = N , v be a coalitional game. If the core of G is empty, there is a certiﬁcate of emptiness S for it such that
|S | | N | .
Proof. Let n = | N | and P be the polyhedron of Rn obtained as the intersection of all halfspaces (2). Since we are not
considering the feasibility constraint (3), there is no upper-bound on the values of any variable xi , and thus it is easy to see
that P = ∅ and dim( P ) = n.
Let H +
P be the halfspace deﬁned by the grand coalition inequality (3). If the core of G is empty, the whole set of
inequalities has no solution, that is, P ∩ H +
P = ∅.
¯ + be the halfspace parallel to H + that ﬁrst touches P , that is, the smallest relaxation of H + that intersect P .
Let H
F
P
P
+
+
¯
¯+
Consider the opposite H +
F of H F , as shown in Fig. 6, on the left. By construction, H P ∩ H F = ∅, H F = H F is a supporting
+
hyperplane of P , and H F is a supporting halfspace of P . Let F be the touching set of H F with P , and let d = dim( F ). (In
Fig. 6, F is the vertex at the bottom of the diamond P .) From Lemma 6.11, there is a set of halfspaces S associated with
+
inequalities from (2), with |S | n − d, and such that H +
F is a supporting halfspace for Pol(S ). It follows that H P ∩ Pol(S ) = ∅,
whence S is a certiﬁcate of emptiness for the core of G . Finally, note that the largest cardinality of S is n, and corresponds
to the case dim( F ) = 0, that is, to the case where the face F is just a vertex. Therefore the maximum cardinality of the
, H+
, H+
}, as shown in Fig. 6, on the right. ✷
certiﬁcate is n. In our three-dimensional example, the certiﬁcate is { H +
F
F
F
1

2

7. Tractable classes of graph games
Many NP-hard problems in different application areas ranging, e.g., from AI [67] and Database Theory [11] to Game Theory [21], are known to be eﬃciently solvable when restricted to instances whose underlying structures can be modeled via
acyclic graphs or nearly-acyclic ones, such as those graphs having bounded treewidth [70]. Indeed, on these kinds of instances,
solutions can usually be computed via dynamic programming, by incrementally processing the acyclic (hyper)graph, accord-

1902

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

ing to some of its topological orderings. In this section, we shall show that (near) acyclicity is also a key for the tractability
of coalitional games represented in terms of marginal contribution nets.
Our results are established by showing that the various solution concepts studied in this paper can be expressed in
terms of optimization problems over Monadic Second Order Logic (MSO) formulae, and by subsequently applying Courcelle’s
Theorem [19] and its generalization to optimization problems due to Arnborg, Lagergren, and Seese [2].
For the sake of completeness, we start by reviewing the concepts of treewidth and Monadic Second Order Logic.
7.1. Treewidth and Monadic Second Order logic
Treewidth. A tree decomposition of a graph G = ( N , E ) is a pair T , χ , where T = ( V , F ) is a tree, and χ is a labeling
function assigning to each vertex p ∈ V a set of vertices χ ( p ) ⊆ N, such that the following conditions are satisﬁed:
(1) for each node b of G, there exists p ∈ V such that b ∈ χ ( p );
(2) for each edge (b, d) ∈ E, there exists p ∈ V such that {b, d} ⊆ χ ( p ); and,
(3) for each node b of G, the set { p ∈ V | b ∈ χ ( p )} induces a connected subtree of T .
The width of T , χ is the number max p ∈ V (|χ ( p )| − 1). The treewidth of G, denoted by tw(G ), is the minimum width
over all its tree decompositions. A graph G is acyclic if and only if tw(G ) = 1. Deciding if a given graph has treewidth
bounded by a ﬁxed natural number k is known to be feasible in linear time [13].
A ﬁnite structure A consists of a domain A and relations R 1 , . . . , R k of arities a1 , . . . , ak , respectively. Each relation R i
consists of a set of tuples (e 1 , . . . , eai ), where e j ∈ A, for each 1
j ai . The size of A, denoted by A , is the value

A = | A| +

k
j =1 | R j |

× a j . Note that a graph G = ( N , E ) can be viewed as a ﬁnite structure whose domain is N, and
where E is a binary relation encoding its edges.
The Gaifman graph of a ﬁnite structure A is the undirected graph G (A) whose vertices are the elements of the domain
of A, and where there is an edge between the elements e and e if and only if there is a tuple of some relation of A where
e and e jointly occur. The treewidth of A, denoted by tw(A), is the treewidth of its Gaifman graph, i.e., tw(A) = tw(G (A)).
MSO. A First Order logic formula is made up of relation symbols, individual variables (usually denoted by lowercase letters),
the logical connectives ∨, ∧, and ¬, and the quantiﬁers ∃ and ∀. Monadic Second Order (MSO) enhances the expressiveness
of ﬁrst order logic by allowing the use of set variables (usually denoted by uppercase letters), of the membership relation ∈,
and of the quantiﬁers ∃ and ∀ over set variables. In addition, it is often convenient to use symbols like ⊆, ⊂, ∩, ∪, and
→ with their usual meaning, as abbreviations. When an MSO formula φ is evaluated over a ﬁnite structure A, the relation
symbols of φ are interpreted as the corresponding relations of A and the variables of φ range over the domain A of A. The
fact that an MSO formula φ holds over A is denoted by A | φ .
Example 7.1. Let G = ( N , E ) be an undirected graph (interpreted as a ﬁnite structure). Then, the fact that G is 3-colorable
can be expressed via the following MSO formula:

∃R, B, Y , R ∪ B ∪ Y = N ∧
R∩B =∅ ∧ R∩Y =∅ ∧ B∩Y =∅∧
∀x, x ∈ B → ∀ y , {x, y } ∈ E → ¬( y ∈ B ) ∧
∀x, x ∈ R → ∀ y , {x, y } ∈ E → ¬( y ∈ R ) ∧
∀x, x ∈ Y → ∀ y , {x, y } ∈ E → ¬( y ∈ Y )
In particular, note that the formula checks whether there exists a partition of the nodes in N into three disjoint sets of nodes
R, B, and Y , which respectively correspond to the nodes that are colored red, blue, and yellow. Moreover, the formula checks
that for each node, all its adjacent nodes are colored with a different color.
The relationship between treewidth and MSO is illustrated next.
Proposition 7.2 (Courcelle’s Theorem [19]). Let φ be a ﬁxed MSO sentence, let k be a ﬁxed constant, and let Ck be a class of ﬁnite
structures having treewidth bounded by k. Then, for each ﬁnite structure A ∈ Ck , deciding whether A | φ holds is feasible in linear
time (w.r.t. A ).
For instance, from the above theorem and Example 7.1, we can immediately conclude that 3-colorability is a property
that can be checked in polynomial time on classes of graphs having bounded treewidth, while, on arbitrary classes of graphs,
the problem is known to be NP-complete (see, e.g., [35]).
An important generalization of MSO formulae to optimization problems was presented by Arnborg et al. [2]. Next, we
state a simpliﬁed deﬁnition of these kinds of problems.

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

1903

Let A be a ﬁnite structure over the domain A, and let w be a list of weights associated with the elements in A, such
that w (e ) is a rational number for each e ∈ A. The pair A, w is hereinafter called a weighted ﬁnite structure, and its size
A, w is deﬁned as the size of A plus all the values (numerators and denominators) in w.
Let φ( X¯ ) be an MSO formula over A, where X¯ is the set of free variables occurring in φ . For an interpretation I mapping
variables in X¯ to subsets of A, we denote by φ[I ] the MSO formula (without free variables) where each variable X ∈ X¯ is
replaced by I ( X ).
A solution to φ over A, w is an interpretation I such that A | φ[I ] holds. The cost of I is the value
e ∈I ( X ) w (e ).
X ∈ X¯
A solution of minimum cost is said optimal.
Example 7.3. Let G = ( N , E ) be an undirected graph (interpreted as a ﬁnite structure). Then, the property that a set X of
nodes is a vertex cover, i.e., a set such that each edge in E has at least one endpoint incident on it, can be expressed via the
following MSO formula where X is its free variable:

vertexCover( X ) ≡ X ⊆ N ∧ ∀ y , y ∈ N → ( y ∈ X ) ∨ ∃x ∈ X , {x, y } ∈ E
By considering a list w of weights assigning 1 to each node in N, we have that an optimal solution to vertexCover over
G , w is a minimum-cardinality vertex cover.
The fact that, over bounded treewidth structures, deciding the existence of a solution to a ﬁxed MSO sentence is feasible
in polynomial time is the well-known result by Courcelle. The result below evidences that not only the decision problem,
but even the associated problem of computing a solution of minimum cost is feasible in polynomial time on such structures.
Theorem 7.4 (Simpliﬁed from Arnborg et al. [2]). Let φ be a ﬁxed MSO sentence, let k be a ﬁxed constant, and let Ck be a class of ﬁnite
structures having treewidth bounded by k. Then, for each weighted ﬁnite structure A, w such that A ∈ Ck , computing an optimal
solution to φ over A, w is feasible in polynomial time (w.r.t. A, w ).
For instance, from the above theorem and Example 7.3, we can immediately conclude that computing a minimumcardinality vertex cover is feasible in polynomial time on classes of graphs having bounded treewidth whereas, on arbitrary
classes of graphs, it is NP-hard (see, e.g., [4]). A further example is discussed below.
Example 7.5. A Boolean formula F in conjunctive normal form over a set V of variables can be interpreted as a structure
where cl( z) (resp., var( z)) means that z is a clause (resp., a variable) in F , and where pos(x, c ) (resp., neg(x, c )) means that
x occurs in a positive (resp., negative) literal in the clause c. Then, the property that a set X of variables is a model for F
can be expressed via the following MSO formula:

model( X ) ≡ X ⊆ V ∧ ∀c , cl(c ) → ∃x,

x ∈ X ∧ pos(x, c ) ∨ x ∈
/ X ∧ neg(x, c )

By considering a list w of weights assigning 1 to each variable in V , we have that an optimal solution to model over F , w
is a minimum-sized model, i.e., a satisfying truth assignment whose number of variables evaluating to true is the minimum
possible one over all possible satisfying truth assignments.
7.2. MSO encoding for marginal contribution networks
Seminal results on the tractability of special classes of marginal contribution nets have been discussed by Ieong and
Shoham [44], who showed that In-Core and Core-NonEmptiness are tractable on classes of MC-nets whose associated
agent graphs have bounded treewidth. However, as observed in the Introduction, since for each rule {pattern} → value the
subgraph induced by the players occurring together in pattern is a clique in the agent graph, by using this representation
one may overvalue the actual intricacy of the game. For instance, classes of MC-nets with one rule only involving all the
players of the game do not fall in the tractable classes analyzed by Ieong and Shoham [44], as the associated agent graph
consists of a clique over all the players (whose treewidth is thus not bounded by any ﬁxed constant). After this observation,
we next explore the possibility of isolating larger islands by encoding MC-nets in terms of suitable ﬁnite structures.
Let M be a marginal contribution network whose sets of players and rules are P and R, respectively. We encode M in
terms of a ﬁnite structure A M deﬁned over the universe P ∪ R, over the unary relations player and rule, and over the binary
relations pos and neg. Tuples in the relations are deﬁned as follows: for each player p ∈ P , the tuple ( p ) is in player; for each
rule r ∈ R, the tuple (r ) is in rule; for each rule r of M having the form {pattern} → value, and for each player p occurring
positively (resp., negatively) in pattern, the tuple ( p , r ) is in pos (resp., neg). For a marginal contribution network M, we
deﬁne its incidence graph IG( M ) as the Gaifman graph of the structure A M . Note that IG( M ) is a bipartite graph, whose
set of nodes consists of the players and the rules in M, and where there is an edge between a player p and a rule r if and
only if p occurs in the pattern of r.
Example 7.6. Consider again the marginal contribution network M of Example 1.3 (on p. 1880), which consists of the rules
r1 : {a ∧ b ∧ c } → 2, r2 : {c ∧ d ∧ e } → 1, r3 : {e } → −1, over the players in {a, b, c , d, e }. Then, the ﬁnite structure A M
associated with M is such that: players = {(a), (b), (c ), (d), (e )}, rules = {(r1 ), (r2 ), (r3 )}, pos = {(a, r1 ), (b, r1 ), (c , r1 ), (c , r2 ),
(d, r2 ), (e , r2 ), (e , r3 )}, and neg = { }.

1904

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

Fig. 2 reports, on the right, the incidence graph associated with the MC-net of Example 1.3. Note that IG( M ) is acyclic,
while the agent graph AG( M ), reported on the left of the ﬁgure, contains cycles.
For each natural number n > 0, let M n denote the network over the players p 1 , . . . , pn and just containing the rule
{ p 1 ∧ · · · ∧ pn } → 0. Then, it is easily seen that tw(IG( Mn )) = 1, i.e., the incidence graph is acyclic, while tw(AG( Mn )) = n − 1.
Therefore, the class of all such MC-nets has bounded treewidth (actually, treewidth 1) if incidence graphs are considered,
while it has unbounded treewidth if agent graphs are considered. In fact we next show that, as long as one is interested
in identifying structurally restricted classes of tractable MC-nets, the incidence graph encoding is always preferable to the
agent-graph one, as classes of games whose agent graphs have bounded treewidth are such that their associated incidence
graphs have bounded treewidth too (and we have just observed that the inverse does not hold).
Proposition 7.7. For any MC-net M, tw(IG( M ))

tw(AG( M )) + 1.

Proof. Let M be an MC-net, and let T , χ be a tree decomposition of AG( M ), where T = ( V , F ) is a tree. Note that for
each rule r : {pattern} → value in M, the subgraph of AG( M ) induced over the set P r of all the players occurring in pattern
is a clique. Thus, there is a vertex v r ∈ V such that P r ⊆ χ ( v r )—in case where several vertices cover the variables in P r , let
v r denote an arbitrarily chosen one enjoying the property.
Based on T , χ , we build a pair T , χ where T is the tree obtained from T by creating a novel vertex w r , for each rule
r of M, and by connecting w r to the vertex v r . Moreover, let us deﬁne χ ( v ) = χ ( v ), for each v ∈ T , and χ ( w r ) = P r ∪ {r },
for each vertex w r ∈ T \ T . It is immediate to check that T , χ is a tree decomposition of IG( M ). To this end, note that
all the edges and nodes of IG( M ) are covered in the vertices of the form w r , that the connectedness condition over the
player-nodes is guaranteed by the connectedness condition on T , χ , and that the connectedness condition over rule-nodes
is guaranteed by the fact that each such node exactly occurs in one vertex. The result follows by the fact that the width of
T , χ is bounded by the width of T , χ plus 1. ✷
7.3. Complexity results
Now that the framework for encoding the structure of marginal contribution networks has been illustrated, a natural
question arises, that is, whether bounded treewidth over incidence graph encodings is a guarantee for the tractability of the
solution concepts studied in the paper. In the rest of the section, we shall provide an answer to this question. The answer
is positive, at least for those cases where the values occurring in the network are polynomially bounded in the number of
players and rules.
For any natural number k, let MCN k be the class of marginal contribution nets such that, for each M ∈ MCN k ,
tw(IG( M )) k and the value of each rule of M is polynomially bounded by the size of A M . Moreover, for each marginal
contribution network M, let M denote its size, naturally measured as the size of A M plus the number of bits necessarily
to encode all the values in the rules of M (in binary).
We next provide our results concerning the tractability of the problems In-Core, Core-NonEmptiness and In-Kernel
over the class MCN k . Note that the results pertaining to the core are incomparable to those by Ieong and Shoham [44].
Indeed, on the one hand, we consider classes of marginal contribution networks that are larger in terms of their structure
but, on the other hand, we restrict ourselves to deal with “small” values. In particular, these islands of tractability lead to
pseudo-polynomial algorithms when values are not small, and the question is open about whether (full) polynomial-time
algorithms exist for MC-nets with bounded-treewidth incidence graphs.
Theorem 7.8. On the class MCN k , In-Core is feasible in polynomial time.
Proof. Let M be a marginal contribution network in MCN k , and let x be a payoff vector. We have to check whether x
belongs to the core of the game induced by M. Assume w.l.o.g. that x is an imputation. Indeed, over marginal contribution
networks, this latter property can be checked in polynomial time. Let A M , w be the weighted relational structure where
A M is the relational encoding of M, and where w (r ) = −value, for each rule r : {pattern} → value, and w ( p ) = x p , for each
player p in M.
Consider the following MSO formulae:

rules( X ) ≡ ∀r , r ∈ X → r ∈ rule
players(Y ) ≡ ∀ p , p ∈ Y → p ∈ player

/Y
active( X , Y ) ≡ ∀ p , ∀r , ( p , r ) ∈ pos ∧ r ∈ X → p ∈ Y ∧ ( p , r ) ∈ neg ∧ r ∈ X → p ∈
maxActive( X , Y ) ≡ active( X , Y ) ∧ ∀ X , X ⊃ X → ¬active X , Y
excess( W ) ≡ ∃ X , Y : rules( X ) ∧ players(Y ) ∧ X ∪ Y = W ∧ maxActive( X , Y )

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

1905

and note that an interpretation I such that A M | excess[I ] is just a mapping from the set W (of the free variables in the
formula) to a disjoint union of two sets X and Y of rules and players, respectively, where X consists of the rules of M that
MCN (Y ), where v MCN is the
apply to coalition Y . The cost of I is therefore the value
r ∈ X w (r ) +
p ∈Y w ( p ) = x( Y ) − v
worth function encoded via the network M.
From the above observation, it follows that there is a one-to-one correspondence between optimal solutions to the
formula excess and the sets Y ∗ of players such that x(Y ∗ ) − v MCN (Y ∗ ) x(Y ) − v MCN (Y ), for each coalition Y . Thus, the
imputation x belongs to the core of the game if and only if the cost of any optimal solution is non-negative.
To conclude the proof, observe now that for any ﬁxed constant k, by Theorem 7.4, an optimal solution (and thus its
associated cost) can be computed in polynomial time (w.r.t. A M , w ) on each class Ck of structures such that every
element A M ∈ Ck has treewidth bounded by k, i.e., such that tw(IG( M )) k. Recall now that the size A M , w is deﬁned
as the size of A M plus all the values in w (or, equivalently plus the number of bits that are necessary to encode the
weights in unary). Whenever the value of each rule of M is polynomially bounded by the size of A M , we have that an
optimal solution can be computed in polynomial time w.r.t. M (i.e., w.r.t. the size of A M plus the number of bits that are
necessary to encode all the values in the rules of M in binary). Thus, on the class MCN k , In-Core is feasible in polynomial
time. ✷
The proof of the above results provides us with a key ingredient to show the tractability of Core-NonEmptiness on
the class MCN k . Indeed, Ieong and Shoham [44] observed that Core-NonEmptiness can be solved in polynomial time
via the ellipsoid method, provided that a polynomial time separation oracle exists for the problem of checking whether a
given imputation x is not in the core. A separation oracle is any procedure that either conﬁrms that x belongs to the core,
or reports a coalition S witnessing that this is not the case (i.e., such that x( S ) − v MCN ( S ) < 0). Computing an optimal
solution to the MSO formula excess in the proof of Theorem 7.8 immediately provides us with such a separation oracle,
which is computable in polynomial time on the class MCN k . Thus, the following is established.
Theorem 7.9. On the class MCN k , Core-NonEmptiness is feasible in polynomial time.
We now conclude the analysis by considering the kernel.
Theorem 7.10. On the class MCN k , In-Kernel is feasible in polynomial time.
Proof. Let x be a given payoff vector. Since we can check in polynomial time whether x is an imputation, by Deﬁnition 4.1
we have just to show that checking whether si , j (x) > s j ,i (x) ⇒ x j = v ({ j }) holds is feasible in polynomial time (on the
class MCN k ), for each pair of players i = j. We shall prove that si , j (x) can be computed in polynomial time for any pair
of players, which clearly entails the tractability result. In particular, recall that si , j (x) = max S ∈Ii, j e ( S , x), so that si , j (x) =
max S ∈Ii, j ( v MCN ( S ) − x( S )) = − min S ∈Ii, j (x( S ) − v MCN ( S )). Thus, it can equivalently be shown that we can compute in

polynomial time the value min S ∈Ii, j (x( S ) − v MCN ( S )).

To this end, given a marginal contribution network M ∈ MCN k , consider the relational structure A+
M obtained from A M
by adding the unary relations in and out, with in = {(i )} and out = {( j )}. Note that A M and A+
have
precisely the same
M
Gaifman graph (thus, the modiﬁcation does not alter their structural properties).
Consider now the MSO formulae in the proof of Theorem 7.8, with the following change:

excess+ ( W ) ≡ ∃ X , Y : rules( X ) ∧ players(Y ) ∧ X ∪ Y = W ∧ maxActive( X , Y ) ∧

/ Y)
(∀ p , p ∈ in → p ∈ Y ) ∧ (∀ p , p ∈ out → p ∈
An interpretation I such that A+
M | excess[I ] is now a mapping from the set W to a disjoint union of two sets X and Y
of rules and players, respectively, where, in particular, X consists of the rules of M that apply to coalition Y , and where Y
contains player i and does not contain player j. Thus, by considering the weighting function w in the proof of Theorem 7.8,
we have that optimal solutions one-to-one correspond to coalitions S ∈ Ii , j minimizing the expression (x( S ) − v MCN ( S ))
over all the possible coalitions in Ii , j . By Theorem 7.4, an optimal solution (and thus its associated cost) can be computed in
+
+
polynomial time on each class Ck+ of structures such that, for each A+
k holds, and such that
M ∈ Ck , tw(A M ) = tw(IG( M ))
+
the value of each rule of M is polynomially bounded by the size of A M . The tractability on MCN k immediately follows
+
from the fact that, given any marginal net M ∈ MCN k , the corresponding structure A+
M ∈ Ck can be built in polynomial
+
time, and it is such that tw(A M ) = tw(A M ). ✷
By combining the above three results with Proposition 7.7 and with the fact that any graph game can be encoded as
a marginal contribution network having the same agent graph structure, we get the following tractability results for graph
games.
Corollary 7.11. Let GG k be any class of graph games such that, for each G ∈ GG k , tw(G ) k and all the weights in G are polynomially
bounded in the number of its nodes. Then, on the class GG k , In-Core, Core-NonEmptiness, and In-Kernel are feasible in polynomial
time.

1906

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

We leave the section by stressing that the running time of the algorithms exploited by Courcelle [19] and Arnborg
et al. [2] to evaluate MSO formulae exponentially depends on the treewidth of the underlying structure. Thus, bounded
treewidth is an actual key for tractability only if the given domain exhibit instances with low treewidth. As an example,
such instances were subject of study in a number of papers dealing with (wireless) communication networks [51,15], and
middleware strategies deﬁned on top of such networks (where tree-like structures often emerge [50]). Therefore, results in
this section are likely to be of practical interest for those classes of (graph) games exploited in the literature to model
cooperation as a coordination paradigm in communication networks [71].
8. Conclusions
In this paper, we have provided a complete picture of the complexity issues arising from the notions of the core, kernel,
and bargaining set on compactly speciﬁed coalitional games. Our results conﬁrm two conjectures by Deng and Papadimitriou
[26] concerning graph games, and positively answer an open question regarding marginal contribution networks posed by
Ieong and Shoham [44]. In addition, we have studied the complexity of these concepts on NPopt -representations, and on
classes of marginal contribution networks whose incidence-graph encodings have bounded treewidth.
Our research leaves open some speciﬁc technical issues, which might be addressed in further research. In particular,
it would be interesting to assess (1) whether hardness results for NPopt -representation can be established for some speciﬁc formalism proposed in the literature, (2) whether tractability results for the core and the kernel still hold in case of
arbitrary—possibly very large—weights, and (3) whether the bargaining set is tractable over classes of marginal networks
whose incidence-graph encodings have bounded treewidth.
Moreover, our research opens the way to further investigate more general questions regarding coalitional games. The
ﬁrst natural question is whether some of the techniques described in this paper are applicable to other core-based solution
concepts, such as the nucleolus [73], the least core [56], or the cost of stability [6]. With this respect, note that the complexity
of the nucleolus over succinctly speciﬁed games has been already studied by Greco et al. [38], who provided hardness
results that still hold over graph games (and, hence, marginal contribution networks). Moreover, the complexity of the
least core and of the cost of stability has been recently studied by Greco et al. [40], with hardness results being provided
which are speciﬁc to the oracle setting. In fact, the question of whether such hardness results still hold over graph games
and/or marginal contribution networks was not addressed by Greco et al. [40], and cannot be answered by a straightforward
adaptation of the techniques illustrated in this paper.
Another avenue of further research concerns the application of the method developed in Section 7 to other relevant
game representations and to other problems arising with coalitional games. On the one hand, concerning the application to
other game representations, it would be interesting to extend the concept of incidence graph as to capture the interactions
in general MC-nets, i.e., in networks where patterns can be arbitrary Boolean formulae [29]. On the other hand, concerning
the application to other problems for coalitional games, one may consider for instance the coalition structure generation
problem. In fact, this problem has recently been studied over coalitional skill games by Bachrach et al. [7], who showed that
it is feasible in polynomial time over instances whose underlying structures have bounded treewidth. The result has been
established by encoding coalition structure generation in terms of a constraint satisfaction problem (CSP) [23], and exploiting
well-known results on the tractability of CSP instances having bounded treewidth. As CSPs can be straightforwardly encoded,
in their turn, in terms of Monadic Second Order Logic (in fact, even in First Order Logic without negation and disjunction),
the existence of pseudo-polynomial algorithms directly follows from the line of reasoning exploited in Section 7. However,
in order to assess whether such tractability results still hold in case of arbitrary weights, direct solution approaches are
needed. Similarly, our techniques might be used to assess whether coalition structure generation over graph games and MCnets [60] remains feasible in pseudo-polynomial time when the underlying structures have bounded treewidth. However,
extending the results to get (full) polynomial time algorithms would require new methods. As an example, tractability
results on certain classes of minor-free graphs have recently been singled out by Voice et al. [78].
Acknowledgements
The authors would like to warmly thank the anonymous referees for the competent and helpful comments that allowed
to signiﬁcantly improve the quality of the paper.
Appendix A. Proofs in Section 4
Lemma 4.3. Let K (φ) = ( N K , E K ), w be the graph game associated with the 3CNF formula φ . Then:
(A) w ({chall, sat}) D + 1; and,
(B) D + w (e ) < 0, for each penalty edge e ∈ E K ,
where D = max{chall,sat}

S ⊆N

v ( S ) denotes the maximum worth over all the coalitions not covering the edge {chall, sat}.

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

1907

Proof. Let P = e∈ E K |e={chall,sat}, w (e)>0 w (e ) be the sum of all the positive edges, but the normalizer one, in K (φ). Let us
ﬁrstly observe that:

P

3 × m × 2n+3 + 2 ×

n

2 i + 20

2m+n+5 + 2n+2 + 20

2m+n+6

i =1
m+n+7

Thus, 2
2 × P holds. Moreover, observe that K (φ) contains at least one penalty edge, since w.l.o.g. there is a clause
in φ containing at least two literals. Hence, w ({chall, sat}) = 1 − e∈ E K |e={chall,sat} w (e ) 1 − P + 2m+n+7 . It follows that
w ({chall, sat}) 1 − P + 2 × P = 1 + P . Eventually, P
D holds by deﬁnition of D and, therefore, w ({chall, sat}) 1 + D,
which proves (A).
D, we may note that 2m+n+7 2 × P implies 2m+n+7 > D. ✷
As for (B), given that D > 0 and P
Property 4.4.(1). For each player i ∈
/ {sat, chall}, it holds that max S ∈Ii,sat e ( S , x)

max S ∈Isat,i e ( S , x).

Proof. Let S be an arbitrary coalition in Ii ,sat with i = chall (and i = sat), and consider the coalition T = {chall, sat} ∈ Isat,i .
Note that e ( T , x) = v ( T ) − x( T ) = v ({chall, sat}) − 1 while e ( S , x) = v ( S ). By Lemma 4.3(A), we know that v ({chall, sat})
v ( S ) + 1. Thus, e ( T , x) e ( S , x) holds for all coalitions S ∈ Ii ,sat with i = chall. ✷
Property 4.4.(2). max S ∈Ichall,sat e ( S , x) = m × 2n+3 + maxσ | φ

i
αi |σ (αi )=true 2 .

Proof. Let us ﬁrstly note that max S ∈Ichall,sat e ( S , x) = max S ∈Ichall,sat v ( S ), by construction of the imputation x. Let S ∗ be the
coalition getting maximum worth over all the coalitions in Ichall,sat . Because of Lemma 4.3(B) and since v ({chall}) = 0, S ∗
cannot cover any penalty edge, for otherwise S ∗ would not be a coalition with maximum worth amongst those belonging
to Ichall,sat . Thus, (i) for each variable player αi ∈ S ∗ , no literal player of the form ¬αi , j is in S ∗ ; (ii) for each clause player
c j ∈ S ∗ , at most one literal player of the form i , j is in S ∗ ; and, (iii) for each variable αi , S ∗ contains no pairs of literal
players of the form αi , j and ¬αi , j .
It follows that the worth of S ∗ is such that: v ( S ∗ ) = |C | × 2n+3 + αi ∈ S ∗ 2i , where C is the set of the clause players
c j ∈ S ∗ for which exactly one literal player i , j is in S ∗ ; in particular, recall that 2i is the weight associated with the edge
{chall, αi }, while 2n+3 is the weight associated with each edge of the form {c j , i , j }. Now, let, σ be a truth assignment such
that σ (αi ) = true (resp., σ (αi ) = false) if αi , j (resp., ¬αi , j ) occurs in S ∗ for some clause c j . Note that σ may be a partial
assignment, over a set of variables α ⊆ {α1 , . . . , αn }; however, because of (iii) above, σ is non-contradictory and satisﬁes
n
all the clauses whose players are in C . Eventually, since φ is satisﬁable and since 2n+3 > i =1 2i , because of (ii), S ∗ will
certainly contain all the m clause players (i.e., σ is a satisfying assignment for φ ). That is, v ( S ∗ ) = m × 2n+3 + αi ∈ S ∗ 2i .
Observe now that if αi , j is in S ∗ , then αi is in S ∗ as well, since this leads to maximize the worth of S ∗ . Moreover, if ¬αi , j
is in S ∗ , then αi is not in S ∗ because of (i). Thus, the assignment σ S ∗ such that σ S ∗ (αi ) = true (resp., σ S ∗ (αi ) = false) if
αi occurs (resp., not occurs) in S ∗ coincides with σ when restricted over the domain of the variables in α . Therefore, σ S ∗ is
a satisfying assignment, and we have:

v ( S ∗ ) = m × 2n+3 +

2i
αi |σ S ∗ (αi )=true

m × 2n+3 + max
σ| φ

2i .
αi |σ (αi )=true

We conclude the proof by showing that the above inequality cannot be strict. Indeed, assume, for the sake of contradiction, that a satisfying assignment σ exists for φ such that v ( S ∗ ) < m × 2n+3 + αi |σ (αi )=true 2i . Based on σ , we can build

a coalition S such that: (a) {chall, c 1 , . . . , cm } ⊆ S; (b) αi ∈ S, for each αi such that σ (αi ) = true; (c) exactly one literal i , j
is in S, for each clause c j that is satisﬁed by i , j according to the truth values deﬁned in σ ; (d) no further player is in S.
Given that σ is a satisfying assignment, no penalty edge is covered by S. In particular, v ( S ) = m × 2n+3 + αi ∈ S 2i and,

hence, v ( S ) = m × 2n+3 +

i
αi |σ (αi )=true 2 . But, this is not possible since we would have a coalition S ∈ Ichall,sat such that

v ( S ) > v ( S ∗ ) = max S ∈Ichall,sat v ( S ).

✷

Property 4.4.(3). max S ∈Isat,chall e ( S , x) = m × 2n+3 + maxσ | φ (|{α1 | σ (α1 ) = true}| +

i
αi |σ (αi )=true 2 ) − 1.

Proof. The property can be proven precisely along the same line of reasoning as in the proof of Property 4.4.(1). The
differences are that: x( S ) = 1 holds for each S with sat ∈ S; and that the weight associated with the edge {sat, αi } is 2i , for
each 2 i n, while it is 21 + 20 for the case where i = 1. In particular, |{α1 | σ (α1 ) = true}| precisely encodes the fact
that unitary weight has to be added to any assignment where α1 evaluates to true. ✷
Appendix B. Proofs in Section 5
Lemma 5.3. Let BS (Φ) = ( N BS , E BS ), w be the graph game associated with the NQBF2,∀ formula Φ . Then:
(A) D

m;

1908

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

(B) w ({chall, sat}) > 2 × m;
(C) D + w (e ) < 0, for each penalty edge e ∈ E BS ; and,
(D) m 2 × n,
where D = max{chall,sat}

S ⊆N

v ( S ) denotes the maximum worth over all the coalitions not covering the edge {chall, sat}.

Proof. The fact (A) that D m is immediate by construction. Moreover, the weight of each penalty edge is −m − 1 and,
hence, (C) holds, too. Eventually, (D) (i.e., m 2 × n) is also immediate since Φ is an NQBF2,∀ formula.
−m − 1, for E BS contains more penalty edges than
Let us, hence, focus on (B) by observing that
e ∈ E BS |e ={chall,sat} w (e )
positive ones. Thus, w ({chall, sat}) = n − 1 + m − e∈ E |e={chall,sat} w (e ) n − 1 + m + (m + 1) > 2 × m. ✷
Property 5.4.(1). No player has a justiﬁed objection against a clause or a literal player.
Proof. Indeed, any clause player c j receives 0 in x and is such that v ({c j }) = 0. Therefore, she can counterobject to any
objection through the singleton coalition {c j }. Similarly, any literal player i , j receives 0 in x and is such that v ({ i , j }) = 0,
and can counterobject through { i , j }. ✷
Property 5.4.(2). No player has a justiﬁed objection against chall.
Proof. Assume that a player p ∈ N BS wants to object against chall through a coalition S. If v ( S ) < 0 then p cannot object
against anyone. Indeed, she has to propose an S-feasible vector y such that yk > xk for all players k ∈ S, and hence v ( S ) =
y ( S ) > x( S ); however x( S ) 0 by deﬁnition, so player p cannot fulﬁll this requirements if v ( S ) < 0. Then, because of
Lemma 5.3(C), S does not include any penalty edges. In particular, for each universally quantiﬁed variable αk , it holds that
| S ∩ {αk,i (k) , ¬αk,¯i (k) }| 1, where c i (k) and c¯i (k) are the two clauses where this variable occurs (recall that Φ is an NQBF2,∀
formula).
k
n} such that | T | = n + 1, T ∩ S = ∅, and | T ∩
Consider, then, the coalition T ⊆ {chall} ∪ {αk,i (k) , ¬αk,¯i (k) | 1
{αk,i (k) , ¬αk,¯i (k) }| = 1, for each 1 k n. Note that v ( T ) = n and x( T ) = xchall = n − 1. Then, consider the vector z such
that zchall = xchall = n − 1 and zq = n1 > xq = 0 for each q ∈ T with q = chall, and observe that z( T ) = v ( T ). Eventually, since
T ∩ S = ∅, ( z, T ) is a counterobjection to any objection of p against chall through S. ✷
Property 5.4.(3). No player different from chall has a justiﬁed objection against sat.

/ S, it is the case that {chall, sat} S
Proof. Suppose that a player p = chall has an objection ( y , S ) against sat to x. Since sat ∈
and hence, by Lemma 5.3(A), that v ( S ) m. Then, we claim that ( z, {sat, chall}) is a counterobjection to ( y , S ) of p against
sat, where z is a feasible distribution that assigns m to sat and w ({chall, sat}) − m to chall. In fact, by Lemma 5.3(B), chall
receives a payoff strictly greater than m (i.e., zchall > m). Then, note that zsat = xsat and let us distinguish two cases:
1. chall ∈
/ S: in this case, we have that zchall > m n − 1 = xchall (recall that m 2 × n, by Lemma 5.3(D));
2. chall ∈ S: in this case, we have that zchall > m while y chall v ( S ) m, and hence zchall > y chall .
It follows that, in both cases, ( z, {sat, chall}) is a counterobjection to ( y , S ).

✷

References
[1] T. Ågotnes, W. van der Hoek, M. Wooldridge, Reasoning about coalitional games, Artiﬁcial Intelligence 173 (2009) 45–79.
[2] S. Arnborg, J. Lagergren, D. Seese, Easy problems for tree-decomposable graphs, Journal of Algorithms 12 (1991) 308–340.
[3] R.J. Aumann, M. Maschler, The bargaining set for cooperative games, in: Advances in Game Theory, Princeton University Press, Princeton, NJ, 1964,
pp. 443–476.
[4] G. Ausiello, P. Crescenzi, G. Gambosi, V. Kann, A. Marchetti-Spaccamela, M. Protasi, Complexity and Approximation: Combinatorial Optimization Problems and Their Approximability Properties, Springer-Verlag, Berlin, Heidelberg, Germany, 1999.
[5] H. Aziz, F. Brandt, P. Harrenstein, Monotone cooperative games and their threshold versions, in: M. Luck, S. Sen, W. van der Hoek, G.A. Kaminka (Eds.),
Proceedings of the 9th International Conference on Autonomous Agents and Multiagent Systems (AAMAS 2010), Toronto, Canada, 2010, pp. 1017–1024.
[6] Y. Bachrach, E. Elkind, R. Meir, D.V. Pasechnik, M. Zuckerman, J. Rothe, J.S. Rosenschein, The cost of stability in coalitional games, in: M. Mavronicolas,
V.G. Papadopoulou (Eds.), Algorithmic Game Theory, Proceedings of the Second International Symposium, SAGT 2009, Paphos, Cyprus, October 18–20,
2009, in: Lecture Notes in Computer Science, vol. 5814, Springer-Verlag, Berlin, Germany, 2009, pp. 122–134.
[7] Y. Bachrach, R. Meir, K. Jung, P. Kohli, Coalitional structure generation in skill games, in: M. Fox, D. Poole (Eds.), Proceedings of the 24th AAAI Conference
on Artiﬁcial Intelligence (AAAI-10), Atlanta, GA, USA, 2010, pp. 703–708.
[8] Y. Bachrach, E. Porat, Path disruption games, in: M. Luck, S. Sen, W. van der Hoek, G.A. Kaminka (Eds.), Proceedings of the 9th International Conference
on Autonomous Agents and Multiagent Systems (AAMAS 2010), Toronto, Canada, 2010, pp. 1123–1130.
[9] Y. Bachrach, J.S. Rosenschein, Coalitional skill games, in: L. Padgham, D.C. Parkes, J. Müller, S. Parsons (Eds.), Proceedings of the 7th International
Conference on Autonomous Agents and Multiagent Systems (AAMAS 2008), Estoril, Portugal, 2008, pp. 1023–1030.
[10] Y. Bachrach, J.S. Rosenschein, E. Porat, Power and stability in connectivity games, in: L. Padgham, D.C. Parkes, J. Müller, S. Parsons (Eds.), Proceedings
of the 7th International Conference on Autonomous Agents and Multiagent Systems (AAMAS 2008), Estoril, Portugal, 2008, pp. 999–1006.

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

1909

[11] P. Bernstein, N. Goodman, The power of natural semijoins, SIAM Journal on Computing 10 (1981) 751–771.
[12] J.M. Bilbao, Cooperative Games on Combinatorial Structures, Theory and Decision Library C, vol. 26, Kluwer Academic Publishers, Reading, MA, USA,
2000.
[13] H.L. Bodlaender, A linear-time algorithm for ﬁnding tree-decompositions of small treewidth, SIAM Journal on Computing 25 (1996) 1305–1317.
[14] A. Brøndsted, An Introduction to Convex Polytopes, Graduate Texts in Mathematics, vol. 90, Springer-Verlag, New York, NY, USA, 1983.
[15] T. Calamoneri, The L (h, k)-labelling problem: An updated survey and annotated bibliography, The Computer Journal (2011), doi:10.1093/comjnl/bxr037,
in press.
[16] A. Condon, The complexity of stochastic games, Information and Computation 96 (1992) 203–224.
[17] V. Conitzer, T. Sandholm, Computing Shapley values, manipulating value division schemes, and checking core membership in multi-issue domains,
in: D.L. McGuinness, G. Ferguson (Eds.), Proceedings of the 19th National Conference on Artiﬁcial Intelligence (AAAI-04), San Jose, CA, USA, 2004,
pp. 219–225.
[18] V. Conitzer, T. Sandholm, Complexity of constructing solutions in the core based on synergies among coalitions, Artiﬁcial Intelligence 170 (2006)
607–619.
[19] B. Courcelle, Graph rewriting: An algebraic and logic approach, in: J. van Leeuwen (Ed.), Handbook of Theoretical Computer Science, Volume B: Formal
Models and Semantics, The MIT Press, Cambridge, MA, USA, 1990, pp. 193–242.
[20] S. Dasgupta, C.H. Papadimitriou, U. Vazirani, Algorithms, McGraw-Hill, New York, NY, USA, 2006.
[21] C. Daskalakis, C.H. Papadimitriou, Computing pure Nash equilibria in graphical games via Markov random ﬁelds, in: J. Feigenbaum, J. Chuang, D.M.
Pennock (Eds.), Proceedings of the 7th ACM Conference on Electronic Commerce (EC’06), Ann Arbor, MI, USA, 2006, pp. 91–99.
[22] M. Davis, M. Maschler, The kernel of a cooperative game, Naval Research Logistics Quarterly 12 (1965) 223–259.
[23] R. Dechter, Constraint Processing, Morgan Kaufmann Publishers, San Francisco, CA, USA, 2003.
[24] X. Deng, Q. Fang, X. Sun, Finding nucleolus of ﬂow game, Journal of Combinatorial Optimization 18 (2009) 64–86.
[25] X. Deng, T. Ibaraki, H. Nagamochi, Algorithmic aspects of the core of combinatorial optimization games, Mathematics of Operations Research 24 (1999)
751–766.
[26] X. Deng, C.H. Papadimitriou, On the complexity of cooperative solution concepts, Mathematics of Operations Research 19 (1994) 257–266.
[27] F.Y. Edgeworth, Mathematical Psychics: An Essay on the Mathematics to the Moral Sciences, C. Kegan Paul & Co., London, 1881.
[28] E. Elkind, L.A. Goldberg, P.W. Goldberg, M. Wooldridge, On the computational complexity of weighted voting games, Annals of Mathematics and
Artiﬁcial Intelligence 56 (2009) 109–131.
[29] E. Elkind, L.A. Goldberg, P.W. Goldberg, M. Wooldridge, A tractable and expressive class of marginal contribution nets and its applications, Mathematical
Logic Quarterly 55 (2009) 362–376.
[30] E. Elkind, D. Pasechnik, Computing the nucleolus of weighted voting games, in: C. Mathieu (Ed.), Proceedings of the 20th Annual ACM–SIAM Symposium
on Discrete Algorithms (SODA09), New York, NY, USA, 2009, pp. 327–335.
[31] U. Faigle, S.P. Fekete, W. Hochstättler, W. Kern, On approximately fair cost allocation in euclidean TSP games, OR Spektrum 20 (1998) 29–37.
[32] U. Faigle, W. Kern, On some approximately balanced combinatorial cooperative games, ZOR – Methods and Models of Operations Research 38 (1993)
141–152.
[33] U. Faigle, W. Kern, S.P. Fekete, W. Hochstättler, On the complexity of testing membership in the core of min-cost spanning tree games, International
Journal of Game Theory 26 (1997) 361–366.
[34] Z. Galil, Eﬃcient algorithms for ﬁnding maximum matching in graphs, ACM Computing Surveys 18 (1986) 23–38.
[35] M.R. Garey, D.S. Johnson, Computers and Intractability: A Guide to the Theory of NP-Completeness, W.H. Freeman & Co., New York, NY, USA, 1979.
[36] D.B. Gillies, Solutions to general non-zero-sum games, in: A.W. Tucker, R.D. Luce (Eds.), Contributions to the Theory of Games, vol. IV, in: Annals of
Mathematics Studies, vol. 40, Princeton University Press, Princeton, NJ, USA, 1959, pp. 47–85.
[37] M.X. Goemans, M. Skutella, Cooperative facility location games, Journal of Algorithms 50 (2004) 194–214.
[38] G. Greco, E. Malizia, L. Palopoli, F. Scarcello, On the complexity of compact coalitional games, in: C. Boutilier (Ed.), Proceedings of the 21st International
Joint Conference on Artiﬁcial Intelligence (IJCAI-09), Pasadena, CA, USA, 2009, pp. 147–152.
[39] G. Greco, E. Malizia, L. Palopoli, F. Scarcello, Non-transferable utility coalitional games via mixed-integer linear constraints, Journal of Artiﬁcial Intelligence Research 38 (2010) 633–685.
[40] G. Greco, E. Malizia, L. Palopoli, F. Scarcello, On the complexity of the core over coalition structures, in: T. Walsh (Ed.), Proceedings of the 22nd
International Joint Conference on Artiﬁcial Intelligence (IJCAI-11), Barcelona, Spain, pp. 216–221.
[41] G. Greco, F. Scarcello, On the power of structural decompositions of graph-based representations of constraint problems, Artiﬁcial Intelligence 174
(2010) 382–409.
[42] B. Grünbaum, Convex Polytopes, Pure and Applied Mathematics, vol. XVI, Wiley, New York, NY, USA, 1967.
[43] E. Helly, Über Mengen konvexer Körper mit gemeinschaftlichen Punkten, Jahresbericht der Deutschen Mathematiker-Vereinigung 32 (1923) 175–176.
[44] S. Ieong, Y. Shoham, Marginal contribution nets: a compact representation scheme for coalitional games, in: J. Riedl, M.J. Kearns, M.K. Reiter (Eds.),
Proceedings of the 6th ACM Conference on Electronic Commerce (EC’05), Vancouver, BC, Canada, 2005, pp. 193–202.
[45] S. Ieong, Y. Shoham, Multi-attribute coalitional games, in: J. Feigenbaum, J. Chuang, D.M. Pennock (Eds.), Proceedings of the 7th ACM Conference on
Electronic Commerce (EC’06), Ann Arbor, MI, USA, 2006, pp. 170–179.
[46] D.S. Johnson, A catalog of complexity classes, in: J. van Leeuwen (Ed.), Handbook of Theoretical Computer Science, Volume A: Algorithms and Complexity, The MIT Press, Cambridge, MA, USA, 1990, pp. 67–161.
[47] E. Kalai, W. Stanford, Finite rationality and interpersonal complexity in repeated games, Econometrica 56 (1988) 397–410.
[48] E. Kalai, E. Zemel, On totally balanced games and games of ﬂow, Discussion Paper 413, Northwestern University, Center for Mathematical Studies in
Economics and Management Science, Evanston, IL, USA, 1980.
[49] W. Kern, D. Paulusma, Matching games: The least core and the nucleolus, Mathematics of Operations Research 28 (2003) 294–308.
[50] R. Klasing, A. Kosowski, A. Navarra, Cost minimization in wireless networks with a bounded and unbounded number of interfaces, Networks 53 (2009)
266–275.
[51] A. Kosowski, A. Navarra, C.M. Pinotti, Exploiting multi-interface networks: Connectivity and cheapest paths, Wireless Networks 16 (2010) 1063–1073.
[52] M.W. Krentel, The complexity of optimization problems, in: Proceedings of the 18th Annual ACM Symposium on Theory of Computing (STOC’86),
Berkeley, CA, USA, pp. 69–76.
[53] E. Malizia, L. Palopoli, F. Scarcello, Infeasibility certiﬁcates and the complexity of the core in coalitional games, in: M.M. Veloso (Ed.), Proceedings of
the 20th International Joint Conference on Artiﬁcial Intelligence (IJCAI-07), Hyderabad, India, 2007, pp. 1402–1407.
(i )
[54] M. Maschler, The inequalities that determine the bargaining set M1 , Israel Journal of Mathematics 4 (1966) 127–134.
[55] M. Maschler, The bargaining set, kernel, and nucleolus, in: R.J. Aumann, S. Hart (Eds.), Handbook of Game Theory, vol. 1, in: Handbooks in Economics,
vol. 11, North-Holland, Amsterdam, The Netherlands, 1992, pp. 591–667.
[56] M. Maschler, B. Peleg, L.S. Shapley, Geometric properties of the kernel, nucleolus, and related solution concepts, Mathematics of Operations Research 4
(1979) 303–338.
[57] N. Megiddo, Computational complexity of the game theory approach to cost allocation for a tree, Mathematics of Operations Research 3 (1978) 189–
196.

1910

G. Greco et al. / Artiﬁcial Intelligence 175 (2011) 1877–1910

[58] S. Muroga, Threshold Logic and Its Applications, Wiley-Interscience, New York, NY, USA, 1971.
[59] J. von Neumann, O. Morgenstern, Theory of Games and Economic Behavior, 3rd ed., Princeton University Press, Princeton, NJ, USA, 1953.
[60] N. Ohta, V. Conitzer, R. Ichimura, Y. Sakurai, A. Iwasaki, M. Yokoo, Coalition structure generation utilizing compact characteristic function representations, in: I.P. Gent (Ed.), Principles and Practice of Constraint Programming – CP 2009, Proceedings of the 15th International Conference, CP 2009,
Lisbon, Portugal, September 20–24, 2009, in: Lecture Notes in Computer Science, vol. 5732, Springer-Verlag, Berlin, Germany, 2009, pp. 623–638.
[61] Y. Okamoto, Traveling salesman games with the Monge property, Discrete Applied Mathematics 138 (2004) 349–369.
[62] M.J. Osborne, A. Rubinstein, A Course in Game Theory, The MIT Press, Cambridge, MA, USA, 1994.
[63] G. Owen, On the core of linear production games, Mathematical Programming 9 (1975) 358–370.
[64] C.H. Papadimitriou, Computational Complexity, Addison-Wesley, Reading, MA, USA, 1994.
[65] C.H. Papadimitriou, K. Steiglitz, Combinatorial Optimization: Algorithms and Complexity, 2nd ed., Dover Publications, 1998.
[66] C.H. Papadimitriou, M. Yannakakis, The complexity of facets (and some facets of complexity), Journal of Computer and System Sciences 28 (1984)
244–259.
[67] J. Pearson, P. Jeavons, A survey of tractable constraint satisfaction problems, Technical Report CSD-TR-97-15, Royal Holloway, University of London,
1997.
[68] K. Prased, J. Kelly, Np-completeness of some problems concerning voting games, International Journal of Game Theory 19 (1990) 1–9.
[69] M. Rabin, A note on Helly’s theorem, Paciﬁc Journal of Mathematics 5 (1955) 363–366.
[70] N. Robertson, P. Seymour, Graph minors III: Planar tree-width, Journal of Combinatorial Theory, Series B 36 (1984) 49–64.
[71] W. Saad, Z. Han, M. Debbah, A. Hjørungnes, T. Basar,
¸
Coalitional game theory for communication networks: A tutorial, IEEE Signal Processing Magazine 26 (2009) 77–97.
[72] M. Schaefer, Graph Ramsey theory and the polynomial hierarchy, Journal of Computer and System Sciences 62 (2001) 290–322.
[73] D. Schmeidler, The nucleolus of a characteristic function game, SIAM Journal of Applied Mathematics 17 (1969) 1163–1170.
[74] A.L. Selman, A taxonomy of complexity classes of functions, Journal of Computer and System Sciences 48 (1994) 357–381.
[75] L.S. Shapley, M. Shubik, The assignment game I: The core, International Journal of Game Theory 1 (1971) 111–130.
[76] H.A. Simon, Theories of bounded rationality, in: C.B. McGuire, R. Radner (Eds.), Decision and Organization, in: Studies in Mathematical and Managerial
Economics, vol. 12, North-Holland, Amsterdam, The Netherlands, 1972, pp. 161–176.
[77] S.H. Tijs, T. Parthasarathy, J.A.M. Potters, V. Rajendra Prasad, Permutation games: Another class of totally balanced games, OR Spektrum 6 (1984)
119–123.
[78] T. Voice, M. Polukarov, N.R. Jennings, Graph coalition structure generation, CoRR, arXiv:1102.1747 [abs], 2011.
[79] M. Yannakakis, Equilibria, ﬁxed points, and complexity classes, Computer Science Review 3 (2009) 71–85.

