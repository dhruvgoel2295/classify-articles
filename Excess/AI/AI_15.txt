Artiﬁcial Intelligence 175 (2011) 1757–1789

Contents lists available at ScienceDirect

Artiﬁcial Intelligence
www.elsevier.com/locate/artint

Decentralized MDPs with sparse interactions
Francisco S. Melo a,∗ , Manuela Veloso b
a
b

GAIPS – INESC-ID, TagusPark, Edifício IST, 2780-990 Porto Salvo, Portugal
Computer Science Department, Carnegie Mellon University, Pittsburgh, PA 15213, USA

a r t i c l e

i n f o

a b s t r a c t

Article history:
Received 26 April 2010
Received in revised form 29 April 2011
Accepted 7 May 2011
Available online 10 May 2011

Creating coordinated multiagent policies in environments with uncertainty is a challenging
problem, which can be greatly simpliﬁed if the coordination needs are known to be
limited to speciﬁc parts of the state space. In this work, we explore how such local
interactions can simplify coordination in multiagent systems. We focus on problems in
which the interaction between the agents is sparse and contribute a new decision-theoretic
model for decentralized sparse-interaction multiagent systems, Dec-SIMDPs, that explicitly
distinguishes the situations in which the agents in the team must coordinate from those
in which they can act independently. We relate our new model to other existing models
such as MMDPs and Dec-MDPs. We then propose a solution method that takes advantage
of the particular structure of Dec-SIMDPs and provide theoretical error bounds on the
quality of the obtained solution. Finally, we show a reinforcement learning algorithm in
which independent agents learn both individual policies and when and how to coordinate.
We illustrate the application of the algorithms throughout the paper in several multiagent
navigation scenarios.
© 2011 Elsevier B.V. All rights reserved.

Keywords:
Multiagent coordination
Sparse interaction
Decentralized Markov decision processes

1. Introduction
Decision-theoretic models, such as Dec-MDPs and Dec-POMDPs, provide a rich framework to tackle decentralized
decision-making problems. However, using these models to create coordinated multiagent policies in environments with
uncertainty is a challenging problem, even more so if the decision-makers must tackle issues of partial observability. As
such, solving ﬁnite-horizon Dec-POMDPs is a NEXP-complete problem and thus computationally too demanding to solve
except for the simplest scenarios.
Recent years have witnessed a profusion of work on Dec-POMDP-related models that aim at capturing some of the
fundamental features of this class of problems, such as partial observability, without incurring the associated computational
cost. In this paper, we contribute to this area of research, and introduce a new model for cooperative multiagent decisionmaking in the presence of partial observability. Our model is motivated by the observation that, in many real-world scenarios,
the tasks of the different agents in a multiagent system are not coupled at every decision step but only in relatively
infrequent situations. We refer to such problems as having sparse interactions.
Multi-robot systems provide our primary motivation, as the interaction among different robots is naturally limited by
each robot’s physical boundaries, such as workspace or communication range, and limited perception capabilities. Therefore,
when programming a multi-robot system to perform some task, one natural approach is to subdivide this task into smaller
tasks that each robot can then execute autonomously or as part of a smaller group. As an example, consider the scenario
in Fig. 1. In this scenario, three robots must navigate to their goal locations, marked with dashed lines. While Robot 3 can

*

Corresponding author.
E-mail address: fmelo@inesc-id.pt (F.S. Melo).

0004-3702/$ – see front matter
doi:10.1016/j.artint.2011.05.001

© 2011

Elsevier B.V. All rights reserved.

1758

F.S. Melo, M. Veloso / Artiﬁcial Intelligence 175 (2011) 1757–1789

Fig. 1. Example of a simple navigation task.

navigate to its goal, disregarding the remaining robots, Robots 1 and 2 need to coordinate so as not to cross the narrow
doorway simultaneously. However, this coordination needs only occur around the doorway.
Other examples include problems of sequential resource allocation, in which groups of agents must interact only to
the extent that they need to share some common resource. In this context, several methods have been proposed that
leverage sparse interactions by decomposing the global problem into several smaller local problems that can be solved
more eﬃciently, and then combining the obtained solutions [1,2]. Such approaches, however, are not particularly concerned
with partial observability issues. Additional examples include problems of task allocation, where the different agents in
a multiagent system are assigned to different subtasks, and the interactions between the agents when performing such
subtasks is localized to small regions of the joint state space [3]. Such problems include emergency response scenarios,
where emergency teams are assigned different subtasks (for example, assisting different victims) and interact only in speciﬁc
localized situations.
Several approaches have exploited simpliﬁed models of interaction in multiagent settings. For example, learning tasks
involving multiple agents can be partitioned in a state-wise manner, allowing different agents to independently learn the
resulting “smaller tasks” [4]. Similarly, a hierarchical learning algorithm can be used that considers only interactions between
the different agents at a higher control level, while allowing the agents to learn lower level tasks independently [5]. Other
works use coordination graphs to compactly represent dependences between the actions of different agents, thus capturing
the local interaction between them [6,7]. Local interactions have also been exploited to minimize communication during
policy execution [8] and in the game-theoretic literature to attain compact game representations. Examples include graphical
games [9] and action-graph games [10].
In this article we consider Dec-MDPs with sparse interactions, henceforth Dec-SIMDPs. Dec-SIMDPs leverage the independence between agents to decouple the decision process in signiﬁcant portions of the joint state space. In those situations
in which the agents interact—the interaction areas—Dec-SIMDPs rely on communication to bring down the computational
complexity of the joint decision process. Dec-SIMDPs balance the independence assumptions with observability: in any
given state, the agents are either independent or can share state information (e.g., by communicating).1 A related model
has recently been proposed under the designation of distributed POMDPs with coordination locales [13]. We postpone until
Section 6 a more detailed discussion of this and other related models.
The contributions of this article are threefold. We provide a precise formalization of the Dec-SIMDP model and discuss
the relation with well-established decision-theoretic models such as Dec-MDPs, MMDPs and MDPs. We then contribute two
new algorithms that exhibit signiﬁcant computational savings when compared to existing algorithms for Dec-SIMDPs, and
illustrate their application in several simple navigation tasks. Finally, we investigate the inﬂuence of interaction areas in the
performance of a multiagent system and contribute a new learning algorithm that allows each agent in one such system to
individually learn those interaction areas.
2. Decision-theoretic models for multiagent systems
We now review several standard decision-theoretic models that are relevant for our work [14–16]. We start with single
agent models, namely Markov decision processes (MDPs) and their partially observable counterparts (POMDPs) before moving to multiagent models such as multiagent MDPs (MMDPs) and their partially observable counterparts (Dec-POMDPs). We
establish the notation we use and review some fundamental concepts of later relevance.
To fully specify the different models in this section, we should explicitly include the initial state x0 or a distribution
thereof. However, in order to avoid cluttering the notation, we omit the explicit reference to this initial state, with the
understanding that one such state is implicit.

1

Both independence assumptions and communication can signiﬁcantly bring down the computational complexity in Dec-POMDP related models [11,12].

F.S. Melo, M. Veloso / Artiﬁcial Intelligence 175 (2011) 1757–1789

1759

2.1. Markov decision processes
A Markov decision process (MDP) describes a sequential decision problem in which a single agent must choose an action at
every time step to maximize some reward-based optimization criterion. We use MDPs in the Dec-SIMDP model proposed in
Section 3 to describe an agent in those situations where its actions are independent of other agents—i.e., in those situations
where the agent can be modeled individually.
Formally, an MDP is a tuple M = (X , A , P , r , γ ), where X represents the ﬁnite state space, A represents the ﬁnite
action space, P(x, a, y ) represents the transition probability from state x to state y when action a is taken, and r (x, a)
represents the expected reward for taking action a in state x. The scalar γ is a discount factor.
A Markov policy is a mapping π : X × A → [0, 1] such that, for all x ∈ X ,

π (x, a) = 1.
a∈A

Solving an MDP consists of determining a policy

π so as to maximize, for all x ∈ X ,

∞

V π (x) = Eπ

γ t r X (t ), A (t )

X (0) = x ,

t =0

where X (t ) denotes the state at time step t, A (t ) denotes the action taken at that time instant such that

P A (t ) = a H (t ) = h = P A (t ) = a X (t ) = x = π (x, a),
where H (t ) = { X (0), A (0), . . . , X (t − 1), A (t − 1), X (t )} is the random variable corresponding to the history of the MDP up to
time t, and h denotes a particular realization of H (t ) such that X (t ) = x. We write A (t ) ∼ π to denote the above dependence
of A (t ) on the policy π . We deﬁne the Q -function associated with a policy π as
∞

Q π (x, a) = Eπ

γ t r X (t ), A (t )

X (0) = x, A (0) = a ,

t =0

where, again, A (t ) ∼ π for all t > 0.
For any ﬁnite MDP, there is at least one optimal policy
∗

V π (x)

π ∗ , such that

V π (x)

for every policy π and every state x ∈ X . The value function corresponding to
veriﬁes the Bellman optimality equation,

V ∗ (x) = max r (x, a) + γ
a∈A

P(x, a, y ) V ∗ ( y ) .

∗

π ∗ is denoted by V ∗ (short for V π ) and

(1)

y ∈X

The associated Q -function in turn veriﬁes

Q ∗ (x, a) = r (x, a) + γ

P(x, a, y ) max Q ∗ ( y , u ).
y ∈X

u ∈A

(2)

The optimal policy can be recovered directly from Q ∗ by assigning an action a ∈ A a positive probability of being selected
in state x ∈ X only if a ∈ arg maxu ∈A Q ∗ (x, u ). As such, the solution for any given MDP can be obtained by computing the
corresponding optimal Q -function, Q ∗ .
Given a function q deﬁned over X × A, the Bellman operator H is deﬁned as

(Hq)(x, a) = r (x, a) + γ

P(x, a, y ) max q( y , u ).
y ∈X

u ∈A

(3)

The function Q ∗ in (2) is the ﬁxed-point of H and thus can be computed, e.g., by iteratively applying H to some initial
estimate Q (0) , a dynamic programming (DP) method known as value iteration.
2.1.1. Q-learning
It is possible to use the operator H in (3) and use a standard ﬁxed-point iteration to compute Q ∗ . If P and/or r are
unknown, Q ∗ can be estimated using the Q -learning algorithm [17]. Q -learning allows Q ∗ to be estimated from transitions
consisting of state–action–reward–next state experienced in the environment, and is deﬁned by the update rule

Q k+1 (x, a) = (1 − αk ) Q k (x, a) + αk r (x, a) + γ max Q k ( y , u ) ,
u ∈A

(4)

1760

F.S. Melo, M. Veloso / Artiﬁcial Intelligence 175 (2011) 1757–1789

where Q k (x, a) is the kth estimate of Q ∗ (x, a), y is a sample from the distribution P(x, a, ·) and {αk } is a step-size sequence.
The sample y and the value of r (x, a) can be obtained from a generative model or from the actual system, not requiring
the knowledge of either P or r. Under suitable conditions, the estimates Q k converge to Q ∗ with probability 1 [18]. We
henceforth write QLUpdate( Q ; x, a, r , y , Q ) to compactly denote the general Q -learning update operation in (4), i.e.,

Q updt (x, a) = QLUpdate Q ; x, a, r , y , Q

(1 − αk ) Q (x, a) + αk r + γ max Q ( y , u ) ,
u ∈A

where Q and Q are general Q -functions.
2.2. Partially observable Markov decision processes
Partially observable MDPs describe problems essentially similar to MDPs, in which an agent must choose an action at
every time step to maximize a reward-based criterion. However, at each time step t, the agent in a POMDP cannot directly
observe the state of the process, X (t ), but accesses only an indirect observation thereof, Z (t ). POMDPs will be useful when
planning for Dec-SIMDPs in Section 4. Taking advantage of the particular structure of Dec-SIMDPs, we reduce the global
planning problem to the problem of planning in a collection of individual single-agent POMDPs.
Formally, a POMDP is a tuple (X , A, Z , P, O, r , γ ), where X is the ﬁnite state space, A is the ﬁnite action space and Z
is the ﬁnite observation space. As before, P(x, a, y ) represents the transition probability from state x to state y when action
a is taken, and now O(x, a, z) represents the probability of observing z ∈ Z given that the state is x and action a was taken,
i.e.,

O(x, a, z) = P Z (t + 1) = z X (t + 1) = x, A (t ) = a .
Finally, r (x, a) again represents the expected reward for taking action a in state x and γ is a discount factor.
A non-Markov policy is a mapping π : H → [0, 1] such that, for all ﬁnite histories h ∈ H,

π (h, a) = 1,
a∈A

where h = {a(0), z(1), a(1), . . . , a(t − 1), z(t )} is a ﬁnite history, i.e., a ﬁnite sequence of action–observation pairs. As before,
the history observed up to time t is a random variable, denoted as H (t ), and we denote by H the set of all possible ﬁnite
histories for the POMDP. Solving a POMDP consists of determining a policy π so as to maximize, for all |X |-dimensional
probability vectors b,
∞

V π (b) = Eπ

γ t r X (t ), A (t )

X (0) ∼ b ,

t =0

where X (0) ∼ b denotes the fact that X (0) is distributed according to b. Similarly, we deﬁne the Q -function associated with
a policy π as
∞

Q π (b, a) = Eπ

γ t r X (t ), A (t )

X (0) ∼ b, A (0) = a .

t =0

We refer to the probability vector b in the expressions above as the initial belief state or just the initial belief. It translates
the “belief ” that the agent has at time t = 0 regarding its state at that time. From the initial belief and given the history up
to time t, H (t ), we can construct a sequence {b(t )} of probability vectors recursively as

b y (t + 1) = Bel b(t ), A (t ), Z (t + 1)

bx (t )P x, A (t ), y O y , A (t ), Z (t + 1) ,

η
x

where Bel is the belief update operator, bx (t ) denotes the x component of b(t ) and η is a normalization factor. We refer to
the vector b(t ) as the belief at time t. It corresponds to a distribution over the unknown state at time t, such that

bx (t ) = P X (t ) = x H (t ) .
Given the POMDP model parameters P and O, every ﬁnite history h ∈ H can be mapped to a belief b. Moreover, for
any given policy, two histories leading to the same belief will yield the same future total expected discounted reward. As
such, beliefs can be used as compact representations of histories, and we can deﬁne policies in terms of beliefs instead of
histories [19]. In fact, it is possible to reinterpret a POMDP as an inﬁnite MDP in which the state space corresponds to the
set of all possible beliefs. Therefore, for any ﬁnite POMDP, there is at least one optimal policy π ∗ , such that
∗

V π (b)

V π (b)

F.S. Melo, M. Veloso / Artiﬁcial Intelligence 175 (2011) 1757–1789

1761

for any π and every initial belief b. The corresponding value function is denoted by V ∗ and also veriﬁes the Bellman
optimality equation,

V ∗ (b) = max

P(x, a, y )O( y , a, z) V ∗ Bel(b, a, z)

bx r (x, a) + γ

a∈A

x

,

z, y

where x, y take values in X , z takes values in Z and Bel(b, a, z) corresponds to the updated belief after taking action a and
observing z. The associated Q -function in turn veriﬁes

Q ∗ (b, a) =

P(x, a, y )O( y , a, z) max Q ∗ Bel(b, a, z), u

bx r (x, a) + γ
x

z, y

u ∈A

.

In spite of their representative power, POMDPs have been shown to be undecidable in the worst case for inﬁnite horizon
settings such as those considered in this paper [20]. As such, exact solutions can be computed only in very speciﬁc instances,
and most approaches in the literature resort to approximate or heuristic methods [21,22].
We now describe an MDP-based heuristic solution method for POMDPs that we use later in the paper. This method is
known as Q MDP as it makes use of the optimal Q -function for the underlying MDP as an estimate for the optimal Q function for the POMDP [23]. Since the optimal solution for the underlying MDP can be eﬃciently computed, this method
is very simple and fast to implement and attains good performance in many practical situations [21,23].
Let M = (X , A, Z , P, O, r , γ ) be a POMDP with ﬁnite state, action and observation spaces. Associated with this POMDP,
¯ = (X , A , P , r , γ ). Let Q¯ ∗ be the optimal Q -function for M
¯ . Q MDP uses an estimate for the
there is an underlying MDP M
optimal Q -function for the POMDP given by

Qˆ (b, a) =

bx Q¯ ∗ (x, a).
x

When using Q MDP , the agent acts under the implicit assumption that state uncertainty only affects the immediate decision,
i.e., after one decision the agent will act on the underlying MDP. Since such assumption seldom holds, Q MDP sometimes
exhibits poor performance and several works have proposed further improvements on Q MDP to address this issue [21,24],
but we do not pursue such discussion here.
2.3. Multiagent MDPs
Multiagent Markov decision processes (MMDPs) generalize MDPs to multiagent cooperative scenarios. MMDPs describe
sequential decision tasks in which multiple agents must each choose an individual action at every time-step that jointly
maximize some common reward-based optimization criterion. Formally, an MMDP is a tuple M = ( N , X , (Ak ), P , r , γ ),
where N is the number of agents, X represents the ﬁnite state space, Ak is the ﬁnite individual action space of agent k.
As in MDPs, P(x, a, y ) represents the transition probability from state x to state y when the joint action a = (a1 , . . . , a N ) is
taken; r (x, a) represents the expected reward received by all agents for taking the joint action a in state x. In an MMDP all
agents receive the same reward, which implies that MMDPs represent fully cooperative multiagent tasks.
A joint action a is a tuple a = (a1 , . . . , a N ) and we denote by A = ×kN=1 Ak the set of all possible joint actions—the joint
action space. For k = 1, . . . , N, we write

A−k = A1 × · · · × Ak−1 × Ak+1 × · · · × A N
to denote the set of joint actions of all agents other than agent k. We write a−k to denote a general element of A−k and
refer to any such action as a reduced joint action or simply a reduced action. We write a = (a−k , ak ) to denote the fact that
the joint action a is composed by the reduced action a−k and the individual action ak for agent k.
We also assume that the state space X can be factored among the N agents as X = X0 × X1 × · · · × X N , where X0
denotes an agent-independent component of the state. As such, each element x ∈ X is a tuple x = (x0 , . . . , x N ), with xk ∈ Xk ,
k = 0, . . . , N. For any x ∈ X , we refer to the pair (x0 , xk ) as the local state of agent k, and generally denote it as x¯ k .
An individual Markov policy for agent k is a mapping πk : X × Ak → [0, 1] such that, for all x ∈ X ,

πk (x, ak ) = 1.
ak ∈Ak

Similarly, a joint policy is a mapping

π : X × A → [0, 1] that we take as the combination of N individual policies, i.e.,

N

π (x, a) =

πk (x, ak ),
k =1

where a = (a1 , . . . , a N ); π−k denotes a reduced policy and π = (π−k , πk ) denotes the fact that the joint policy
by the reduced policy π−k and the individual policy πk for agent k.

π is composed

1762

F.S. Melo, M. Veloso / Artiﬁcial Intelligence 175 (2011) 1757–1789

In an MMDP, the purpose of all agents is to determine a joint policy

π so as to maximize, for all x ∈ X ,

∞

V π (x) = Eπ

γ t r X (t ), A (t )

X (0) = x ,

t =0

where X (t ) denotes the state at time t and A (t ) denotes the joint action taken at time t. The Q -function associated with a
joint policy π is deﬁned from V π as its single-agent counterpart.
For the purposes of planning, i.e., computing the optimal policy, an MMDP is indistinguishable from an ordinary MDP. In
fact, when considering a centralized controller, an MMDP reduces to an MDP. It is only at execution time that an MMDP
differs from an MDP, since the process of decision making is not centralized. However, when we move to partially observable
settings, decentralized execution raises severe diﬃculties even during planning.
2.4. Decentralized POMDPs
Decentralized POMDPs (Dec-POMDPs) are partially observable generalizations of MMDPs. As in MMDPs, the agents in a
Dec-POMDP must each choose an individual action at every time step that jointly maximize some common reward-based
optimization criterion. Unlike MMDPs, however, the agents can only access the global state of the process by means of local
indirect observations. Formally, a Dec-POMDP can be represented a tuple

M = N , (Xk ), (Ak ), (Zk ), P, (Ok ), r , γ ,
where N is the number of agents, X = ×kN=0 Xk is the joint state space, A = ×kN=1 Ak is the set of joint actions, each Zk
represents the set of possible local observations for agent k, P(x, a, y ) represents the transition probabilities from joint
state x to joint state y when the joint action a is taken, each Ok (x, a, zk ) represents the probability of agent k making the
local observation zk when the joint state is x and the last action taken was a, and r (x, a) represents the expected reward
received by all agents for taking the joint action a in joint state x. The scalar γ is a discount factor.
In this partially observable multiagent setting, an individual non-Markov policy for agent k is a mapping πk : Hk → [0, 1]
such that, for all hk ∈ Hk ,

π (hk , ak ) = 1,
ak ∈Ak

where hk = {ak (0), zk (1), . . . , ak (t − 1), zk (t )} is an individual history for agent k, i.e., a sequence of individual action–
observation pairs. Hk is the set of all possible ﬁnite histories for agent k and we denote by H k (t ) the random variable
that represents the history of agent k at time t.
Like in POMDPs, in a Dec-POMDP each agent has only partial perception of the global state. Therefore, from the agent’s
perspective, its local observations are non-Markovian—the current local observation and action are not suﬃcient to uniquely
determine its next observation. In the general multiagent setting, however, there is no compact representation of histories
that plays the role of beliefs in POMDPs, implying that the passage from MMDP to its partially observable counterpart is
fundamentally different from the same passage in single-agent scenarios.2 However, if communication between the agents
is instantaneous, free and error-free, then a Dec-POMDP reduces to a “large” POMDP, and partial observability is no longer
an issue.
Solving a Dec-POMDP consists in determining a joint policy π that maximizes the total sum of discounted rewards.
In order to write this in terms of a function, we consider a distinguished initial state, x0 ∈ X , that is assumed common
knowledge among all agents. We thus want to maximize
∞

V π = Eπ

γ t r X (t ), A (t )

X (0) = x0 .

t =0

Dec-POMDPs constitute one of the most representative models in the decision-theoretic literature [26]. In the remainder
of this section we discuss several specializations of this model that are relevant for this work.
2.4.1. Decentralized MDPs
A decentralized MDP (Dec-MDP) is a particular case of a Dec-POMDP in which, for every joint observation z ∈ Z , there is
a state x ∈ X such that

P X (t ) = x Z (t ) = z = 1.
2
This fact can also be observed by considering the worst-case computational complexity of each of the different models. In ﬁnite horizon settings,
POMDPs are PSPACE-complete, versus the P-completeness of fully observable MDPs [25]. In ﬁnite-horizon multiagent settings, however, Dec-MDPs are
NEXP-complete [16] even in the 2-agent case, versus the P-completeness of MMDPs.

F.S. Melo, M. Veloso / Artiﬁcial Intelligence 175 (2011) 1757–1789

1763

Intuitively, the agents in a Dec-MDP have joint full observability: if all agents share their observations, they can recover the
state of the Dec-MDP unambiguously. This is in contrast with MMDPs where each agent, individually, has full observability.
In fact, MMDPs can be seen as a particular subclass of Dec-MDPs in which the individual observations of each agent allow
it to recover the state of the Dec-MDP/MMDP unambiguously. Formally, for every individual observation zk ∈ Zk , there is a
state x ∈ X such that

P X (t ) = x Z k (t ) = zk = 1.

(5)

Throughout this work, we focus on Dec-MDPs and specializations thereof. Moreover, as with MMDPs, we assume that the
state can be factored and the agents have local full observability, meaning that each agent can infer from its local observations
the corresponding local state unambiguously. Formally local full observability can be translated into the following condition:
for every local observation zk ∈ Zk there is a local state x¯ k ∈ X0 × Xk such that

P X¯ k (t ) = x¯ k Z k (t ) = zk = 1.
Although more general Dec-MDP models are possible [16], we adhere to this simpliﬁed version, as this is suﬃcient for our
purposes. For future reference, we deﬁne the set

X−k = X0 × · · · × Xk−1 × Xk+1 × · · · × X N
corresponding to the local state of all agents other than agent k, and denote by x−k a general element of X−k . As with
actions, we write x = (x−k , xk ) to denote the fact that the kth component of x takes the value xk .
2.4.2. Transition, observation and reward independence
Transition-independent Dec-MDPs constitute a particular subclass of Dec-MDPs in which, for all (x, a) ∈ X × A,

P X 0 (t + 1) = y 0 X (t ) = x, A (t ) = a = P X 0 (t + 1) = y 0 X 0 (t ) = x0 ,
P Xk (t + 1) = yk X (t ) = x, A (t ) = a = P Xk (t + 1) = yk X¯ k (t ) = x¯ k , Ak (t ) = ak .

(6a)
(6b)

The transition probabilities can thus be factorized as
N

P(x, a, y ) = P0 (x0 , y 0 )

Pk (¯xk , ak , yk ),

(7)

k =1

where

P0 (x0 , y 0 ) = P X 0 (t + 1) = y 0 X 0 (t ) = x0 ,
Pk (¯xk , ak , yk ) = P X k (t + 1) = yk X¯ k (t ) = x¯ k , A k (t ) = ak .
This particular class of Dec-MDPs was introduced in [27] and seeks to exploit a particular form of independence to bring
down the computational complexity required to solve such models. In this class of problems, the local state of each agent
constitutes a suﬃcient statistic for its history, and the optimal policy for each agent can thus be computed in terms of this
individual state [12]. This particular class of Dec-MDPs has been shown to be NP-complete in ﬁnite-horizon settings, versus
the NEXP-completeness of general ﬁnite-horizon Dec-MDPs [12].
Similarly, reward-independent Dec-MDPs correspond to a subclass of Dec-MDPs in which, for all x, a,

r (x, a) = f rk (¯xk , ak ), k = 1, . . . , N ,

(8)

i.e., the global reward function r can be obtained from local reward functions rk , k = 1, . . . , N. To ensure consistency of the
decision process, we also require that

f r−k (x−k , a−k ), rk (¯xk , ak )

f r−k (x−k , a−k ), rk (¯xk , uk )

if and only if

rk (¯xk , ak )

rk (¯xk , uk ).

One typical example is
N

r (x, a) =

rk (¯xk , ak ),

(9)

k =1

where x = (x0 , . . . , x N ) and a = (a1 , . . . , a N ). Interestingly, it was recently shown [28,11] that reward independent Dec-MDPs
retain NEXP-complete complexity. However, when associated with transition independence, reward independence implies
that a Dec-MDP can be decomposed into N independent MDPs, each of which can be solved separately. The complexity of
this class of problems thus reduces to that of standard MDPs (P-complete).

1764

F.S. Melo, M. Veloso / Artiﬁcial Intelligence 175 (2011) 1757–1789

Fig. 2. Scenario in Example 1. Two robots must coordinate around a narrow doorway.

3. Decentralized sparse-interaction MDPs (Dec-SIMDPs)
We now depart from the transition-independent Dec-MDP and introduce a new model for multiagent decision problems
that is, at the same time, more general and more speciﬁc than transition independent Dec-MDPs. Our goal is to exploit
sparse interactions among the different agents in a Dec-MDP and so we are interested in Dec-MDPs in which there is some
level of both transition and reward dependency, but this dependency is limited to speciﬁc regions of the state space.
To motivate our proposed model, we start with a simple example that is used throughout the section to illustrate the
several concepts introduced.
Example 1. Consider the scenario depicted in Fig. 2, corresponding to an environment consisting of two rooms of 10 cells
each connected by a narrow doorway D. In this scenario, two mobile robots acting as a team, Robot 1 and Robot 2, must
each navigate from their depicted initial positions to the corresponding goal positions, marked in Fig. 2 with the labels
Goal 1 and Goal 2, respectively. Each robot has available 4 actions, N, S, E, and W that move to the adjacent cell in the
corresponding direction with probability of 0.8, and fail with probability 0.2. In case of failure, the robot remains in the
same cell. Whenever a robot reaches the corresponding goal position, the team is granted a reward of +1. Conversely, if
both robots stand simultaneously in the narrow doorway, corresponding to the cell marked as “D”, the robots bump into
each other and the team is granted a reward of −20. Also, in this situation, the robots get in the way of one another, and
the probability of an individual action failing is 0.4. Each robot is able to perceive unambiguously its own position in the
environment. Also, when both robots simultaneously stand in the shaded area in Fig. 2, they are able to see each other and
can thus perceive their joint state unambiguously.
This problem can be modeled as a Dec-POMDP

M H = 2, (Xk ), (Ak ), (Zk ), P, (Ok ), r , γ ,
where

•
•
•
•
•

Xk = {1, . . . , 20, D}, for k = 1, 2;
Ak = { N , S , E , W }, k = 1, 2;
Zk = Xk ∪ X I , k = 1, 2, where X I = {6, 15, D} × {6, 15, D};
the transition and observation functions can be derived from the description above;
the reward function r is given by

r (x, a) =

⎧
2
⎪
⎨

if x = (20, 9),
if x1 = 20 or x2 = 9,
⎪
−
20
if x = (D, D),
⎩
0
otherwise.
1

The reward function of this example is purposefully designed to include a region in the state space of negative reward where
the two robots must coordinate. Outside this interaction area (say, the shaded region in Fig. 2), each robot can pursue its
own goal, disregarding the existence of other robot.
The Dec-SIMDP model that we introduce explicitly addresses situations in which the interaction between the agents in
a Dec-MDP is localized, much as in Example 1. In order to deﬁne our model that leverages such local interactions, we must
ﬁrst formalize concepts such as agent dependence and agent interaction. These deﬁnitions reﬁne the notions of transition
and reward independence described in Section 2.4.
Let K = {k1 , . . . , km } be a subset of agents in a Dec-MDP. We denote by

X K = X0 × Xk1 × · · · × Xkm

F.S. Melo, M. Veloso / Artiﬁcial Intelligence 175 (2011) 1757–1789

1765

the joint state space of all agents in K . Extending the notation introduced in Section 2, we write X− K to denote the joint
state space of the agents not in K . We write x K to denote a general element of X K and x− K to denote a general element
of X− K . We write x = (x− K , x K ) to distinguish the components of x corresponding to agents in K and those corresponding
to agents not in K .
We assume that the reward function in our Dec-MDP to be decomposed as
MR

N

r (x, a) =

r iI (x K i , a K i ),

rk (¯xk , ak ) +

(10)

i =1

k =1

where each rk corresponds to an individual component of the reward function that depends only on agent k and there
are M R sets, K i , i = 1, . . . , M R , and M R reward components, r iI (the interaction components), each depending on all the
agents in K i and only on these.
Similarly, we assume that the transition probabilities for our Dec-MDP can be decomposed as
MP

N

P(x, a, y ) = P0 (x0 , y 0 )
k =1

1 − I K i (k)IX I (x K i ) Pk (¯xk , ak , yk ) + P0 (x0 , y 0 )
Ki

i =1

P K i (x K i , a K i , y K i )IX I (x K i ),
Ki

(11)

where each X KI includes those states in X K i where the transition probabilities for each of the agents k ∈ K i cannot be
i
factorized as in (7). We write IU (x) to denote the indicator function for set U .
Expressions (10) and (11) explicitly distinguish the components of the reward and transition functions that can be
factorized from those that cannot. The decompositions in (10) and (11) imply no loss of generality, since any reward r
can be trivially written in that form by setting M R = 1, rk ≡ 0, K 1 = {1, . . . , N }, and r1I = r, and the same occurs with the
transition probabilities, by setting M P = 1, K 1 = {1, . . . , N } and P1I = P. However, our interest is not in the general case, but
when the supports of

MR I
r
i =1 i

and P0

small when compared with X × A.

MP
P I
i =1 K i X KI

i

—i.e., the subset of X × A in which these quantities are non-zero—are

Deﬁnition 3.1 (Agent independence). Given a Dec-MDP M, an agent k0 is independent of agent k1 in a state x ∈ X if the
following conditions both hold at state x:

• It is possible to decompose the global reward function r (x, a) as in (10) in such a way that no agent set K i contains
both k0 and k1 .

• It is possible to decompose the transition probabilities P(x, a, y ) as in (11) in such a way that no agent set K i contains
both k0 and k1 .
When any of the above conditions does not hold, agent k0 is said to depend on agent k1 in x. Similarly, agent k0 is independent of a set of agents K = {k1 , . . . , km } at state x if the above conditions hold for all k ∈ K in state x, and dependent
otherwise.
An agent k0 depends on another agent k1 in a particular state if either the reward function or the transition probabilities
or both cannot be decomposed so as to decouple the inﬂuence of each agent’s individual state and action. However, the
dependence relation is not symmetrical: even if agent k0 depends on agent k1 , the reverse need not hold. In fact, it is
possible that the two agents are reward independent and that the transition probabilities from state xk0 depend on the
individual state/action of agent k1 without the reverse holding.
We illustrate the notion of agent independence using Example 1.
Example 1 (Cont.). 1 In the Dec-MDP M H , as previously introduced, it is possible to write the reward function r as

r (x, a) = r1 (x1 , a1 ) + r2 (x2 , a2 ) + r I (x, a),
where r1 (x1 , a1 ) = I20 (x1 ), r2 (x2 , a2 ) = I9 (x2 ) and r I (x, a) = I(D,D) (x). We write Ix (·) to denote the indicator function for
the set {x}. In state (D, D), Robot 1 and Robot 2 both depend on the other, as seen in the transition probabilities. In the
remaining joint states in X , Robot 1 and Robot 2 are independent.
Deﬁnition 3.2 (Agent interaction). In a Dec-MDP M, a set of agents K interact at state x ∈ X if the following conditions all
hold

• For all k0 ∈ K , if agent k0 depends on some agent k1 in state x, then k1 ∈ K .
• For all k1 ∈ K , if there is an agent k0 that depends on agent k1 in state x, then k0 ∈ K .
• There is no strict subset K ⊂ K such that the above conditions hold for K .
If the agents in a set K interact in a state x, then we refer to x K as an interaction state for the agents in K .

1766

F.S. Melo, M. Veloso / Artiﬁcial Intelligence 175 (2011) 1757–1789

The concept of interaction introduced above captures a local dependence between a set of agents in a Dec-MDP. If x K
is an interaction state for the agents in K , this does not mean that each agent k in K depends on all other agents in that
state x. Instead, it means that there is at least one agent in K that either depends on k or k depends on it. Furthermore,
the deﬁnition of agent interaction is transitive: if agents k0 and k1 interact at some state x and agents k1 and k2 interact at
that same state x, then agents k0 and k2 interact at x.
We again resort to Example 1 to illustrate the concept of agent interaction.
Example 1 (Cont.). Robot 1 and Robot 2 interact at state (D, D). In fact, as seen above, not only does Robot 1 depend on
Robot 2, but the converse also holds. Also, there is no strict subset of {1, 2} such that the conditions of Deﬁnition 3.2 hold.
Deﬁnition 3.3 (Interaction area). Consider a general N-agent Dec-MDP M = ( N , (Xk ), (Ak ), (Zk ), P, (Ok ), r , γ ). We deﬁne an
interaction area X I as verifying:
(i) X I ⊂ X K , for some set of agents K ;
(ii) there is at least one state x∗ ∈ X I such that x∗ is an interaction state for the agents in K ;
/ X I,
(iii) for any x ∈ X I , a K ∈ A K and y ∈

P X K (t + 1) = y X K (t ) = x, A K (t ) = a K = P0 (x0 , y 0 )

P(xk , ak , yk );

(12)

k∈ K

(iv) the set X I is connected.3
An agent k is involved in an interaction at time t if there is at least one interaction area X I involving a set of agents K , such
that k ∈ K and X K (t ) ∈ X I . Otherwise, we say agent k is involved in no interaction.
Condition (i) states that each interaction area involves a subset K of the agents in a Dec-MDP. Condition (ii) ensures that
in every interaction area there is at least one interaction state involving all agents in K , to minimize the number of agents
involved in each interaction. Condition (iii) deﬁnes interaction areas as regions of the state space “around” an interaction
state. Finally, condition (iv) states that interaction areas are sets of adjacent states in terms of the transition function.
Unlike interaction states, interaction areas are not disjoint: an agent can be simultaneously involved in an interaction at two
different interaction areas.
Example 1 (Cont.). The joint state (D, D) is an interaction state, corresponding to the situation in which both Robot 1 and
Robot 2 are in the narrow doorway. An interaction area should include the state (D, D) and at least those states immediately
adjacent to it. In fact, in order for the two robots to avoid bumping into each other in the narrow doorway, they must
coordinate before actually reaching the doorway, and hence the inclusion of the neighboring states in the interaction area
associated with this interaction state. In this particular scenario, this corresponds to the shaded area in Fig. 2. For illustration
purposes, we consider X I = {6, 15, D} × {6, 15, D}, although other (larger) sets are also possible.
As required in (i), X I ⊂ X1 × X2 . Also, as required in (ii), (D, D) ∈ X I . Condition (iii) requires that the transition probabilities from states in X I to states not in X I can be factored as in (7). In our scenario, such factorization is not possible only
in state (D, D), but it is also not possible to transition from this state to a state outside X I . This means that condition (iii)
also holds. Finally, X I is connected and condition (iv) also holds.
We exploit the fact that an agent not involved in any interaction should be unaffected by partial joint state observability,
in the sense that its optimal action is the same independently of the state of the other agents. The purpose of deﬁning the
interaction areas in a Dec-MDP is precisely to single out those situations in which the actions of one agent depend on other
agents. As such, when in an interaction area, the agent should use state information from the other agents in the interaction
area to choose its actions. Therefore, we consider scenarios in which all agents in a particular interaction area X I ⊂ X K at
time t have full access to the state X K (t ). We henceforth refer to such a Dec-MDP as having observable interactions.
Deﬁnition 3.4 (Observable interactions). A Dec-MDP has observable interactions, if for any interaction area X I involving a set K
of agents, for each k ∈ K there is a set of local observations ZkI ⊂ Zk such that for every x ∈ X I

P Z k (t ) ∈ ZkI X K (t ) ∈ X I = 1
and, for every zk ∈ ZkI there is a local state x K ∈ X I , such that

P X K (t ) = x K Z k (t ) = zk = 1.
3
A set U ⊂ X is connected if, for any pair of states x, y ∈ U , there is a sequence of actions that, with positive probability, yields a state-trajectory
{x(0), . . . , x( T )} such that x(t ) ∈ U , t = 0, . . . , T , and either x(0) = x and x( T ) = y or vice versa.

F.S. Melo, M. Veloso / Artiﬁcial Intelligence 175 (2011) 1757–1789

1767

Our focus on Dec-MDPs with observable interactions translates a property often observed in real-world scenarios: when
involved in an interaction, agents are often able to observe or communicate information that is relevant for coordination.
Interaction areas encapsulate the need for information sharing in a general multiagent decision problem.
Informally, we say that a Dec-MDP M = ( N , (Xk ), (Ak ), (Zk ), P, (Ok ), r , γ ) has sparse interactions if all agents are independent except in a set of M interaction areas, {X1I , . . . , X MI }, with XiI ⊂ X K i for some set of agents K i , and such that
|XiI |
|X K i |. We refer to a Dec-MDP with sparse, observable interactions as a decentralized sparse-interaction MDP (DecSIMDP).
Deﬁnition 3.5 (Dec-SIMDP). Let M = ( N , (Xk ), (Ak ), (Zk ), P, (Ok ), r , γ ) be a Dec-MDP with sparse observable interactions,
encapsulated in a set of M interaction areas, {X1I , . . . , X MI }, as described above. We represent such a decentralized sparseinteraction MDP (Dec-SIMDP) as a tuple

Γ = {Mk , k = 1, . . . , N },

XiI , MiI , i = 1, . . . , M ,

where

• each Mk is an MDP Mk = (X0 × Xk , Ak , Pk , rk , γ ) that individually models agent k in the absence of other agents,
where rk is the component of the joint reward function associated with agent k in the decomposition in (9);

• each MiI is an MMDP that captures a local interaction between K i agents in the states in XiI and is given by MiI =
( K i , X K i , (Ak ), PiI , r iI , γ ), with XiI ⊂ X K i .
Each MMDP MiI describes the interaction between a subset K i of the N agents, and the corresponding state space X K i is a
superset of an interaction area as deﬁned above.
A Dec-SIMDP is an alternative way of representing a Dec-MDP with observable interactions. For all agents outside interaction areas, the joint transition probabilities and reward function for a Dec-SIMDP can be factorized as in (7) and (9),
and it is possible to model these agents using individual MDPs. In the states of each interaction area in a Dec-SIMDP, and
only in these, the agents involved in the interaction are able to communicate freely. In these areas, the agents can thus use
communication to overcome local state perception and can be modeled using a local MMDP, observing each other’s state
and deciding jointly on their action. Outside these areas, the agents have only a local perception of the state and, therefore,
choose the actions independently of the other agents. A simple, albeit inaccurate, way of thinking of a Dec-SIMDP is as a
Dec-MDP in which each agent has access, at each time step, to all state-information required to predict its next local state
and reward. In fact, a Dec-SIMDP may include states—namely in interaction areas—in which agents are able to perceive joint
state information, not strictly required to predict their next local state and reward. Hence the inaccuracy of the description.
For illustration purposes, we revisit Example 1, using a Dec-SIMDP model to describe the corresponding navigation
problem.
Example 1 (Cont.). The problem depicted in Fig. 2 can be represented as a Dec-SIMDP

Γ = {M1 , M2 }, X I , M I ,
where

• M 1 is an MDP M1 = (X1 , A1 , P1 , r1 , γ ), describing the task of Robot 1 (navigating to Goal 1) in the absence of Robot 2.
X1 and A1 are the same as in the deﬁnition of the original Dec-MDP (see page 1764), P1 and r1 arise from the
decomposition of r and P described in (10) and (11);

• M 2 is an MDP M2 = (X2 , A2 , P2 , r2 , γ ), describing the task of Robot 2 (navigating to Goal 2) in the absence of Robot 1;
• X I is the interaction area already deﬁned;
• M I is an MMDP M I = (2, X , A, P, r I , γ ), that captures the interaction between Robot 1 and Robot 2 in X I .
In this example, there is a unique MMDP M I since there is a single interaction area X I . Also, since there are only two
robots/agents in the environment, the MMDP M I is a fully observable version of the original Dec-MDP M with a simpliﬁed
reward function. In more general scenarios, there will be an MMDP corresponding to each interaction area that includes only
the agents involved in that interaction.
Finally, we explore the relation between the Dec-SIMDP model and the MDP and MMDP models. As expected, in the
absence of any interaction areas, the Dec-SIMDP reduces to a set of independent MDPs that can be solved separately.
A Dec-SIMDP with no interaction areas thus captures the situation in which the agents are completely independent. In
those situations in which all agents interact in all states, as assumed in the general Dec-MDP model, the whole state space
is an interaction area and, as such, our assumption of observable interactions renders our model equivalent to an MMDP.
Nevertheless, the appeal of the Dec-SIMDP model is that many practical situations do not fall in either of the two extreme

1768

F.S. Melo, M. Veloso / Artiﬁcial Intelligence 175 (2011) 1757–1789

cases i.e., independent MDPs vs. fully observable MMDP. It is in these situations that the Dec-SIMDP model may bring an
advantage over more general but potentially intractable models.
We ﬁrst assume interaction areas to be known in advance (i.e., they are provided as part of the model speciﬁcation)
and present a planning algorithm that leverages the particular structure of Dec-SIMDPs in Section 4. In Section 5, we then
discuss how these areas can be determined and an algorithm that allows each agent to learn these interaction areas.
4. Planning in Dec-SIMDPs
We address the problem of planning in Dec-SIMDPs, i.e., estimating the optimal policy for each agent in a Dec-SIMDP
when the model is fully speciﬁed, including the interaction areas.
We start by introducing a general heuristic approach that relies on the solution for an associated POMDP, leading to two
general algorithms, MPSI and LAPSI. We then introduce the concept of generalized α -vectors for Dec-SIMDPs and describe
instances of both MPSI and LAPSI that use generalized α -vectors, discussing the main properties of these methods. The
complete proofs of all results in this section are in Appendix A.
4.1. Heuristic planning in Dec-SIMDPs
We start by considering a Dec-SIMDP in which all except one of the agents have full state observability. We refer to
this agent as agent k and further suppose that the remaining agents (those with full state observability) follow some ﬁxed
known policy, π−k . Agent k can be modeled as a POMDP and the other agents can be collectively regarded as part of the
environment. In this particular situation, any POMDP solution method can be used to compute the policy for agent k.
Our heuristic departs from this simpliﬁed setting and computes a policy for each agent k as if all other agents had full
observability and followed some ﬁxed known policy π−k . This hypothesized policy π−k allows each agent k to approximately
track the other agents and choose its actions accordingly. The closer π−k is to the actual policy of the other agents, the better
agent k is able to track them and select its individual actions. In fact, even if the ability of an agent to track the other agents
necessarily depends on the stochasticity of the environment,4 in our scenarios the determinant factor in the agents’ ability
to maintain a reliable (albeit ﬂat) belief on the state of the other agents depends on how accurate the transition model for
the other agents is, which critically depends on how close π−k is to their actual policy.
Algorithm 1 summarize this general algorithm:
Algorithm 1 Heuristic planning algorithm for Dec-SIMDPs
Require: Dec-SIMDP model Γ ;
1: for all agents k = 1, . . . , N do
2:
Build hypothetical policy πˆ −k ;
3:
Using Γ and πˆ −k , build POMDP model for agent k;
4:
Use preferred POMDP solution technique to compute
5: end for

πk ;

The idea behind Algorithm 1 can be used in general Dec-POMDPs. However, as the hypothesized policy π−k seldom
corresponds to the actual policy followed by the other agents, this method does not allow each agent k to properly track the
other agents and decide accordingly, even if the environment is close to deterministic. Hence this approach is inadequate for
general Dec-POMDPs, where we expect it to lead to poor results. The particular structure of Dec-SIMDPs, however, renders
this approach more appealing because (i) outside of interaction areas, the individual policy of agent k ideally exhibits little
dependence on the state/policy of the other agents. As such, poor tracking in these areas has little impact on the policy of
agent k; and (ii) inside interaction areas, local full observability allows agent k to perfectly track the other agents involved
in the interaction and choose its actions accordingly.
We present two algorithms, Myopic Planning for Sparse Interactions (MPSI) and Look-Ahead Planning for Sparse Interactions (LAPSI), that are particular instances of Algorithm 1 but consider different hypothetical policies for the other agents.
In MPSI, agent k considers each of the other agents as completely self-centered and oblivious to the interactions. Agent k
thus acts as if each agent j, j = k, acts according to a policy π j —the optimal policy for the corresponding MDP M j in the
Dec-SIMDP. In environments with almost no interaction, the MPSI heuristic provides a good approximation to the policy of
the other agents outside the interaction areas.
In LAPSI, agent k considers that all other agents jointly adopt the optimal policy for the underlying MMDP.5 LAPSI is
the counterpart to MPSI, as it provides a good approximation to the policy of the other agents in scenarios where the
interactions are not so sparse.

4
For example, in POMDPs with very stochastic transitions (meaning that transitions out of one state may lead to many states), the beliefs used for
decision-making are often ﬂat, where many states have non-negligible probability.
5
The MMDP associated with the Dec-SIMDP is the MMDP obtained by endowing all agents with global full-state observability.

F.S. Melo, M. Veloso / Artiﬁcial Intelligence 175 (2011) 1757–1789

1769

Using the corresponding hypothesized policies for the remaining agents, MPSI and LAPSI can now leverage any POMDP
solution methods to obtain a policy for each agent k. We now introduce the concept of generalized α -vectors, that we use to
construct particular instances of both MPSI and LAPSI.
4.2. Generalized α -vectors for Dec-SIMDPs
MPSI and LAPSI are described in terms of general POMDP solvers and can be used to compute an individual policy
for each agent in a Dec-SIMDP. We now propose particular instances of both MPSI and LAPSI that exploit the structure
of the Dec-SIMDP model. We depart from the single-agent POMDP model constructed using the proposed approach (see
Algorithm 1) and introduce generalized α -vectors, a simpliﬁcation of the α -vectors used in POMDP solvers [29]. Using the
generalized α -vectors, we derive a variation of the Q MDP heuristic [23] and provide bounds for the performance of this
method when applied to Dec-SIMDPs. We focus on 2-agent scenarios, to avoid unnecessarily complicating the presentation,
remarking that the development presented extends easily to more than two agents only at the cost of more cumbersome
expressions.
Using the POMDP model obtained by adopting the introduced heuristic, agent k computes an individual policy πk that
maps beliefs to actions. However, agent k has full local state observability, implying that the kth component of the state is
unambiguously determined. Furthermore, given our assumption of observable interactions (Deﬁnition 3.4), at each time step
only those state components corresponding to agents not interacting with agent k are unobservable. By deﬁnition, these
state-components do not depend on the state-action of agent k and depend only on π−k .
Recovering the POMDP model for agent k (Section 2),

Q ∗ (b, a) =

P(x, a, y )O( y , a, z) max Q ∗ Bel(b, a, z), u

bx r (x, a) + γ
x

u

z, y

.

Since agent k has full local observability, the belief b concerns only the state component of the other agent,

Q ∗ (¯xk , b−k , a) =

P(x, a, y )O( y , a, z) max Q ∗ y¯ k , Bel(b, a, z), u

bx−k r (x, a) + γ
x−k

u

z, y

.

The other agent is assumed to follow a ﬁxed policy that depends only on the current state, so we can eliminate the explicit
dependence on its action,

Q ∗ (¯xk , b−k , ak ) =

Pπ−k (x, ak , y )O( y , a, z) max Q ∗ y¯ k , Bel(b, ak , z), uk

bx−k rπ−k (x, ak ) + γ
x−k

uk

z, y

,

where

rπ−k (x, ak ) =

π−k (x, a−k )r x, (a−k , ak ) ,
a−k

Pπ−k (x, ak , y ) =

π−k (x, a−k )P x, (a−k , ak ), y .
a−k

Every time step t that agent k is in an interaction area, implying that so is the other agent, agent k can unambiguously
perceive their joint state and hence Z k (t ) = X (t ). In all remaining time steps, Z k (t ) = X¯ k (t ), meaning that the agent observes
M
only its local state. Denoting by X I the set of all joint states in any interaction area, i.e., X I = i =1 XiI ,

Q ∗ (¯xk , b−k , ak ) =

Pπ−k (x, ak , y ) max Q ∗ ( y¯ k , y −k , uk )

bx−k rπ−k (x, ak ) + γ
y ∈X I

x−k

uk

Pπ−k (x, ak , y ) max Q ∗ y¯ k , Bel(b, ak , y¯ k ), uk

+γ

uk

y∈
/XI

.

(13)

We now focus explicitly on the updated belief Bel(·) and the optimal Q -function for the states in the interaction areas.
The general belief-update expression is (Section 2.2)

Bel y b, ak , Z k (t + 1) = η

bx (t )P x, A (t ), y O y , A (t ), Z k (t + 1) .
x

In the current setting, the belief concerns only the distribution over states of the other agent. As such, if X k (t ) = xk , then

Bel y −k b, ak , Z k (t + 1) = η

bx−k (t )Pπ−k x, A k (t ), y −k O y −k , A k (t ), Z k (t + 1) ,
x−k

1770

F.S. Melo, M. Veloso / Artiﬁcial Intelligence 175 (2011) 1757–1789

where x = (x−k , x¯ k ),

Pπ−k (x, ak , y −k ) =

π−k (x, a−k )P−k x−k , (a−k , a), y −k
a−k

and, as in Section 2.4, P−k denotes the transition probabilities corresponding to all except the kth components of the state.
If the agents are not in an interaction area, the transitions of the other agent do not depend on the actions of agent k and
hence

Bel y −k b, ak , Z k (t + 1) = η

bx−k (t )Pπ−k (x, y −k )O y −k , A k (t ), Z k (t + 1) .
x−k

If X (t + 1) is in an interaction area, then agent k can observe the state of the other agent and, as such,

Bel y −k (b, ak , y ) = I X −k (t +1) ( y −k ),
where Ix denotes the indicator function for the singleton set {x}. For the general situation in which X (t + 1) ∈
/ XI ,

Bel y −k (b, ak , y¯ k ) = η

bx−k (t )Pπ−k x, A k (t ), y −k IX c ( y ),

(14)

I

x−k

where, for a general set U ⊂ X , IU is the indicator function for the set U and U c denotes the complement of U in X .
We now consider the expression for Q ∗ (¯xk , b−k , ak ) when the agents are in an interaction area. In this case, b−k = ex−k
for some x−k , where ex is the probability vector where each component y is given by Ix ( y ). This implies that

Q ∗ (¯xk , x−k , ak ) = rπ−k (x, ak ) + γ

Pπ−k (x, ak , y ) max Q ∗ ( y¯ k , y −k , uk )
uk

y ∈X I

Pπ−k (x, ak , y ) max Q ∗ y¯ k , Bel(b, ak , y¯ k ), uk .

+γ

uk

y∈
/XI

(15)

Noting the similarity between the right-hand side of (15) and the term in square brackets in the right-hand side of (13), we
deﬁne a generalized α -vector for agent k, αk , recursively as follows:

αk (x, ak ) = rπ−k (x, ak ) + γ

Pπ−k (x, ak , y ) max αk ( y , uk )IX I ( y )
uk

y

P(¯xk , ak , y¯ k ) max

+γ
yk

uk

Pπ−k (x−k , y −k )αk ( y , uk )IX c ( y ).
I

(16)

y −k

Theorem 4.1. Given a two-agent Dec-SIMDP Γ , the generalized α -vectors associated with agent k when the other agent follows a
ﬁxed and known policy π−k are well deﬁned, i.e., they always exist and are unique.
Proof. (sketch) The complete proof of the theorem is in Appendix A. We introduce a dynamic-programming operator Tk
such that

αk = Tk αk
and show this operator to be a contraction in the sup-norm. The statement in the theorem follows from Banach’s ﬁxed-point
theorem. ✷
The operator Tk is used to iteratively compute the generalized α -vectors, in a way very similar to the value-iteration
algorithm used to compute the optimal Q -function for an MDP. The next result establishes that the generalized α -vectors
associated with a Dec-SIMDP can be computed eﬃciently.
Theorem 4.2. The generalized
polynomial time.

α -vectors for a 2-agent Dec-SIMDP Γ verifying the conditions of Theorem 4.1 can be computed in

Proof. (sketch) The result follows from noting that the generalized
MDP. ✷

α -vectors can be computed by solving an associated

Given that an MDP is a particular case of a Dec-SIMDP in which there is a single agent, for such a Dec-SIMDP the
generalized α -vectors correspond exactly to the optimal Q -values. It then follows from Theorem 4.2 that computing the
generalized α -vectors for a Dec-SIMDP is P-complete.

F.S. Melo, M. Veloso / Artiﬁcial Intelligence 175 (2011) 1757–1789

1771

All results extend to scenarios with more than two agents. For example, the deﬁnition in (16) takes the more general
form

αk (x, ak ) = rπ−k (x, ak ) + γ

Pπ−k (x− O , y − O )αk ( y , uk ),

Pπ−k (x O , ak , y O ) max
uk

yO

y− O

where y = ( y O , y − O ), for y ∈ X . The components y O correspond to the observable components of y—those that belong to
agents involved in an interaction with agent k—and y − O correspond to the remaining components.
4.3. Generalized α -vectors in LAPSI and MPSI
We now use the generalized

Qˆ (¯xk , b−k , ak ) =

α -vectors to compute estimates Qˆ (b, ak ) of the optimal Q -function for agent k,

bx−k αk (x, ak ).

(17)

x−k

This approximation shares several features with the Q MDP heuristic (Section 2.2), since we compute the generalized α vectors for a Dec-SIMDP by solving an associated MDP. One would thus expect our methods to suffer in states of great
uncertainty, much like Q MDP does. In these states, action selection may be conservative but our assumed sparse interactions
will hopefully minimize the effects of this situation. Our experimental results indicate that this may indeed be the case.
We now derive error bounds for the approximation in (17) that depend only on the dispersion of the maximum values
of the generalized α -vectors outside the interaction areas. This result can be extended to general POMDPs, providing error
bounds for the Q MDP heuristic that depend only on the optimal Q -function for the underlying MDP.
Given a generalized α -vector αk (x, ak ), let x O denote the observable components of x—those corresponding to agents
interacting with k at x¯ k —and x− O the remaining components. We deﬁne the dispersion of a set of α -vectors α k (x, ak ), with
x ∈ X and ak ∈ Ak , as
k

αk (x O , x− O ), uk −

= max max
xO

uk

x− O

max αk (x O , x− O ), uk .
x− O

uk

(18)

The dispersion of a set of α -vectors measures how the maximum value of αk taken over all actions differs from the
corresponding average in the non-observable components of the state. The dispersion quantiﬁes how the lack of knowledge
of agent k on the state of the other agents can impact the action choice of agent k in terms of value.
Theorem 4.3. Let M = ({Mk , k = 1, . . . , N }, {(XiI , MiI ), i = 1, . . . , M }) be a Dec-SIMDP and let πk denote the policy for agent k
obtained from the approximation (17) when the policy π−k for the other agents is ﬁxed and known. Then,

V ∗ − V πk ∞
where

k

2γ 2

(1 − γ )2

(19)

k,

represents the dispersion of the α -vectors associated with π−k .

Proof. See Appendix A.

✷

Theorem 4.3 translates well-known bounds for approximate policies to our particular setting. As expected, the bound
in (19) is proportional to the total dispersion of the generalized α -vectors. Also, the bound in (19) is zero if either

• The whole state space is an interaction area, i.e., X I = X . In this case, we recover the MMDP version of the problem
(Section 3).

• There are no interaction states, i.e., X I = ∅. In this case, the generalized α -vectors for agent k do not depend on the
other agents, implying that k = 0.
Finally, the above bounds assume that the policy hypothesized for the other agents corresponds to their actual policy, which
is not the case in either MPSI and LAPSI. In particular, deﬁning the errors in rπ−k and Pπ−k , arising from the imperfect
knowledge of π−k , as

εr = rπ−k − rπˆ −k

∞,

εP = Pπ−k − Pπˆ −k

∞,

we ﬁnally get

V ∗ − V πk ∞

2γ 2

(1 − γ

)2

k

+

εr + γ εP
,
1−γ

(20)

1772

F.S. Melo, M. Veloso / Artiﬁcial Intelligence 175 (2011) 1757–1789

where the ﬁrst term corresponds to the approximation error of the POMDP policy, and the second term corresponds to the
approximation error of the policy of the other agents.
The error bounds in (20) are generally loose—as known similar bounds for MDPs are also loose. However, in our view, the
most interesting aspect of the proposed bounds arises from the deﬁnition and identiﬁcation of the dispersion of generalized
α -vectors, on which those bounds critically depend.
Using the generalized α -vectors in LAPSI and MPSI is now straightforward. Both methods use the estimate in (17) to
choose the action for agent k. The difference between the two methods lies on the policy π−k hypothesized for the other
agents, needed to both track the belief b−k and to compute the α -vectors. In MPSI, π−k is taken as the reduced policy
obtained from the individual policies π j , j = k, the optimal policy for the corresponding MDP M j in the Dec-SIMDP. In
LAPSI, π−k is obtained from the optimal policy for the underlying MMDP by ignoring component k.
For illustration purposes, we apply both of these methods to several problems of different dimension, using (17) as
our estimate for the POMDP optimal Q -function. As discussed above, the estimate in (17) corresponds to a variation of the
Q MDP heuristic. Our results indicate that, even using such a sub-optimal POMDP solver, LAPSI is able to attain a performance
close to optimal in all test scenarios while incurring a computational cost similar to that of solving the underlying MMDP.
MPSI, while computationally more eﬃcient, seems to lead to agents that excessively avoid interactions. We also compare
our algorithms with a previous algorithm for Dec-SIMDPs, the IDMG algorithm [30]. Our results indicate that LAPSI is able
to attain similar performance to that of IDMG while providing signiﬁcant computational savings. We also show that the
IDMG algorithm is, by design, unable to consider future interactions when planning outside the interaction areas, which
leads to poor performance. Such limitation is not present in LAPSI.
4.4. Results
To gain a better understanding of the applicability and general properties of our methods, we compared the performance
of both MPSI and LAPSI to those of individual agents that plan disregarding other agents in the environment and of the
optimal fully observable MMDP policy. We also tested the performance of the IDMG algorithm, previously introduced as
an heuristic planning algorithm for Dec-SIMDPs [30]. It was empirically shown that this algorithm attains near-optimal
performance on several scenarios, and we use the results obtained with this approach as a benchmark against which we
compare the performance of LAPSI and MPSI. We brieﬂy describe the IDMG algorithm and outline the main differences
between this approach and those presented in this article.
4.4.1. The IDMG algorithm
Let Γ = ({Mk , k = 1, . . . , N }, {(XiI , MiI ), i = 1, . . . , M }) denote an N agent Dec-SIMDP. Let Q k∗ denote the optimal Q function associated with each of the MDPs Mk in Γ . Similarly, let Q iI denote the joint optimal Q -function associated with
the MMDP MiI in Γ . IDMG proposes to use these two sets of functions, { Q k∗ , k = 1, . . . , N } and { Q iI , i = 1, . . . , M }, as
follows:

• At every time step t for which an agent k is involved in no interaction, it follows the greedy policy with respect to Q k∗ ,
i.e.,

πk (xk ) ∈ arg max Q k∗ (xk , ak ).
ak ∈Ak

• Otherwise, let O denote the set of all agents interacting with k at time step t. For each k ∈ O , and all x ∈ X , let
M

Q¯ k (x, a) = Q k∗ (¯xk , ak ) +

Q iI (x K i , a K i )IX K (x K i ).
i

i =1

For each x ∈ X , Q¯ k (x, ·) combines Q k∗ (x, ·) with the joint Q -functions associated with all interactions of agent k in
state x.
Since these functions are different for each agent k ∈ O , at each time-step t IDMG adopts a game-theoretic approach
and constructs a matrix game

Γ X (t ) = | O |, (Ak ), (qk ) ,
involving all agents in O . Each payoff function qk is given by
M

P(x O , a O , y O )Nashk Q¯ k ( y O , ·), k ∈ O ,

r iI (x K i , a K i )IX K (x K i ) + γ

qk (a O ) = rk (¯xk , ak ) +
i =1

i

y O ∈X O

where X (t ) = x and Nashk is a max-like operator denoting the Nash value for agent k with respect to the game deﬁned
by the matrices Q¯ k in state y O . Finally, at every time step t for which agent k is involved in some interaction, it chooses
its action according to the Nash equilibrium for the game Γ X (t ) .

F.S. Melo, M. Veloso / Artiﬁcial Intelligence 175 (2011) 1757–1789

1773

Table 1
Distinction between different methods used for comparison in terms of planning and prescribed policies.
Policy

Planning

In int. areas

Outside int. areas

IDMG
MPSI
LAPSI
Indiv.
Opt.

Equilibrium
MDP (hyp.)
MMDP (hyp.)
–
MMDP

Equilibrium
POMDP
POMDP
MDP
MMDP

MDP
POMDP
POMDP
MDP
MMDP

There are two important distinctions between the IDMG algorithm and LAPSI/MPSI. Outside interaction areas, IDMG is
oblivious to the existence of other agents in the environment, i.e., it never considers the effect that future interactions may
have in its performance. This, as will soon be apparent, leads to situations in which IDMG may perform arbitrarily poor.
A second signiﬁcant difference concerns the use of a game-theoretic solution to resolve the interactions that requires the
computation of multiple equilibria. Computing equilibria is known to be a computationally demanding problem, which lead
to a very signiﬁcant computational advantage to LAPSI/MPSI, as will also become apparent from the results.
Table 1 summarizes the main distinctions between the different methods used for comparison. For each method, the
second column indicates which policy is hypothesized for the other agents during planning. The third column corresponds
to the policy prescribed by that method in interaction areas, and the last column corresponds to the policy prescribed
outside interaction areas. During planning, IDMG assumes the other agents adopt an equilibrium solution in interaction
areas and prescribes this same policy in those areas. Outside interaction areas, IDMG follows an individual MDP policy
that disregards the other agents. During planning, LAPSI and MPSI assume the other agents to follow the joint MMDP and
individual MDP policies, respectively. Both methods then construct a POMDP for planning, whose policy is then followed
inside and outside interaction areas. Individual agents do not consider other agents during planning and always follow an
individual MDP policy. The optimal agents assume that the other agents follow the joint MMDP policy during planning and
then adopt that same policy.
4.4.2. Experimental setup
Fig. 3 depicts the different scenarios used to test our algorithm. The reason for using navigation scenarios is that the
Dec-SIMDP model appears particularly appealing for modeling multi-robot problems. Furthermore, in this class of problems,
the results can easily be visualized and interpreted. In each of the test scenarios, each robot in a set of two/four robots must
reach one speciﬁc state. In the smaller environments (Fig. 3a through 3d), the goal state is marked with a boxed number,
corresponding to the number of the robot. The cells with a simple number correspond to the initial states for the robots.
In the larger environments (Fig. 3e through 3j), the goal for each robot is marked with a cross and the robots each depart
from the other robot’s goal state, in an attempt to increase the possibility of interaction.
Each robot has 4 possible actions that move the robot in the corresponding direction with probability 0.8 and fail with
probability 0.2, leaving the state of the robot unchanged. The shaded regions correspond to interaction areas, inside of which
the darker cells correspond to interaction states. When two or more robots stand in one of these cells simultaneously, they
both get a penalty of −20. Upon reaching the corresponding goal, each agent receives a reward of +1. In all experiments
we used γ = 0.95.
Table 2 summarizes the dimension of the joint state space for the corresponding Dec-MDP. For comparison purposes,
Table 2 also includes the number of interaction states and the number of states in the individual MDPs that give an idea of
the number of states in the corresponding Dec-SIMDP model.
4.4.3. Description and discussion of results
For each of the different scenarios in Fig. 3, we run the algorithms in Table 1 and test the obtained policies for 1000
independent Monte Carlo trials. Each trial lasts for 250 time steps.
Except for the individual agents, all methods are able to completely avoid miscoordinations in all tested scenarios. Table 3
summarizes the average number of miscoordinations for the individual agents. The results in Table 3 provide a hint on the
coordination needs for the different environments. For example, environments such as cit or suny require no coordination
at all, while Map 4 (Fig. 3d) requires signiﬁcant coordination. Tables 4 and 5 present comparative results in terms of total
discounted reward and steps-to-goal. Performance results for the IDMG algorithm in Map 4 (Fig. 3d) are not available, since
the complexity of this particular instance prevented the method from providing solutions in practical computational time.
The LAPSI algorithm performs very close to the optimal MMDP policy in all environments, in spite of the signiﬁcant difference in terms of state information available to both methods. Also, in most scenarios, LAPSI and IDMG perform similarly,
both in terms of total discounted reward and in terms of steps-to-goal. The only exceptions are Map 2, where LAPSI outperforms IDMG, and ISR, where IDMG outperforms LAPSI. Interestingly, however, the difference in terms of time-to-goal in
the ISR environment is not signiﬁcant. Our results agree with previous ones that showed that IDMG attains close-to-optimal
performance in most scenarios considered here [30].
Interestingly, in the ISR scenario alone, the individual agents are actually able to outperform the Dec-SIMDP planning
methods. Observing the results in terms of steps-to-goal, we conclude that in this particular scenario the Dec-SIMDP planning methods take longer to reach the goal, an indication that they may be attempting to avoid miscoordinations at a cost of

1774

F.S. Melo, M. Veloso / Artiﬁcial Intelligence 175 (2011) 1757–1789

Fig. 3. Environments used in the experiments.

Table 2
Dimension of the different test scenarios. The number of joint states in a scenario involving N agents in an environment described by
a map with M cells is given by M N .
Environment
Map 1
Map 2
Map 3
Map 4
cit
cmu
isr
mit
pentagon
suny

# Joint states
441
1296
400
65,536
4900
17,689
1849
2401
2704
5476

# States in inter. areas

# MDP states

9
36
18
1188
153
714
203
192
113
287

21
36
20
16
70
133
43
49
52
74

(×2)
(×2)
(×2)
(×4)
(×2)
(×2)
(×2)
(×2)
(×2)
(×2)

F.S. Melo, M. Veloso / Artiﬁcial Intelligence 175 (2011) 1757–1789

1775

Table 3
Number of miscoordinations for the individual
agents in each of the test scenarios. The results are
averaged over 1000 independent Monte Carlo trials. For each environment, bold entries correspond
to optimal values (differences from optimal are not
statistically signiﬁcant).
Environment

Indiv.

Map 1
Map 2
Map 3
Map 4
cit
cmu
isr
mit
pentagon
suny

0.409
0.239
0.280
1.943
0.000
0.249
0.004
0.010
0.120
0.000

Table 4
Total discounted reward for each of the four different algorithms in each of the test scenarios. The results are averaged over 1000 independent Monte
Carlo trials. For each environment, bold entries correspond to optimal values (differences are not statistically signiﬁcant). Italic entries correspond to values
whose differences are not statistically signiﬁcant.
Environment

IDMG

MPSI

LAPSI

Indiv.

Opt.

Map 1
Map 2
Map 3
Map 4
cit
cmu
isr
mit
pentagon
suny

12.035
10.672
13.722
–
11.178
2.839
14.168
6.663
16.031
11.161

11.130
10.159
13.249
15.384
11.105
2.688
13.937
6.641
15.162
11.130

11.992
10.947
13.701
15.564
11.126
2.824
13.997
6.648
15.976
11.139

5.919
7.423
9.378
−4.741
11.120
0.982
14.301
6.628
14.167
11.144

12.059
11.108
13.837
16.447
11.128
2.840
14.407
6.705
16.016
11.149

Table 5
Steps-to-goal for each of the four different algorithms in each of the test scenarios. The results are averaged over 1000 independent Monte Carlo trials.
For each environment, bold entries correspond to optimal values (differences are not statistically signiﬁcant). Italic entries correspond to values whose
differences are not statistically signiﬁcant.
Environment

IDMG

MPSI

LAPSI

Indiv.

Opt.

Map 1
Map 2
Map 3
Map 4
cit
cmu
isr
mit
pentagon
suny

11.021
13.368
8.450

12.752
14.433
9.282
6.088
12.552
49.341
8.986
24.507
19.684
12.500

11.091
12.828
8.477
6.071
12.514
39.444
8.012
22.618
5.416
12.487

9.964
12.494
7.529
6.292
12.526
38.880
7.500
22.329
5.008
12.477

10.977
12.546
8.267
5.001
12.512
39.340
7.440
22.444
5.365
12.469

−
12.422
39.338
7.993
22.578
5.348
12.448

reaching the goal later, this slightly impacting their performance. However, in most other scenarios, the performance of the
individual agents is signiﬁcantly worse than that of all other methods. The difference is more noticeable in those scenarios
where coordination is more critical.
Another interesting observation is that MPSI typically performs worse than the other methods. Since an agent in MPSI
considers the other agents to disregard the consequences of miscoordinations (each is focused only on its individual goal),
it is expected that the agent following MPSI is more “cautious” and hence the observed longer time to the goal. To see
why this is so, consider for example the environment in Map 1, in which the two agents cannot simultaneously cross the
narrow passage. If the agents ﬁnd each other in opposite sides of the passage, one of them must make way to the other. In
MPSI, each agent k assumes that the other agent will not deviate and, as such, agent k will cautiously deviate. This means
that, in this case, both agents will deviate. Both agents will eventually move across the narrow passage, but the cautious
decision-process causes delays and impacts the total reward received, as seen in Table 5. In LAPSI the agents are implicitly
following coordinated policies, so the delays observed in MPSI do not occur.
In our results, the difference in performance between both LAPSI and IDMG and the optimal MMDP policy occurs both
in terms of total discounted reward and in terms of steps-to-goal. Given the discount factor γ , the latter in part explains

1776

F.S. Melo, M. Veloso / Artiﬁcial Intelligence 175 (2011) 1757–1789

Fig. 4. Computation time for the different algorithms as a function of the problem dimension, corresponding to the number of joint states reported in the
second column of Table 2.

the former: if the agents take longer to reach their goal, the corresponding reward is further discounted. The above results
thus indicate that both our algorithms and the IDMG algorithm require more time to reach the goal conﬁguration than that
needed by MMDP solution, and this time is spent in avoiding the penalties. Also, the choice of interaction areas greatly
inﬂuences the ability of the algorithms to avoid penalties without incurring any delays in reaching the goal.6
Since IDMG requires the computation of several equilibria both in the off-line planning phase and in the on-line running
phase, the computational complexity of the IDMG algorithm may quickly become prohibitive, in scenarios with large action

6

This was already reported in [30] concerning the IDMG algorithm.

F.S. Melo, M. Veloso / Artiﬁcial Intelligence 175 (2011) 1757–1789

1777

Fig. 5. Example scenario where avoiding the interaction may be beneﬁcial.

Table 6
Estimated error bounds for the different environments.
Environment

MPSI

LAPSI

Map 1
Map 2
Map 3
cit
cmu
isr
mit
pentagon
suny

7.248
9.826
13.019
38.153
98.059
78.229
54.701
21.586
54.856

3.683
5.717
6.436
20.792
44.586
44.406
32.704
21.369
28.723

spaces and/or with many interaction areas. We compare the computational effort of our methods with that of IDMG, both
in terms of the average off-line computation time and the on-line computation time. Fig. 4 summarizes these results.
Both MPSI and LAPSI are signiﬁcantly more computationally eﬃcient than the IDMG algorithm according to either of the
two performance metrics. It is also interesting to note how the average computation times evolve with the dimension of
the problem: while the computation time for both MPSI and LAPSI grows linearly with the dimension of the problem,
the computation time of IDMG also depends on the number of interaction areas and hence the irregular growth pattern
observed in Fig. 4.
Finally, the IDMG method is, by construction, unable to consider future interactions when planning for the action in a
non-interaction area. In this sense, the IDMG algorithm is “myopic” to such interactions and only handles these as it reaches
an interaction area, which can have a negative impact on the performance of the method.
Consider the scenario depicted in Fig. 5. Once again, the two robots must reach the marked states while avoiding simultaneously crossing the narrow pathways. We model this problem using a Dec-SIMDP: the two sets of shaded cells represent
two interaction areas in which the robots only get a non-zero penalty by standing simultaneously in the darker state. In this
environment, and ignoring the interaction, Robot 1 can reach its goal by using either of the narrow pathways, since both
trajectories have the same length. However, Robot 2 should use the upper pathway, since it is signiﬁcantly faster than using
the lower pathway.
By using the IDMG algorithm, Robot 2 goes to the upper pathway while Robot 1 chooses randomly between the two,
for example, the upper pathway. In this case, according to the IDMG algorithm, both robots reach the interaction area
simultaneously and Robot 1 must move out of the way for Robot 2 to go on. Therefore, Robot 1 takes 10 steps to reach
Goal 1 while Robot 2 takes 8 steps to reach Goal 2, for an average of 9 steps to reach the goal. If, instead, Robot 1 takes
the lower pathway, the two robots reach their goal states in 8 steps each. The IDMG algorithm chooses between these two
possibilities randomly—or, at least, has no way to differentiate between the two. Therefore, IDMG agents take an average
of 8.5 steps to reach their goal. We ran 1000 independent trials using the IDMG algorithm in this scenario and, indeed,
obtained an average of 8.485 steps-to-goal, with a standard deviation of 0.5.
For comparison purposes, we also ran 1000 independent trials using the LAPSI algorithm in this same scenario. Out of
1000 trials, Robot 1 always picked the lower pathway and the group took an average of 8 steps-to-goal with a variance of 0.
This difference could be made arbitrarily large by increasing the “narrow doorway” to an arbitrary number of states, thus
causing an arbitrarily large delay.
We conclude this section by providing Table 6 with the value of the bounds from Theorem 4.3 for some of the test
environments. Although these bounds are generally loose, they still provide insights on some properties of our methods.
The error bounds for MPSI are, in general, larger than those for LAPSI, since the policy estimate for MPSI is, in most
scenarios, more crude than that of LAPSI. Moreover, although the bounds exhibit some dependency on the dimension of the
problem—larger scenarios tend to have larger bounds,—this is not always the case. For example, while Map 3 is smaller than
Map 2, the corresponding bounds are actually larger. Also, ISR is much smaller than CMU but the corresponding bounds are
approximately similar.

1778

F.S. Melo, M. Veloso / Artiﬁcial Intelligence 175 (2011) 1757–1789

5. Learning interaction areas
In the previous sections we introduced the Dec-SIMDP model and proposed the MPSI and the LAPSI planning algorithms,
both able to leverage the sparse interactions in Dec-SIMDPs to overcome the computational burden associated with more
general decision-theoretic models. The Dec-SIMDP model relies on the concept of interaction areas that capture local dependences between groups of agents. These interaction areas include non-interaction states that nevertheless improve the
coordination performance of the agent group. We now introduce a learning algorithm that learns those interaction areas.
We start by considering the simple case of a 2-agent transition-independent MMDP given by M = (2, X , (Ak ), P, r , γ )
where, as before, r is decomposable as

r (x, a) = r1 (x1 , a1 ) + r2 (x2 , a2 ) + r I (x, a),
where rk corresponds to the individual component of the reward function associated with agent k and r I is the joint component of the reward function. If r I ≡ 0, each agent can use standard Q -learning to learn its optimal individual policy πk∗ ,
and the policy π ∗ = (π1∗ , π2∗ ) is optimal for M. However, if r I (x, a) = 0 in some state x, the policy learned by each agent
using Q -learning and disregarding the existence of the other agent is generally suboptimal [31,32]. The optimal policy in
that case must take into account whatever the other agent is doing.
When moving to a Dec-MDP setting, the situation in which r I ≡ 0 poses no additional diﬃculties, as the problem can still
be decomposed into independent single-agent MDPs. If the interaction between the two agents is sparse, we expect each
agent to coordinate only around those states x for which r I (x, a) = 0—the interaction areas. This coordination may require
each agent to have access to state and action information about the other agent. Therefore, interaction areas should comprise
the states in which information on the joint state brings improvements in performance over local-state information.
In general, the performance obtained using joint state information in all time steps is never worse than that obtained
using this information only at certain situations. However, since we are interested in determining the interaction areas, we
are only interested in states in which this information brings an improvement in performance. To this purpose, we add
an artiﬁcial penalty every time the agent uses joint state information, to ensure that the latter is only used when actually
useful.
We augment the individual action space of each agent with one pseudo-action, the Coordinate action, that incurs the
aforementioned penalty and consists of two steps:
1. An active perception step, in which the agent tries to determine the local state information of the other agent;
2. A coordinating step, in which the agent makes use of the local state information from the other agent, if available, to
choose one of its primitive actions.
The active perception step of the Coordinate action may not succeed; whether or not it actually succeeds is environment
dependent. Considering once again a multi-robot navigation scenario, the active perception step can consist for example of
the use of an onboard camera to localize the other robot. In this case, the robot is able to localize the other robot only
when the latter is in its ﬁeld-of-view. Another possibility consists of the use of explicit wireless communication, in which
one robot requires the other robot to share its location.
Going back to our algorithm, each agent k uses standard Q -learning to estimate Q k∗ (¯xk , ak ) for all local states x¯ k and
all ak ∈ Ak ∪ {Coordinate}. The role of the coordinating step is to use the local state information from the other agent,
provided by the active perception step, to guide the actual choice of the actions in Ak . To this purpose, each agent k keeps
an estimate of a second Q -function, the interaction Q -function Q kI , deﬁned in terms of the immediate reward of agent k
and the value of agent k’s policy. Since this policy is deﬁned in terms of Q k∗ , the values of Q kI at different state-action pairs
are independent, i.e.,

Pka (¯xk , y¯ k ) max Q k∗ ( y¯ k , bk ).

Q kI (x, a) = rk (x, ak ) + γ
y¯ k ∈Xk

bk ∈Ak

The above relation can be used in a Q -learning-like update to estimate the value Q kI associated with each individual action
ak ∈ Ak in each joint state (x1 , x2 ).
Algorithm 2 summarizes our algorithm; π is the learning policy i.e., a policy that ensures suﬃcient exploration, such
as an ε -greedy policy, and by π g ( Q , ·) the greedy policy with respect to function Q . The ﬂag ActivePercept is true if the
active perception step is successful and the general instruction QLUpdate( Q ; x, a, r , y , Q ) denotes the general Q -learning
update deﬁned in Section 2.1.
The update of Q kI uses the estimates of Q k∗ , as the individual action at the next step depends on the values in Q k∗ and
not on Q kI . Hence, the values in Q kI only determine the one step behavior of the Coordinate action, and therefore there
is not a direct dependency among entries in Q kI corresponding to different states/actions (Fig. 6). Such independence is
particularly useful as it implies that, unlike algorithms that learn directly on the joint state-action space, our matrix Q kI is
sparse—i.e., the number of non-zero elements is small—and thus requires a similar sample complexity as that necessary to
learn Q k∗ .

F.S. Melo, M. Veloso / Artiﬁcial Intelligence 175 (2011) 1757–1789

1779

Algorithm 2 Learning algorithm for agent k
Require: Learning policy π

1: Initialize Q k∗ and Q kI ;
2: Set t = 0;
3: while (FOREVER) do
4:
Choose A k (t ) using π ;
5:
if A k (t ) = COORDINATE then
6:
if ActivePercept = TRUE then
ˆ k (t ) = π g ( Q I , X (t ));
7:
A
k
8:
else
ˆ
A k (t ) = π g ( Q k∗ , X¯ k (t ));
9:
10:
end if
11:
Sample R k (t ) and X¯ k (t + 1);
12:
if ActivePercept = TRUE then
QLUpdate( Q kI ; X (t ), Aˆ k (t ), R k (t ), X¯ k (t + 1), Q k∗ );
13:
14:
end if
15:
else
16:
Sample R k (t ) and X¯ k (t + 1);
17:
end if
QLUpdate( Q k∗ ; X¯ k (t ), Ak (t ), R k (t ), X¯ k (t + 1), Q k∗ );
18:
19:
t = t + 1;
20: end while

Fig. 6. Illustration of the dependence between the global Q -function, Q k∗ , and the local Q -function, Q kI .

Also, the Coordinate action does not use any joint action information, only joint state information. This fact and the
aforementioned independence of the components of Q kI associated with different x¯ k makes the learning of Q kI similar to a
generalized ﬁctitious play process [33]. However, in scenarios where the action information from other agents is necessary
for coordination, our algorithm may exhibit poor performance.
So far we have described how to apply our learning algorithm to 2-agent MMDPs. In MMDPs with N > 2 agents, and
since the local state information from the other agents arises from an active perception step, each agent can only perceive
the local state information concerning one other agent. Therefore, in problems for which coordination requires state information concerning more than two agents, the performance of our algorithm is expected to decrease. Another implication
is that we can apply Algorithm 2 without modiﬁcation, by disregarding the identity of the other agent and merely considering that the local information obtained by active perception concerns some other agent. However, if we consider more
general active perception processes—i.e., the agent is actually able to perceive the state of all other agents—the algorithm
can be trivially modiﬁed to address coordination of any number of agents, with an obvious tradeoff in terms of the memory
requirements of the algorithm.
5.1. Results
We apply our learning algorithm to the test scenarios in Fig. 3, where we include an individual penalty of −0.1 in all
scenarios every time an agent uses the Coordinate action. The excessive use of such Coordinate action impacts the sparsity
of Q kI , which is undesirable for large problems.
We run our learning algorithm in each of the test environments. Table 7 summarizes the number of learning steps
allowed in each environments. During learning, exploration is ensured by combining a greedy policy with optimistic initial
values [34]. We use an initial learning rate of α = 0.1. Every 2 × 104 time steps, this rate is updated as α ← 0.1 × α . For
comparison purposes, we also run:

• One instance of single-agent Q -learning for each robot, in the absence of other robots in the environment. The robots
thus learn how to reach their goal but not how to avoid miscoordination, since there are no other robots in the environment during the learning stage and hence the learner never actually experiences the miscoordination penalty.
• One instance of single-agent Q -learning for each robot, in the presence of other robots in the environment. The robots
thus learn how to best reach their goal while avoiding interaction using only individual state information. Due to the

1780

F.S. Melo, M. Veloso / Artiﬁcial Intelligence 175 (2011) 1757–1789

Table 7
Number of time-steps used for learning in each of the test
environments.
Environment

Learning steps

Map 1
Map 2
Map 3
cit
cmu
isr
mit
pentagon
suny

104
105
104
5 × 105
2 × 105
5 × 105
2 × 105
3 × 105
2 × 105

Table 8
Distinction between different learning approaches used for comparison. The second and third columns indicate whether learning and
test are conducted in the presence or absence of other agents. The last column indicates state observability.
Approach

Learning

Test

State observability

Indiv.
Non-coop.
Coop.
Opt.

Single
Multiple
Multiple
Multiple

Multiple
Multiple
Multiple
Multiple

Local
Local
Local + Active perc.
Global

Table 9
Total discounted reward for each of the four different algorithms in each of the test scenarios. The results are averaged over 1000 independent Monte Carlo
trials. For each environment, bold entries correspond to optimal values (differences are not statistically signiﬁcant).
Environment

Indiv.

Non-coop.

Coop.

Opt.

Map 1
Map 2
Map 3
Map 4
cit
cmu
isr
mit
pentagon
suny

2.826
1.607
5.470
−3.180
9.790
−1.319
10.695
6.554
14.676
11.167

3.046
4.487
7.002
0.000
11.002
0.910
14.296
6.666
12.918
11.104

6.304
9.957
7.171
4.229
11.112
1.630
14.258
6.502
16.554
11.135

12.059
11.108
13.837
16.447
11.128
2.840
14.407
6.705
16.016
11.149

general lack of knowledge about the global state, the agents in this second comparison set correspond to independent
learners in the sense of [31].
Table 8 summarizes this information. The second and third columns show whether learning and testing are conducted in
the presence or absence of other agents (corresponding to the labels “Multiple” and “Single”, respectively). The last column
indicates whether the agents have access to only local state information, global state information or, in the case of our
method, local state information complemented by state information from the active perception step of the Coordinate
action.
We evaluate each of the learned policies in the different environments, performing 1000 independent Monte Carlo trials.
Each trial lasts for 250-time-steps, during which each learned policy (Indiv., Non-coop., and Coop.) is evaluated in the
original problem, i.e., with two/four robots moving simultaneously in the environment. For comparison, we also present the
results obtained with the optimal fully observable MMDP policy from Section 4. However, since the framework considered
here is different from that considered in Section 4, the results from the optimal MMDP policy cannot be used for direct
comparison, but only as a reference to better assess the performance of the learning methods. Table 9 presents the results
in terms of total discounted reward.
The results in Table 9 show that our algorithm generally outperforms the two other learning methods, matching the
optimal MMDP policy in some of the test scenarios. However, the behavior of the different algorithms varies in the different
scenarios. For example, individual agents never experience miscoordination penalties during learning. Therefore, they act as
if such penalty does not exist, which impacts negatively the total discounted reward they receive as seen, for example, in
Map 2. The non-cooperative agents experience miscoordination penalties during learning and are better able to avoid them,
although their lack of joint state information prevents them from attaining optimal performance. In particular, in the Map 4
environment, they adopt cautious policies that prefer avoiding penalties to attaining the agents’ goals. Such cautious policies
explain the total discounted reward of 0.00 and the steps to goal.

F.S. Melo, M. Veloso / Artiﬁcial Intelligence 175 (2011) 1757–1789

1781

Table 10
Steps-to-goal for each of the four different algorithms in each of the test scenarios. The results are averaged over 1000 independent Monte Carlo trials.
For each environment, bold entries correspond to optimal values (differences are not statistically signiﬁcant). Numbers in parentheses indicate that not all
agents reached the goal.
Environment

Indiv.

Non-coop.

Coop.

Opt.

Map 1
Map 2
Map 3
Map 4
cit
cmu
isr
mit
pentagon
suny

10.862
12.900
8.303
8.244
13.542
40.100
8.216
24.100
5.300
12.441

10.841
12.800
8.154
> 250.00
13.500
39.800
8.211
24.600
5.500
12.558

(10.821)
17.500
(8.467)
(4.999)
13.520
(39.815)
8.226
25.300
4.900
12.492

10.977
12.546
8.267
5.001
12.512
39.340
7.440
22.444
5.365
12.539

Table 11
Number of crashes for the four different algorithms in each of the test scenarios. The results are averaged over 1000 independent Monte Carlo trials. For
each environment, bold entries correspond to optimal values (differences are not statistically signiﬁcant).
Environment

Indiv.

Non-coop.

Coop.

Opt.

Map 1
Map 2
Map 3
Map 4
cit
cmu
isr
mit
pentagon
suny

0.408
0.500
0.303
1.911
0.000
0.500
0.012
0.000
0.100
0.000

0.397
0.300
0.261
0.000
0.000
0.100
0.005
0.000
0.200
0.000

0.000
0.000
0.000
0.000
0.000
0.000
0.006
0.000
0.000
0.000

0.000
0.000
0.000
0.000
0.000
0.000
0.000
0.000
0.000
0.000

Tables 10 and 11 show the number of steps-to-goal and the number of miscoordinations per trial for each of the test
environments. Our algorithm exhibits nearly no miscoordinations in all environments, which means that the robots are
able to coordinate in their choice of path. However, in some scenarios, this is attained at the cost of having only one of
the agents reach the goal, corresponding to the values in parenthesis in Table 10. This indicates that, in these scenarios,
coordination would require incurring in an excessive penalty arising from using the Coordinate action, and the agents opt
by sacriﬁcing reaching one of the goals. This is an interesting aspect of our learning approach: the agents trade-off the
cost of the Coordinate action by the usefulness of the information provided. This is in contrast with the individual agents:
they always reach their goal in minimum time, but at a cost of severe miscoordination penalties that they never experience
during learning, and hence their poor performance in terms of total discounted reward.
Our results also conﬁrm that interaction in the larger environments is much sparser than that in the smaller environments. In some of the test scenarios (e.g., cit), the environment and the initial/goal positions for both robots are such
that explicit coordination actions are not really necessary to avoid miscoordinations. Therefore, both the individualistic Q learners and the non-cooperative Q -learners should be able to attain a good performance. In general, as seen in Tables 9
through 11, there are some environments in which all methods attain similar performance, indicating that no coordination
actions are necessary, since both the Individual and Non-coordinated approaches are able to attain optimal performance.
The fact that our algorithm attains a similar performance means that it learns that the Coordinate action is not necessary,
otherwise the total discounted reward would be inferior to that of the other methods.
We also analyze how the increasing penalties for miscoordination affect the performance of the robots in all scenarios.
We run all three learning algorithms for different values of the miscoordination penalty and evaluated the obtained policies.
As expected, as the penalty for miscoordination increases, the total discounted reward of those methods that are unable
to avoid miscoordinations (Table 11) decreases accordingly, accentuating the differences already observed in Table 10. The
reliability of the performance of the individualistic and non-coordinated policies—translated in the variance of the observed
performance—is also severely affected as the miscoordination penalty increases.
Finally, the non-cooperative Q -learning algorithm is able to surpass the individualistic Q -learning in several scenarios.
This is particularly evident by observing the performance as the miscoordination penalty increases, and can be interpreted
as the non-cooperative agents having to act with increasing caution due to the penalties experienced during learning.
In conclusion, our proposed method is able learn to coordinate only when coordination is necessary to attain good
performance. In several scenarios, our learning agents resort to coordination actions in those states where joint state information leads to improved performance, and these states corresponds precisely to the interaction areas deﬁned in Section 3.
In other scenarios, our agents are also able to learn to trade-off the beneﬁts of coordination actions against the costs of
such actions.

1782

F.S. Melo, M. Veloso / Artiﬁcial Intelligence 175 (2011) 1757–1789

6. Related work
A wide range of models have been proposed to formalize decision-making problems in multiagent systems, including
stochastic games [35], multiagent MDPs [36], Dec-POMDPs [37,16], and I-POMDPs [38]. These models differ in scope, assumptions, and computational complexity [26]. For example, multiagent MDPs are can be solved in polynomial time, while
ﬁnite-horizon Dec-MDP and Dec-POMDP models are NEXP-complete, even for the benign 2-agent scenarios, and complexity
results are even worse in non-cooperative settings.
Efforts to handle the worst-case complexity of decentralized multiagent models led to approximate methods that tradeoff optimality and computability (e.g., [39,40]), and reduced models that trade off representability and computability. Several
such models assume that the interaction among agents can be simpliﬁed in different ways. For example, in transitionindependent Dec-MDPs, the transition probabilities for each agent depend solely on its own actions and local states.
Transition independent Dec-MDPs are NP-complete and can be solved using the Coverage Set algorithm [41,27].
Our Dec-SIMDP model can be viewed as an extension of transition-in dependent Dec-MDP, as it allows the transition
probabilities for an agent to dependent on the actions of other agents in interaction areas, where joint state observability
or free instantaneous communication is assumed. We expect the worst-case complexity of a Dec-SIMDP to be between that
of transition-independent Dec-MDPs and general Dec-MDPs.
Local interactions have also been exploited in other multiagent scenarios. For example, several works propose the
use of hierarchical approaches that subdivide an overall task in a hierarchy of subtasks, each restricted to the states
and actions relevant to that particular subtask [5,42,4]. The subtasks are conducted individually by each agent and do
not require the local state of different agents to be shared. Going up the hierarchy corresponds to moving from lowlevel “local” tasks to higher-level “global” tasks, in which coordination is necessary and must be accounted for explicitly. Since execution at the highest level corresponds to several low-level time steps, communication needs are minimized.
Coordination graphs [6,43] capture local dependences between the different agents in an MMDP, allowing the overall Q function to be decomposed into local Q -functions that can be optimized individually. Coordination graphs have been used
for eﬃcient planning and learning in large multiagent MDPs [44]. Although the problems to which coordination graphs
have been applied are signiﬁcantly different from those we study, the interactions between agents captured by coordination
graphs are related to our notion of interaction areas in our Dec-SIMPD model, and it would be interesting to investigate the
use of a graphical structure to compactly represent the dependencies among agents in a Dec-SIMDP.
The coordination graph structure has also been learned from experience based on the concept of utile coordination [7].
Although using a fundamentally different approach, this work relates to our learning of interaction areas in that both
methods infer where joint state information can improve the performance of the agents. We differ in the fact that our
agents explicitly learn how to trade-off the beneﬁts of querying the other agents’ states with the environment-imposed
limitations of this querying process and the associated cost. Our method captures the impact that communication costs may
have both on the decision process and on the process of learning these inter-agent dependencies.
Both hierarchical approaches and coordination graphs discussed above exploit local interactions among the agents and
should thus be able to accommodate some level of partial state observability.
In the game-theoretic literature, local dependences between players in large games have also been explored. For example,
graphical games [9] represent n-player matrix games as undirected graphs, where players correspond to nodes, and the payoff
for each node depends only on the actions of its direct neighbors in the graph. Action-graph games further generalize the
concept of graphical games, exploring sparser dependences between players in a game [10]. Multiple algorithms have been
proposed to compute Nash equilibria in this class of games, mostly relying on “continuation methods” [45], where a known
solution for a simple game is gradually perturbed toward a solution to the desired game. Continuation methods run in time
exponential in the in-degree of the action-graph, and not in its number of nodes. Therefore, games with many contextspeciﬁc independences yield sparsely connected action-graph games, leading to exponential savings in computational time.
In some classes of problems, additional structure of the corresponding action-graph games can lead even to more eﬃcient
computation of equilibria [46,47].
The main concept of our Dec-SIMDP model was originally proposed under the designation of interaction-driven Markov
games [30], with the associated IDMG algorithm. Our contributions in this paper extend the original IDMG formulation in
several aspects. We formalize the relation between Dec-MDPs and Dec-SIMDPs, introducing concepts such as interaction areas and interaction states. We presented two general heuristic planning algorithms with corresponding convergence analysis
and error bounds that overcome some limitations of the original IDMG algorithm: (i) outside interaction areas, both LAPSI
and MPSI reason about future interactions, unlike IDMG which only considers interactions when they actually occur; (ii) in
interaction areas, LAPSI and MPSI also offer computational advantages over IDMG, since the latter requires the computation
of several equilibria.
Other closely related models to the Dec-SIMDP model are those that explore event-driven interactions [48–50], and distributed POMDPs with coordination locales (DCPLs) [13]. Particularly in DCPLs, each agent is assumed independent of all
other agents except on previously speciﬁed coordination locales. As in the IDMG algorithm, the proposed TREMOR algorithm for DCPLs models each agent k using a POMDP model that is solved to yield a policy πk for that agent. Coordination
locales are handled by modifying the POMDP model for each agent taking the policies of the other agents into account.
Instead, our approach assumes that interactions are fully observable, which can be used for coordination.

F.S. Melo, M. Veloso / Artiﬁcial Intelligence 175 (2011) 1757–1789

1783

More recently, an information-theoretic measure of inter-agent inﬂuence has been proposed under the designation of
inﬂuence gap [28], which indicates how much the actions of one agent determine the actions of the other agents in the
optimal policy. Such inﬂuence gap then attempts at quantifying the level of dependence between the different agents. As
expected, larger inﬂuence gaps, corresponding to smaller inter-agent inﬂuence, typically translate into less computational
complexity. While the inﬂuence gap is a measure of global inter-agent inﬂuence, our interaction areas capture local interactions between the agents. Larger or numerous interaction areas typically lead to harder problems. As future work, it would
be interesting to relate the number or size of interaction areas in Dec-SIMDPs in terms of the proposed inﬂuence gap, using
the latter to assess the potential usefulness of the Dec-SIMDP model in particular problems.
7. Conclusion and future work
In this work, we analyzed how local interactions in a multiagent system can be used to simplify the process of decentralized decision making. We introduced Dec-SIMDPs, a new decision-theoretic model for decentralized multiagent systems
with sparse interaction that explicitly distinguishes the situations in which the agents in a team must coordinate from
those in which they can act independently. We formalized the relation between Dec-MDPs and Dec-SIMDPs, establishing
Dec-SIMDPs as particular instances of Dec-MDPs. We presented MPSI and LAPSI, two general heuristic planning approaches
that reduce planning in a Dec-SIMDP to a sequence of planning problems in single-agent POMDPs. We analyzed particular
instances of MPSI and LAPSI and derived bounds for the quality of the obtained policies. Finally, we presented an RL algorithm that can be used to learn interaction areas in a Dec-SIMDP. We illustrated the application of all algorithms throughout
the paper in several multiagent navigation scenarios.
Both instances of MPSI and LAPSI used in the experimental results rely on having each agent track the other agents in
the environment using a belief vector that is then used to choose the actions. The difference between the two algorithms
lies in the assumed policy for the other agents. MPSI assumes each of the other agents to be completely driven by its
individual goals, thus discarding whatever interaction there may be. In the cases where these interactions are negative,
MPSI agents then act more cautiously. In contrast, the LAPSI agent assumes that the other agents are team-players, in that
they choose their actions for the common goal of the group. Hence, the LAPSI agent adopts a policy that is closer to the
actual optimal fully-observable policy. The LAPSI algorithm successfully leverages the particular independences between
the different agents to attain eﬃcient and yet near-optimal performance. In MPSI and LAPSI, these modeling strategies are
used to abstract the decision process of each agent into a single-agent decision process—namely, a POMDP. Although we
illustrated our methods using a Q MDP -like approach, the same principle can be used with any other POMDP solver.
The differences between MPSI and LAPSI may provide additional information in deﬁning the interaction areas. While
MPSI relies on the optimal policies for the individual MDPs in the Dec-SIMDP model, LAPSI relies on the joint policy for
the underlying MMDP. Since outside interaction areas we expect the actions of the different agents to be approximately
independent, the interactions areas should be those in which the estimated policies using the individual MDPs and the joint
MMDP disagree. This provides one recipe for choosing the interaction states as those in which individual state-information
is not suﬃcient to determine the best action.
The results of learning algorithm open several interesting questions. One ﬁrst issue concerns the dependence of the
performance of the algorithm on the cost of the Coordinate action. In fact, we observed that our agents are able to learn
a trade-off between the beneﬁts arising from good coordination and the cost of that same coordination. Such trade-off is
similar to the problem of exchanging reward by information arising in POMDPs [22] and it would be interesting to analyze
both how this trade-off is inﬂuenced by the cost of the Coordinate action and how such trade-off extends to situations
where further partial state observability is considered.
Another aspect open to future investigation regards the performance guarantees of the algorithm. As remarked in
Section 5, the parallel learning process taking place when the agent executes the Coordinate action bears signiﬁcant resemblances to a generalized ﬁctitious play. It would be interesting to analyze how the convergence guarantees of ﬁctitious
play can be translated to our particular learning algorithm. The scenarios used in our work, in which our learning algorithm
exhibited interesting performance, were focused on localized coordination, based on the underlying assumption of the advantages of our model and learning. As coordination increases to a more global level, the learning algorithm may need to
be adapted to attain the desired performance.
In view of the completely independent way by which the agents learn, it remains to investigate if the learning algorithm
would be applicable to different reward functions for the different agents, or other scenarios in which the agents are not
completely independent in terms of dynamics but exhibit some weak coupling—for example in the states where interaction
occurs. It would also be interesting to explore our ideas in more general models such as Dec-POMDPs, alleviating the
requirement of full local state observability.
Acknowledgements
The authors would like to acknowledge the thorough comments of the anonymous reviewers that signiﬁcantly contributed to improve the quality of the presentation, and the helpful discussions with Matthijs Spaan. This research was
partially sponsored by the project CMU-PT/SIA/0023/2009 under the Carnegie Mellon Portugal Program and its Information and Communications Technologies Institute, and the Portuguese Fundação para a Ciência e Tecnologia. The views and
conclusions contained in this document are those of the authors only.

1784

F.S. Melo, M. Veloso / Artiﬁcial Intelligence 175 (2011) 1757–1789

Appendix A. Proofs
A.1. Proof of Theorem 4.1
We show that the generalized α -vectors can be computed using a convergent dynamic-programming-like approach, by
iterating over the recurrent expression in (16).
In a Dec-SIMDP verifying the conditions of the theorem, a generalized α -vector α k is actually a |X | × |Ak | matrix with
component (x, ak ) given by αk (x, ak ). For a general matrix |X | × |Ak | matrix W , let Tk be the operator deﬁned as

(Tk W )(x, ak ) = rπ−k (x, ak ) + γ

Pπ−k (x, ak , y ) max W ( y , uk ) + γ max
uk

y ∈X I

uk

Pπ−k (x, ak , y ) W ( y , uk ),
y∈
/XI

where (Tk W )(x, ak ) denotes the element (x, ak ) of the matrix Tk W . The operator Tk is closely related with the Bellman
operator H introduced in (3). We establish the assertion of the theorem by showing Tk to be a contraction in the supremum
norm. In fact, we have

Tk W 1 − Tk W 2 ∞ = max (Tk W 1 )(x, ak ) − (Tk W 2 )(x, ak )
x,ak

Pπ−k (x, ak , y ) max W 1 ( y , uk ) − W 2 ( y , uk ) ,

γ max
x,ak

uk

y

where the last inequality follows from Jensen’s inequality, implying that

Tk W 1 − Tk W 2 ∞

γ max W 1 (x, ak ) − W 2 (x, ak ) = γ W 1 − W 2
x,ak

∞.

We have thus shown that Tk is a contraction in the supremum norm, which implies that

• Tk has a unique ﬁxed-point, corresponding to the generalized α -vectors;
• Tk can be used to compute the generalized α -vectors in a dynamic-programming-like fashion, using the update rule

αk(n+1) (x, ak ) = Tk αk(n) (x, ak ),
where

αk(n) denotes the nth estimate of αk (x, ak ). ✷

A.2. Proof of Theorem 4.2
We show that the problem of computing the generalized α -vectors for a Dec-SIMDP verifying the conditions of the
theorem is equivalent in terms of complexity to that of solving an MDP whose dimension depends polynomially on the
dimension of the original Dec-SIMDP. In particular, we show that computing the generalized α -vectors for such Dec-SIMDP
is equivalent to computing the optimal Q -function for an MDP. Since MDPs are known to be P-complete [25], the desired
result follows.
We rewrite (16) as

αk (x, ak ) = rπ−k (x, ak ) + γ

Pπ−k (x, ak , y ) max αk ( y , uk )
uk

y ∈X I

+γ

Pπ−k (x, ak , z)αk ( z, uk ),

Pπ−k (x, ak , y ) max ηxak
uk

y∈
/XI

z∈
/XI

where

ηxak =

1
y∈
/ X I Pπ−k (x, ak , y )

.

ˆ = (Xˆ , Ak , Pˆ , rˆ), where Xˆ = X ∪ X × Ak and
We now construct an MDP M

ˆ (ˆx, ak , yˆ ) =
P

⎧
Pπ−k (ˆx, ak , yˆ )
⎪
⎪
⎪
⎪ 1/ηxˆa
⎨
k

if xˆ ∈ X and yˆ ∈ X I ,
if xˆ ∈ X and yˆ = (ˆx, ak ),

ηzuk y∈/ X I Pπ−k (z, uk , y )Pπ−k ( y , ak , yˆ ) if xˆ = (z, uk ) and yˆ ∈ X I ,
⎪
⎪
⎪
⎪
if xˆ = ( z, uk ), yˆ = ( y , ak ), and y ∈
/ XI ,
⎩ ηzuk Pπ−k ( z, uk , y )/η yak
0

These probabilities are well deﬁned since, for xˆ ∈ X ,

otherwise.

(A.1)

F.S. Melo, M. Veloso / Artiﬁcial Intelligence 175 (2011) 1757–1789

ˆ (ˆx, ak , yˆ ) =
P
yˆ

Pπ−k (ˆx, ak , yˆ ) + 1/ηxˆ ak =
yˆ ∈X I

Pπ−k (ˆx, ak , yˆ ) +

1785

Pπ−k (ˆx, ak , y ) = 1
y∈
/XI

yˆ ∈X I

and, for xˆ = ( z, uk )

ˆ (ˆx, ak , yˆ ) = ηzuk
P

Pπ−k ( y , ak , yˆ ) + 1/η yak

Pπ−k ( z, uk , y )
y∈
/XI

yˆ

Pπ−k ( z, uk , y ) = 1.

= ηzuk
y∈
/XI

yˆ ∈X I

ˆ is
The reward function for M
if xˆ ∈ X ,

rπ−k (ˆx, ak )

rˆ (ˆx, ak ) =

ˆ = ( z, uk ).
y∈
/ X I Pπ−k ( z, uk , y )r π−k ( y , ak ) if x

ηzuk

The optimal Q -function for this MDP veriﬁes the recursive relation (2), namely:

Q ∗ (ˆx, ak ) = rˆ (ˆx, ak ) + γ

ˆ (ˆx, ak , yˆ ) max Q ∗ ( yˆ , uk ).
P
uk

yˆ ∈Xˆ

ˆ and rˆ ,
For xˆ ∈ X , and replacing the deﬁnitions of P
Q ∗ (ˆx, ak ) = rπ−k (ˆx, ak ) + γ

Pπ−k (ˆx, ak , yˆ ) max Q ∗ ( yˆ , uk ) +
uk

yˆ ∈X I

γ
max Q ∗ (ˆx, ak ), uk .
ηxˆak uk

(A.2)

Similarly, for xˆ = ( z, uk ),

Q ∗ (ˆx, ak ) = ηzuk
y∈
/XI

+

Pπ−k ( y , ak , yˆ ) max Q ∗ ( yˆ , uk )

Pπ−k ( z, uk , y ) rπ−k ( y , ak ) + γ
yˆ ∈X I

uk

γ
max Q ∗ ( y , ak ), uk
η yak uk
Pπ−k ( z, uk , y ) Q ∗ ( y , ak ).

= ηzuk

(A.3)

y∈
/XI

Replacing (A.2) in (A.3) yields

Q ∗ (ˆx, ak ) = rπ−k (ˆx, ak ) + γ

Pπ−k (ˆx, ak , yˆ ) max Q ∗ ( yˆ , uk ) +
uk

yˆ ∈X I

γ
max η
Pπ (ˆx, ak , y ) Q ∗ ( y , uk ),
ηxˆak uk xˆak y∈/ X −k
I

ˆ , we compute the generalized
which is (A.1). As such, in computing the optimal Q -function for the MDP M
the original Dec-SIMDP as

α -vectors for

αk (x, ak ) = Q ∗ (x, ak ).
Since the dimension of the new MDP grows linearly with the dimension of the generalized
dimension of the corresponding Dec-SIMDP, the statement of the theorem follows. ✷

α -vectors, and, hence, with the

A.3. Proof of Theorem 4.3
For a general MDP M = (X , A , P , r , γ ), if πˆ is the greedy policy with respect to a function Qˆ , i.e., if

πˆ (x) = arg max Qˆ (x, a)
a∈A

for all x ∈ X , then

V πˆ − V ∗ ∞

2γ

(1 − γ )2

BE( Qˆ ),

(A.4)

where BE( Qˆ ) is the Bellman error associated with the function Qˆ ,7

P(x, a, y ) max Qˆ ( y , u ) − Qˆ (x, a) .

BE( Qˆ ) = sup r (x, a) + γ
x,a

7

y

This fact follows from Proposition 6.1 of [18].

u

1786

F.S. Melo, M. Veloso / Artiﬁcial Intelligence 175 (2011) 1757–1789

In our Dec-SIMDP setting, since we are assuming the policy π−k to be ﬁxed and known, the decision process from agent
k’s perspective is a standard POMDP. Since a POMDP can be recast as an equivalent belief MDP, it follows that the relation
(A.4) also holds for POMDPs. Writing down the Bellman error for a general POMDP (X , A, Z , P, O, r , γ ) thus yields

BE( Qˆ ) = sup
b,a

P(x, a, y )O( y , a, z) max Qˆ bza , u

bx r (x, a) + γ
x

u

z, y

− Qˆ (b, ak ) .

For simplicity of notation, we consider the Bellman error at (b, a) to be

BE( Qˆ , b, a) =

P(x, a, y )O( y , a, z) max Qˆ bza , u

bx r (x, a) + γ
x

u

z, y

− Qˆ (b, a) .

For the POMDP as perceived by agent k in our Dec-SIMDP setting,

BE( Qˆ , b, ak ) =

Pπ−k (x, ak , y )O( y , z) max Qˆ bzak , u

bx−k rπ−k (x, ak ) + γ
x−k

u

z, y

which, replacing the deﬁnitions of Qˆ (b, ak ) and the generalized

BE( Qˆ , b, ak ) = γ

uk

−

x− O , y − O

Pπ−k (x− O , y − O )αk ( y , uk ) ,

b x O bx− O Pπ−k (x O , ak , y O ) max
uk

x, y O

α -vectors yields, leads to
bx− O Pπ−k (x− O , y − O )αk ( y , uk )

bx O Pπ−k (x O , ak , y O ) max
xO , y O

− Qˆ (b, ak )

y− O

using the notation introduced in Section 4.2. Letting

Λk (x− O , y O , uk ) =

Pπ−k (x− O , y − O )αk ( y , uk ),
y− O

then

BE( Qˆ , b, ak )

bx− O Λ(x− O , y O , uk ) −

γ max max
yO

uk

x− O

bx− O max Λ(x− O , y O , uk ) .
x− O

uk

In order to bound the right-hand side of the expression above, we need two auxiliary results that generalize some of the
bounds in [51] to the case of functions deﬁned over Rn and are of independent interest per se.
Lemma 1. Let {xk , k = 1, . . . , M } be a set of points in Rn , for some (ﬁnite) n, and {βk , k = 1, . . . , M } a set of corresponding weights,
verifying 0 βk 1, k = 1, . . . , M and k βk = 1. Let f : Rn → R be a convex function. Then, it holds that

βk f (xk ) − f
k

β∗

βk xk
k

f (xk ) − M f
k

xk / M

,

(A.5)

k

where

β ∗ = max βk .
k

Proof. The proof essentially follows that of Lemma 1 in [51]. Let k∗ be such that β ∗ = βk∗ . Eq. (A.5) can be rewritten as

β ∗ − βk f (xk ) + f
k=k∗

β∗ M f

βk xk
k

xk / M
k

or, equivalently,

k=k∗

β ∗ − βk
1
f (xk ) +
f
Mβ∗
Mβ∗

Since

k=k∗

β ∗ − βk
1
+
= 1,
Mβ∗
Mβ∗

βk xk
k

f

xk / M .
k

F.S. Melo, M. Veloso / Artiﬁcial Intelligence 175 (2011) 1757–1789

1787

then

β ∗ − βk
1
f (xk ) +
f
Mβ∗
Mβ∗

k=k∗

βk xk

f
k=k∗

k

β ∗ − βk
1
xk +
Mβ∗
Mβ∗

where the ﬁrst inequality follows from Jensen’s inequality, implying (A.5).

βk xk = f
k

xk / M ,
k

✷

Corollary 1. Let {xi , i = 1, . . . , N } be a set of points in Rn , for some ﬁnite n, and { p i , i = 1, . . . , N } a corresponding sequence of
weights verifying 0 p i 1 and i p i = 1. Let U denote a closed convex set that can be represented as the convex hull of a set of
points {ak , k = 1, . . . , M } in Rn . Let f : U → R be a convex function. Then, it holds that

p i f ( xi ) − f

f (ak ) − M f

p i xi

i

i

k

ak / M .

(A.6)

k

Proof. Each xi can be written as

xi =

λik ak ,
k

with 0

λik

1 and

k

λik = 1, i = 1, . . . , n. Then,

p i f ( xi ) − f
i

p i xi

=

λik ak − f

pi f

i

i

p i λik − f

f (ak )

i

λik ak
k

ak

i

k

Letting βk =

pi
i

k

p i λik .
i

k

p i λik ,

p i f ( xi ) − f
i

βk f (ak ) − f

p i xi
i

k

βk ak .
k

Finally, applying Lemma 1,

p i f ( xi ) − f
i

βk f (ak ) − f

p i xi
i

k

βk ak
k

β∗

f (ak ) − M f
k

ak / M
k

f (ak ) − M f
k

ak / M .

✷

k

The two bounds differ as (A.5) depends on the function f and the set of points {xk , k = 1, . . . , M }, while (A.6) depends
only on the function f and on the set U .
For any given uk∗ ∈ Ak , x∗− O ∈ X− O and y ∗O ∈ X O , it holds that Λk (x∗− O , y ∗O , uk∗ ) lies in the convex hull of the set of
alpha-vectors αk ( y , uk∗ ) where y O = y ∗O . Then, from Corollary 1,

BE( Qˆ , b, ak )

αk ( y O , y − O ), uk −

γ max max
yO

uk

y− O

max αk ( y O , y − O ), uk ,
y− O

uk

ﬁnally yielding

V ∗ − V πk ∞

2γ 2

(1 − γ )2

αk ( y O , y − O ), uk −

max max
yO

uk

y− O

max αk ( y O , y − O ), uk .
y− O

uk

✷

1788

F.S. Melo, M. Veloso / Artiﬁcial Intelligence 175 (2011) 1757–1789

References
[1] N. Meuleau, M. Hauskrecht, K. Kim, L. Peshkin, L. Kaelbling, T. Dean, C. Boutilier, Solving very large weakly coupled Markov decision processes, in: Proc.
15th AAAI Conf. Artiﬁcial Intelligence, 1998, pp. 165–172.
[2] S. Singh, D. Cohn, How to dynamically merge Markov decision processes, Advances in Neural Information Processing Systems 10 (1998) 1057–1063.
[3] R. Nair, M. Tambe, Hybrid BDI-POMDP framework for multiagent teaming, Journal of Artiﬁcial Intelligence Research 23 (2005) 367–420.
[4] P. Stone, M. Veloso, Team-partitioned, opaque-transition reinforcement learning, in: Proc. RoboCup-98, 1998, pp. 206–212.
[5] M. Ghavamzadeh, S. Mahadevan, R. Makar, Hierarchical multiagent reinforcement learning, Journal of Autonomous Agents and Multiagent Systems 13 (2) (2006) 197–229.
[6] C. Guestrin, D. Koller, R. Parr, Multiagent planning with factored MDPs, Advances in Neural Information Processing Systems 14 (2001) 1523–1530.
[7] J. Kok, P. Hoen, B. Bakker, N. Vlassis, Utile coordination: learning interdependencies among cooperative agents, in: IEEE Symp. Computational Intelligence and Games, 2005, pp. 61–68.
[8] M. Roth, R. Simmons, M. Veloso, Exploiting factored representations for decentralized execution in multiagent teams, in: Proc. 6th Int. Conf. Autonomous Agents and Multiagent Systems, 2007, pp. 469–475.
[9] M. Kearns, M. Littman, S. Singh, Graphical models for game theory, in: Proc. 17th Conf. Uncertainty in Artiﬁcial Intelligence, 2001, pp. 253–260.
[10] A. Xin Jiang, K. Leyton-Brown, N. Bhat, Action-graph games, Tech. rep. TR-2008-13, Univ. British Columbia, 2008.
[11] M. Allen, S. Zilberstein, Complexity of decentralized control: special cases, Advances in Neural Information Processing Systems 22 (2009) 19–27.
[12] C. Goldman, S. Zilberstein, Decentralized control of cooperative systems: categorization and complexity analysis, Journal of Artiﬁcial Intelligence Research 22 (2004) 143–174.
[13] P. Varakantham, J. Kwak, M. Taylor, J. Marecki, P. Scerri, M. Tambe, Exploiting coordination locales in distributed POMDPs via social model shaping, in:
Proc. 19th Int. Conf. Automated Planning and Scheduling, 2009, pp. 313–320.
[14] M. Puterman, Markov Decision Processes, Discrete Stochastic Dynamic Programming, John Wiley & Sons, Inc., 1994.
[15] L. Kaelbling, M. Littman, A. Cassandra, Planning and acting in partially observable stochastic domains, Artiﬁcial Intelligence 101 (1998) 99–134.
[16] D. Bernstein, R. Givan, N. Immerman, S. Zilberstein, The complexity of decentralized control of Markov decision processes, Mathematics of Operations
Research 27 (4) (2002) 819–840.
[17] C. Watkins, Learning from delayed rewards, Ph.D. thesis, King’s College, Cambridge Univ., 1989.
[18] D. Bertsekas, J. Tsitsiklis, Neuro-Dynamic Programming, Athena Scientiﬁc, 1996.
[19] R. Smallwood, E. Sondik, The optimal control of partially observable Markov processes over a ﬁnite horizon, Operations Research 21 (5) (1973) 1071–
1088.
[20] O. Madani, S. Hanks, A. Condon, On the undecidability of probabilistic planning and inﬁnite-horizon partially observable Markov decision problems, in:
Proc. 16th AAAI Conf. Artiﬁcial Intelligence, 1999, pp. 541–548.
[21] A. Cassandra, Exact and approximate algorithms for partially observable Markov decision processes, Ph.D. thesis, Dept. Computer Sciences, Brown Univ.,
1998.
[22] D. Aberdeen, A (revised) survey of approximate methods for solving partially observable Markov decision processes, Tech. rep., National ICT Australia,
2003.
[23] M. Littman, A. Cassandra, L. Kaelbling, Learning policies for partially observable environments: scaling up, in: Proc. 12th Int. Conf. Machine Learning,
1995, pp. 362–370.
[24] F. Melo, M. Ribeiro, Transition entropy in partially observable Markov decision processes, in: Proc. 9th Int. Conf. Intelligent Autonomous Systems, 2006,
pp. 282–289.
[25] C. Papadimitriou, J. Tsitsiklis, The complexity of Markov decision processes, Mathematics of Operations Research 12 (3) (1987) 441–450.
[26] S. Seuken, S. Zilberstein, Formal models and algorithms for decentralized decision-making under uncertainty, Journal of Autonomous Agents and
Multiagent Systems 17 (2) (2008) 190–250.
[27] R. Becker, S. Zilberstein, V. Lesser, C. Goldman, Solving transition independent decentralized Markov decision processes, Journal of Artiﬁcial Intelligence
Research 22 (2004) 423–455.
[28] M. Allen, Interactions in decentralized environments, Ph.D. thesis, Univ. Massachusetts, Amherst, 2009.
[29] A. Cassandra, Optimal policies for partially observable Markov decision processes, Tech. rep. CS-94-14, Dept. Computer Sciences, Brown Univ., 1994.
[30] M. Spaan, F. Melo, Interaction-driven Markov games for decentralized multiagent planning under uncertainty, in: Proc. 7th Int. Conf. Autonomous
Agents and Multiagent Systems, 2008, pp. 525–532.
[31] C. Claus, C. Boutilier, The dynamics of reinforcement learning in cooperative multiagent systems, in: Proc. 15th AAAI Conf. Artiﬁcial Intelligence, 1998,
pp. 746–752.
[32] M. Tan, Multi-agent reinforcement learning: independent vs. cooperative agents, in: Readings in Agents, Morgan Kaufman, 1997, pp. 487–494.
[33] D. Leslie, E. Collins, Generalised weakened ﬁctitious play, Games and Economic Behavior 56 (2006) 285–298.
[34] R. Sutton, A. Barto, Reinforcement Learning: An Introduction, MIT Press, 1998.
[35] L. Shapley, Stochastic games, Proceedings of the National Academy of Sciences 39 (1953) 1095–1100.
[36] C. Boutilier, Planning, learning and coordination in multiagent decision processes, in: Theoretical Aspects of Rationality and Knowledge, 1996, pp. 195–
210.
[37] D. Pynadath, M. Tambe, The communicative multiagent team decision problem: analyzing teamworktheories and models, Journal of Artiﬁcial Intelligence Research 16 (2002) 389–423.
[38] P. Gmytrasiewicz, P. Doshi, A framework for sequential planning in multiagent settings, Journal of Artiﬁcial Intelligence Research 24 (2005) 49–79.
[39] R. Emery-Montemerlo, G. Gordon, J. Schneider, S. Thrun, Approximate solutions for partially observable stochastic games with common payoffs, in:
Proc. 3rd Int. Conf. Autonomous Agents and Multiagent Systems, 2004, pp. 136–143.
[40] M. Roth, Execution-time communication decisions for coordination of multiagent teams, Ph.D. thesis, Carnegie Mellon University, August 2007.
[41] R. Becker, S. Zilberstein, V. Lesser, C. Goldman, Transition-independent decentralized Markov decision processes, in: Proc. 2nd Int. Conf. Autonomous
Agents and Multiagent Systems, 2003, pp. 41–48.
[42] R. Makar, S. Mahadevan, Hierarchical multiagent reinforcement learning, in: Proc. 5th Int. Conf. Autonomous Agents, 2001, pp. 246–253.
[43] C. Guestrin, S. Venkataraman, D. Koller, Context-speciﬁc multiagent coordination and planning with factored MDPs, in: Proc. 18th AAAI Conf. Artiﬁcial
Intelligence, 2002, pp. 253–259.
[44] J. Kok, N. Vlassis, Sparse cooperative Q -learning, in: Proc. 21st Int. Conf. Machine Learning, 2004, pp. 61–68.
[45] N. Bhat, K. Leyton-Brown, Computing Nash equilibria of action-graph games, in: Proc. 20th Conf. Uncertainty in Artiﬁcial Intelligence, 2004, pp. 35–42.
[46] A. Xin Jiang, K. Leyton-Brown, A polynomial-time algorithm for action-graph games, in: Proc. 21st AAAI Conf. Artiﬁcial Intelligence, 2006, pp. 679–684.
[47] A. Xin Jiang, K. Leyton-Brown, Computing pure Nash equilibria in symmetric action-graph games, in: Proc. 22nd AAAI Conf. Artiﬁcial Intelligence, 2007,
pp. 79–85.
[48] R. Becker, V. Lesser, S. Zilberstein, Decentralized Markov decision processes with event-driven interactions, in: Proc. 3rd Int. Conf. Autonomous Agents
and Multiagent Systems, 2004, pp. 302–309.

F.S. Melo, M. Veloso / Artiﬁcial Intelligence 175 (2011) 1757–1789

1789

[49] R. Becker, V. Lesser, S. Zilberstein, Analyzing myopic approaches for multiagent communication, in: Proc. IEEE Int. Conf. Intelligent Agent Technology,
2005, pp. 550–557.
[50] R. Becker, A. Carlin, V. Lesser, S. Zilberstein, Analyzing myopic approaches for multiagent communications, Computational Intelligence 25 (1) (2009)
31–50.
[51] S. Simic, On a global upper bound for Jensen’s inequality, Journal of Mathematical Analysis and Applications 343 (2008) 414–419.

