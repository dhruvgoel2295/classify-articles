journal of information security and applications 23 (2015) 44–53

Available online at www.sciencedirect.com

ScienceDirect
j o u r n a l h o m e p a g e : w w w. e l s e v i e r. c o m / l o c a t e / j i s a

Design of a lightweight two-factor
authentication scheme with smart
card revocation
Dheerendra Mishra a,*, Ankita Chaturvedi b, Sourav Mukhopadhyay b
a
b

Department of Mathematics, LNM Institute of Information Technology, Jaipur, India
Department of Mathematics, Indian Institute of Technology, Kharagpur, India

A R T I C L E

I N F O

A B S T R A C T

Article history:

Smart card based authentication schemes present user-friendly and secure communica-

Available online 3 July 2015

tion mechanism over insure public channel. Recently, Li et al. designed an authentication
scheme with pre-smart card authentication to present efficient login phase and user-

Keywords:

friendly password change phase. It can quickly detect illegitimate login attempt. We analyze

Authentication

the security of Li et al.’s scheme, and identify the scheme insecure. Moreover, their scheme

Smart card

requires the computation of public key operations. To address the security and efficiency

Anonymity

of mutual authentication design, we propose a lightweight authentication scheme, which
supports smart card revocation. The proposed scheme requires the computation of only hash
function and exclusive-or operations. Furthermore, we verify the correctness of mutual authentication using the widely-accepted BAN (Burrows, Abadi, and Needham) logic. Through
the security and performance analysis, we show that our scheme is secure and
computationally efficient than the existing schemes. Furthermore, the proposed scheme
present efficient login and password change phases where incorrect login is quickly detected, and a user can freely change his password without server assistance.
© 2015 Elsevier Ltd. All rights reserved.

1.

Introduction

Advancement in Internet technology have made Internet an
efficient and scalable tool to utilize for various online services. Access of resources over the insecure Internet is a subject
of security and privacy risk. Thus, it is required to adopts cryptographic protocol, which can ensure secure and authorized
communication over insecure public channel. The authentication protocols are designed and developed to ensure the
correctness of the participants. In recent years, identity based
authentication scheme is being introduced, which uses user
identity in communication. It may cause identity theft and

linkability of users’ communications (Kuo et al., 2014; Mishra
and Mukhopadhyay, 2013; Darwish et al., 2015; Wang and Wang,
2014a). In recent years, authentication schemes using smart
card are also designed to ensure that only user who possesses both the smart card and the corresponding password
are allowed to gain access the server to safeguard data integrity, confidentiality and availability with user privacy. Smart
card based schemes support two factor authentication, and a
user just need to remember memorable password to use it.
These schemes are widely employed for various services due
to user-friendliness.
The smart card based protocol are developed to ensure authorized and secure communication between the user and

* Corresponding author.
E-mail addresses: dheerendra.mishra@lnmiit.ac.in (D. Mishra), ankita@maths.iitkgp.ernet.in (A. Chaturvedi), sourav@maths.iitkgp.ernet.in
(S. Mukhopadhyay).
http://dx.doi.org/10.1016/j.jisa.2015.06.001
2214-2126/© 2015 Elsevier Ltd. All rights reserved.

journal of information security and applications 23 (2015) 44–53

server (Wang et al., 2014; Kalra and Sood, 2014). However, smart
card based remote user authentication schemes faces various
attacks due to the following assumptions (Boyd and Mathuria,
2003; Eisenbarth et al., 2008; Kocher et al., 1999; Messerges et al.,
2002; Nohl et al., 2008; Kim et al., 2012):
• The user holds the uniformly distributed low-entropy password from the small dictionary.
• An adversary and a participants interact by executing oracle
queries that enables an adversary to perform various attacks
on authentication protocols.
• The communication channel is controlled by the adversary who has the capacity to intercept, modify, delete, resend
and reroute the eavesdropped messages.
• An adversary may steel user’s smart card and may extract
the stored information from the smart card.
To get over the security flaws, and enhance the system security, Chang and Wu (1991) introduced smart card-based
remote user authentication scheme. The smart card based
design of these cryptographic protocols increase the adoptability of smart card-based authentication scheme for real life
applications due to feature like cryptographic capacity, low cost
and portability. The smart-card-based authentication has
become one of the most widely adopted authentication protocols (He and Wang, 2014; Wang and Wang, 2014b; Kuo et al.,
2014; Wang et al., 2012). In the recent years many smart card
based authentication schemes have been designed and developed in keeping the mind following attributes:
– Address low computational overhead and less storage requirement to design a low cost smart card.
– Achieve efficient login and password change phase to detect
any unauthorized attempt.
– Resistance to different kinds of active and passive attacks
such as off-line password guessing attack, impersonation
attack, man-in-the middle attack, replay attack, insider
attack, etc.
– Support user-friendly password change phase to allow a user
to choose and change his password independently.
– Support mutual authentication to ensure correctness of
participants.
In smart card based authentication protocols, smart card
stores user security credentials, and using password they can
be protected. On user initiation, smart card generates the login
message and sends to the server. On receiving the login request,
server verify the correctness of message source. If verification
succeeds, User authentication holds. In 2009, Xu et al. (2009)
presented an password authentication scheme using smart card
to overcome the weaknesses of (Lee and Chiu, 2005; Lee et al.,
2005). Xu et al. also claimed that their scheme satisfies all the
desired security attributes. Although, in 2010, Sood et al. (2010)
showed that Xu et al.’s scheme is vulnerable to off-line passwordguessing attack and forgery attacks. They also presented an
improvement of Xu et al.’s scheme. In the same year, Song (2010)
also demonstrated that an adversary can extract the parameters from the legitimate user’s smart card and perform user
impersonation attack. Further, he presented an improvement
of Xu et al.’s scheme. In 2012, Chen et al. (2014) pointed out

45

that both Song and Sood et al. are still insecure. Chen et al.
showed that Sood et al.’s scheme only achieves one way authentication instead of mutual authentication. In addition, they
identified the inefficiency of Sood et al.’s scheme in the detection of incorrect input. Chen et al. also demonstrated the
off-line password guessing attack on the Song’s scheme. They
have also proposed an efficient scheme. However, Ma et al. (2014)
showed that Chen et al.’s scheme is vulnerable to off-line password guessing attack and does not provide forward secrecy.
Karuppiah and Saravanan (2014) designed a public key based
authentication scheme using smart card. Their scheme can efficiently resist off-line password guessing attack. However, Maitra
(1502) showed that Karuppiah and Saravanan’s scheme does
not replay reply attack, and discussed flaws in the login phase.
Recently, Li et al. (2013) also analyzed the security of Chen et al.’s
scheme, and showed that Chen et al.’s scheme does not ensure
forward secrecy, and fails to maintain efficient login and userfriendly password change phase. They also proposed an
enhanced smart card based password authentication scheme
to overcome the weaknesses of existing schemes. Later on, Islam
(2014) pointed out the vulnerability of Li et al.’s scheme to insider
attack, known session-specific temporary information attack
and off-line password guessing attack. He also proposed an improved authentication scheme, which can efficiently resist
insider attack, but does not overcome off-line password guessing attack. Unfortunately, Islam’s improved authentication
scheme does not protect anonymity, and has higher computation and communication overhead.
In this paper, we revisit the Li et al.’s scheme as it presents
smart card pre-authentication mechanism.We demonstrate the
pitfalls of Li et al.’s scheme, and then work on the design of an
efficient and secure authentication scheme. We propose a lightweight authentication scheme with pre-smart card
authentication. The proposed scheme supports smart card revocation mechanism.The analysis shows that proposed scheme
resists various active and passive attack such as off-line password guessing attack, impersonation attack, replay attack, insider
attack and stolen smart card attack. We also discuss the computation and communication overhead of the proposed scheme.
The rest of the paper is organized as follows: Section 2 presents the brief review of Li et al.’s scheme. Section 3 points out
the weakness of Li et al.’s scheme. The proposed scheme is presented in Section 4. We verify the correctness of mutual
authentication using the widely-accepted BAN (Burrows, Abadi,
and Needham) logic in Section 5. The security and performance analysis is presented in Section 6 and 7, respectively.
Finally, conclusion is drawn in Section 8.

2.

Review of Li et al.’s scheme

In 2013, Li et al. (2013) proposed an improvement over Chen
et al.’s (2014) password based user authentication scheme. The
symbols used in the scheme is discussed in Table 1. Their
scheme has four phases similar to Chen et al.’s scheme. The
brief description of Li et al.’s scheme is as follows:
– Registration
– Login

46

journal of information security and applications 23 (2015) 44–53

Step 3. SCU selects a random number α ∈Zq* , and calcu-

Table 1 – Meaning of symbols that used throughout the
paper.
Notation
U
S
A
IDU
SCU
BU
PWU
TU
TS
h(·)
H(·)
⊕
||
Δt

lates the following values: CU = BU h(IDU )PWU (mod p) ,
DU = h(IDU )α (mod p) and MU = h(IDU||CU||DU||TU), where TU is
the timestamp. Then, SC U broadcasts the message
{IDU,DU,MU,TU} to S.

Descryption
User
A trustworthy server
Adversary
Unique identity of U
User personalized smart card
Biometric of U
Unique password of user
Timestamp generated by user
Timestamp generated by S
One-way hash functions
Biohash function
XOR
String concatenation operation
Valid time delay in message transmission

Remark 4. Li et al.’s scheme does not protect anonymity,
where the login message {IDU,DU,MU,TU} includes user’s identity IDU. This may cause identity theft problem, and enable an
adversary to link user’s communication. Additionally, an adversary can know user’s login history. Using the stolen identity
of a user an adversary can also achieve the user’s secret key
as discussed in Remark 3.

2.3.

Step 1. S ensures that IDU is valid and TU′ − TU ≤ ΔT , where
TU′ is the message receiving time and ΔT is the valid time
delay in message transmission. If conditions do not hold,
it terminates the session. Otherwise, it computes the following values: CU′ = h(IDU )x (mod p), MU′ = h(IDU CU′ DU TU ).
Step 2. S verifies MU′ = ? MU . If verification does not hold, it
denies the request. Otherwise, S authenticates U.

– Authentication
– Password change
In the beginning of the system, the server chooses two large
prime numbers p and q such that p = 2q + 1. It also selects the
master secret key x∈Z q and an one way hash function

Step 3. S generates a random number β ∈Zq* and calcu-

h(•) : {0, 1}* → Z*p . Then, the registration, login, and authentica-

lates: VU = h(IDU)β(mod p), then the session key sk = DUβ (mod p)
Step 4. S takes the current timestamp TS and achieves
MS = h(IDU CU′ VU sk TS ) , then transmits the message
{IDU,VU,MS,TS} to U.
Step 5. Upon receiving the message at time TS′ , SCU validates ID U and TS′ − TS ≤ ΔT . If verification succeeds, SC U
computes sk′ = Viα (mod p), MS′ = h(IDU || Ci || Vi || sk′ || Ts ) , and
verifies MS′ = ? MS . If verification fails, the session is terminated. Otherwise, S is authenticated by U.

tion phase executes as follows:

2.1.

Registration phase

To achieve a valid smart card, a user proceeds as follows:
Step 1. U selects identity IDU and password PWU, then
submits IDU and PWU to S via a secure channel.
Step 2. S computes the values AU = h(IDU PWU )PWU (mod p)
and BU = h(IDU )( x + PWU ) (mod p).
Step 3. S embeds the parameters {AU,BU,h(·),p,q} into the smart
card and provides the smart card SCU to U via a secure
channel.
Remark 1. The server does not maintain registered user database. Thus, during registration, the server cannot identify
whether the requested identity is already registered or not. This
enables the repeated registration using same identity.
Remark 2. The user U secret key h(IDU)x depends only on
user’s identity as server master key x is same for all users’ registration. If two different users submit the same identity, they
will get the same key.
Remark 3. Only the identity and server master key is used
in secret key generation, thus in repeated registrations with
the same identity will provide the same key. This shows that
using the stolen identity of a user an adversary can also achieve
the user’s secret key.

2.2.

Login phase

Step 1. U enters his smart card into the card reader, then
inputs IDU and PWU.
Step 2. SCU calculates AU′ = h(IDU PWU )PWU (mod p), then verifies AU′ = ? AU . If verification does not hold, the smart card
terminates the session.

Authentication phase

2.4.

Password change phase

A user can change his password as follows:
Step 1. U enters the smart card SCU into a card reader, then
inputs IDU and PWU with password change request.
Step 2. SCU calculates AU′ = h(IDU PWU )PWU (mod p), and verifies AU′ = ? AU . If verification succeeds, SCU proceeds the
password change request. Then, U inputs new password
PWUnew.
new

Step 3. SC U calculates: AUnew = h(IDU PWUnew )PWU (mod p),
new
U

B

PWUnew

= BU ⋅ h(IDU )

PWU

h( IDU )

(mod p) .

Step 4. Finally, SCU replaces AU with AUnew and BU with BUnew .

3.

Cryptanalysis of Li et al.’s scheme

In this section, we will discuss the flaws of Li et al.’s scheme.

3.1.

Forgery attack

The Li et al.’s scheme does not protect anonymity, and thus
an adversary can achieve identity IDU from the intercepted login
message <IDU,DU,MU,TU>. Using IDU, the adversary can achieve

journal of information security and applications 23 (2015) 44–53

the U’s secret key by registering to the server with IDU. As server
does not store registered users’ identity, thus the server cannot
verify the repeated registration of an identity. This provides opportunity to an adversary A to perform forgery attack by
adopting the following steps:
– A selects a value PW∗, then masquerade as a legitimate
user, and submits user U’s identity IDU with PW∗ to S.
– S computes
AU* = h(IDU || PW * )PW * mod p and
BU* =

47

User agrees upon the key sk′ = h(IDU )e2α (mod P), which an adversary can easily calculate skUA , not the server.

3.4.

Man-in-the middle attack

In this section, we show that how forgery attack causes manin-the middle attack. With the help of gained values CU of U
using forgery attack, an adversary can successfully perform
man-in-the middle attack as follows:

h(IDU )x + PW * mod p , then provides the smart card with parameters 〈 AU* , BU* , h(⋅), p, q〉 to A .

– A

– Upon receiving the smart card, A can achieve U’s secret
key CU as CU = BU* /h(IDU )PW * mod p.
Using the identity IDU and secret key CU of U, an adversary
can perform user impersonation attack, server impersonation attack and man-in-the middle attack.

3.2.

User impersonation attack

In this section, we show that how identity theft causes user
impersonation attack. With the help of gained values IDU and
secret key CU of U, an adversary can impersonate an valid user
in the system as follows:
– A

chooses a random number e ∈ Zq* and calculates

DA = h(IDU )e (mod p) and MA = h(IDU CU DU TA ), where
TA is the current timestamp. Then, masquerade as a legitimate user U and sends the message {IDU, DA , MA , TA }
to S.
– The verification at server end succeeds, as adversary uses
current timestamp. Moreover, when server verifies
MA = ? h(IDU CU DA TA ) , the verification holds. Then,
server selects β ∈Zq* and calculates VU = h(IDU)β(mod p)
and sk = DAβ (mod p). Server also sends the message
{IDU,VU,MS,TS} to U.
– A intercepts the message {IDU,VU,MS,TS} and calculates
the session key sk = (VU)e(mod p)=h(IDU)βe(mod p), as e is adversary generated value.

3.3.

Server impersonation attack

In this section, we show that how identity theft causes server
impersonation attack. With the help of gained values IDU and
secret key CU of U as discussed in Section 3.1, an adversary can
successfully perform server impersonation attack as follows:
– A

intercepts U’s message {ID U ,D U ,M U ,T U }. Then, A

selects a value e1 ∈ Zq* and calculates DA = h(IDU )e1 (mod p)
and MUA = h(IDU CU DU TA ) for current timestamp TUA .
Then, it replaces the message {ID U ,D U ,M U ,T U } with
{IDU, DA , MUA , TUA } , and sends it to S.
– Upon receiving the message {IDU, DA , MUA , TUA } at time
TUA
′ , S ensures that ID U is valid and verifies
TU′A − TUA ≤ ΔT . The verification holds, since the adversary
uses user’s valid identity and current timestamp.
– S computes CU = h(IDU)x(mod p) and then MU′ with the received parameters as follows:

MU′ = h(IDU CU DA

TUA ).

Then, S verifies MU′ = ? MUA , the verification holds. Then, it
calculates. sk = ( DA )β (mod p) = h(IDU )eβ (mod P).
– When S sends the message {IDU,Vi,MS,TS} to U. A
cepts S’s message, selects

inter-

e2 ∈ Zq* and calculates

skUA = ( DU )e2 (mod p) = h(IDU )α e2 (mod P) . A replaces the
original message by {IDU, VA , MSA , TSA } , where TSA is
the current timestamp, VA = h(IDU )e2 (mod p) and
MSA = h(IDU || CU || VA || skUA || TSA ) .
– Upon receiving the message at time TS′ , U validates IDU and
TS′ − TSA ≤ ΔT . The verification holds, since IDU is user’s original identity and TSA is current timestamp. U also computes
sk′ = VAα (mod p) and MS′ = h(IDU || CU || VA || sk′ || TSA ) , then
verifies MS′ = ? MS . The verification holds, since sk′ = skUA .
In this case also use and server agree upon the key, which
are distinct at both ends. However, the adversary achieves both
user and server calculated session the keys skUA and skSA ,
respectively.

4.
Proposed lightweight authentication
scheme

intercepts U’s message {ID U ,D U ,M U ,T U } and selects

e2 ∈ Zq* and calculates skUA = ( DU )e2 (mod p) = h(IDU )α e2 (mod P),
then replaces the message with {IDU, VA , MSA , TSA } , where
TSA is the current timestamp, VA = h(IDU )e2 (mod p) and
MSA = h(IDU || CU || VA || skUA || TSA ) .
– Upon receiving the message at time TS′ , U validates IDU
and TS′ − TSA ≤ ΔT . The verification holds, since ID U is
user’s original identity and TSA is current timestamp.
Then, U computes sk′ = VAα (mod p) = h(IDU )e2α (mod P) and
MS′ = h(IDU CU VA sk′ TSA ) , then verifies MS′ = ? MS . The
verification holds, since sk′ = skUA .

In this section, we present an improved smart card based remote
user password authentication scheme to enhance the security
and efficiency of smart card based authentication mechanism.
The proposed scheme comprises the following phases:
–
–
–
–
–

Registration phase
Login phase
Verification phase
Password change phase
Smart card revocation phase

48

journal of information security and applications 23 (2015) 44–53

Fig. 1 – Summary of registration phase of proposed
scheme.

In the beginning, server selects its secret key x of 1024 bits
to avoid guessing attempts, and an one-way hash function
h(·):{0,1}∗→{0,1}k.

4.1.

Registration phase

When a user wishes to register with the server to get the smart
card. User first selects his/her identity and password, and then
submits mask password with identity to the server. The server
responds with personalized smart card for authorized requests. The summary of the phase is given in Fig. 1.
Step 1. U selects an identity IDU and password PWU, and
keeps both of them secret. U computes NID = h(IDU||b) and
RPW = h(PWU||b||IDU), where b is randomly selected numbers.
Finally, U submits (IDU,NID,RPW) with registration request
to S via secure channel.
Step 2. Upon receiving the U’s registration request, S checks
IDU and NID. If IDU is available in the registered user database, i.e., S asks for new identity. Otherwise, S computes
XU = h(x⊕IDSC⊕NID) and YU = XU⊕RPW, where IDSC is a random
number.
Step 3. S embeds the values {YU,h(·)} into the smart card SCU,
and then provides the smart card to U via secure channel.
Additionally, S maintains user’s record table. S adds (NID,IDSC)
in the active users’ list. Additionally, S stores (IDU⊕h(x),NID)
in the registered users’ list.
Step 4. Upon receiving the smart card, U imprints biometric BU, and then computes V = h(IDU⊕PWU⊕b) and L = b⊕H(BU),
where H(·) is a biohash function. Then, U stores V and L
into SCU. Finally, the smart card stores the parameters
{YU,V,L,h(·)}.

4.2.

Login phase

When user U wish to login to the server, he inserts his smart
card into card reader and inputs the identity and password.
U also imprints his biometric. Upon getting the inputs, SCU verifies the correctness of input. If input verification succeeds, SCU
computes the login message as follows:

Fig. 2 – Summary of authorization mechanism where a
user and server mutually authenticate each other.

4.3.

Verification phase

When server receives user’s login request, verification phase
is brought up. In this mechanism, user and server verify the
correctness of each other. The summary of mutual authentication is given in Fig. 2.
Step 1. Upon receiving the login request <MU,TU> at time
TU′ , S verifies TU′ − TU Δt , where Δt is the valid time delay
in message transmission. If verification does not hold, S terminates the session. Otherwise, S retrieves U’s pseudoidentity NID in the active users’ database by checking the
condition MU=?h(h(x⊕IDSC⊕NID)||TU). If such pseudo-identity
NID does not exist, U’s login attempt is terminated. Otherwise, it is accepted. Then, S sends the message <MS,TS> to
U, where MS = h(h(x⊕IDSC⊕NID)||TU||TS) and TS is the current
timestamp.
Step 2. Upon receiving response message <MS,TS> at time
TS′ , SCU checks TS′ − TS ≤ Δt . If validation does not hold, the
session is terminated. Otherwise, SCU verifies MS=?h(XU||TU||TS).
If verification does not hold, the session is terminated. Otherwise, S is authenticated.

4.4.

Password change phase

The proposed scheme presents user-friendly password change
phase, where the smart card first verifies the legitimacy of
entered parameters, then on the success of verification, it allows
to change the password. The summary of password change
phase is given in Fig. 3.
Step 1. U inserts his smart card into the card reader, and
inputs identity (IDU) and password (PWU). U also imprints
his biometric BU.
Step 2. SC U computes b = L⊕H(B U ), and then verifies
V=?h(IDU⊕PWU⊕b). If verification does not hold, SCU terminates the session. Otherwise, SCU asks for a new password.
Step 3. Upon receiving new password (PW new ), SC U
computes RPW = h(PW U ||b||ID U ), X U = Y U ⊕RPW, RPW new =

Step 1. Computes b = L⊕H(B U ), and then verify
V=?h(IDU⊕PWU⊕b). If verification does not hold, session is
terminated.
Step 2. Computes RPW = h(PWU||b||IDU), XU = YU⊕RPW and
MU = h(XU||TU), where TU is the current timestamp.
Finally, SCU transmits the message <MU,TU> to S.

Fig. 3 – Summary of password change mechanism of
proposed scheme.

journal of information security and applications 23 (2015) 44–53

h(PWnew||b||IDU), Ynew = XU⊕RPWnew, Vnew = h(IDU⊕PWnew⊕b). Then,
SCU replaces YU with Ynew and V with Vnew.

4.5.

Smart card revocation phase

This phase is invoked on the request of lost his smart card’s
revocation. The mechanism works as follows:
Step 1. U chooses a password PWU′ , and random
NID′ = h(IDU || b′ ) and
b′ . U computes
number
RPW ′ = h( PWU′ || b′ || IDU ) . Finally, U submits his new smart
card request with (IDU,NID′,RPW′) to S via secure channel.
Step 2. Upon receiving the request, S computes IDU⊕h(x),
and then checks IDU⊕h(x) in registered users’ database. If
IDU⊕h(x) does not exist. U terminates the request. Otherwise, S retrieves (IDU⊕h(x),NID).
Step 3. S selects a random number IDSC
′ , and then computes XU′ = h( x ⊕ IDSC
′ ⊕ NID′ ) and YU′ = XU′ ⊕ RPW ′ . S
personalizes U’s smart card SCU′ by embedding the security parameters {YU′ , h(⋅)}, and then provides SCU′ to U via
secure way. S stores ( NID′, IDSC
′ ) in active users’ database,
and removes the stored value ( NID, IDSC ) from it.
Step 4. Upon receiving the smart card, U imprints BU, and
then computes V ′ = h(IDU ⊕ PWU′ ⊕ b′ ) and L′ = b′ ⊕ h(BU ) . U
stores V′ and L′ into SCU′ .

5.

Accuracy of mutual authentication

We apply logical postulates of BAN logic (Burrows et al., 1989;
Syverson and Cervesato, 2001) to show the correctness of mutual
authentication between the remote user and server. Using BAN
logic, we show that the user and server determine whether exchanged information is secured and trustworthy against
eavesdropping. It comprises the verification of message origin,
message freshness and the origin’s trustworthiness. In the proposed scheme, the generic form of the messages exchange
between the user and server are as follows:

Message 1. U → S : 〈h( XU || TU ), TU 〉
Message 2. S → U : 〈h( XU || TU || TS ), TS 〉
Subsequently, we translate the message 1 & 2 into idealize form as follows:

Message 1. U → S : (TU )XU , TU
Message 2. S → U : (TU, TS )XU , TS
Recall that in the proposed scheme the user and server share
a common secret key CU. Moreover, the user and server generate fresh timestamps. We make the following assumptions
about the initial state of the protocol:

49

CU )
A4 : S |≡ (U ←⎯⎯
→ S);

CU )
A5 : U |≡ S |≡ (U ←⎯⎯
→ S);

CU )
A5 : S |≡ U |≡ (U ←⎯⎯
→ S);

Lemma 1. The server can correctly verify the authenticity of user’s
message.
Proof. User generates a login message and sends to the server
in order to login to the server. With the message, the server
receives the timestamp with other values which help to prove
the correctness of message source as follows:
S1: According to the message 1, we could get: S⊲(TU)XU,TU.
S2: According to the assumption A4, we apply the message
meaning rule to get: S|≡U|∼TU.
S3: According to the assumption A1, we apply the freshnesspropagation rule to get: S |≡ (TU )XU .
S4: According to the S2 and S3, we apply nonce verification
rule and obtain: S |≡ U |≡ (TU )XU .
S5: According to the assumption A4 and S4, we apply the jurisdiction rule and get: S|≡TU.
The server identify that the used timestamp in the message
is fresh. This proves the correctness of message source.
Lemma 2. The user can correctly verify the server’s response message
authenticity.
Proof. In the proposed scheme, when correctness of user’s
login message holds, the server responds with a message which
includes the server’s timestamp. The user can be able to identify the authenticity of server’s message as follows:
S 6 : According to the message 2, we could obtain:
U⊲(TU,TS)CU,TS.
S7: According to the assumption A3, we apply the message
meaning rule to get: U|≡S|∼TS.
S8: According to the assumption A1, we apply the freshness conjuncatenation rule to get: U |≡ (TU, TS )XU .
S9: According to the S7 and S8, we apply nonce verification
rule to obtain: U |≡ S |≡ (TU, TS )XU .
S11: According to the assumption A1, A3 and S9, we apply the
jurisdiction rule to get: U|≡TS.
This shows that the user can correctly verify the correctness of message source and its freshness.
Theorem 1. The user and server can mutually authenticate each
other.
Proof. According to the Lemma 1, the server can correctly
verify the login message sender authenticity. According to the
Lemma 2, the user can also correctly verify the authenticity
of server’s response. This shows that the user and server can
mutually authenticate each other response.

A1 : U |≡ ( TU );

6.

A2 : S |≡ (TS );

The detailed security analysis of the proposed scheme to verify
‘how the scheme satisfying the security requirements’ is as
follows:

CU )
A3 : U |≡ (U ←⎯⎯
→ S);

Security analysis

50

journal of information security and applications 23 (2015) 44–53

Proposition 1. The proposed scheme protects user anonymity and unlinkability.
Proof. In the proposed scheme, login message <MU,TU> and
server response message <MS,TS> do not includes identity related
information such as IDU or NID(=h(IDU||b)), where MS=?h(XU||TU||TS)
and MU = h(XU||TU). Additionally, MU and MS are different for different sessions as they are the hashed output of timestamp
along with other parameters. Thus, the adversary cannot link
user-server communications. This shows that the proposed
scheme achieves anonymity.
Proposition 2. The proposed scheme withstands off-line password guessing attack.
Proof. An adversary A can try to guess user’s password.
However, A cannot verify the guessed password correctly using
retrieved information L(=b⊕h(B U )) and V(=h(ID U ⊕PW U ⊕b))
from the smart card, and the intercepted information
<MU(=h(NID||CU||TU)),TU> and <MS(=h(NID||CU||TU||TS)),TS> because
of the following facts:
– To verify the guessed password PW∗ with V = h(IDU⊕PWU⊕b),
required the knowledge of user identity IDU and b.
– To verify the guessed password PW∗ with MU = h(XU||TU) or
MS = h(XU||TU||TS), required user’s secret key XU. To retrieve
secret key X U from Y U , ID U and b are needed as X U =
YU⊕h(PWU||b||IDU).
– Neither the smart card nor the transmitted messages (via
public channel) include IDU.
– To compute b from L, user biometric imprint is needed as
b = L⊕H(BU).
It is clear from the above discussion that user identity and
biometric are needed to verify the guess password. As only user
can imprint the biometric, the proposed scheme can efficiently resist password guessing attack.
Proposition 3. The proposed scheme withstand against stolen
smart card attack.
Proof. An adversary can achieve the stored parameters
{YU,L,V,h(·)} from the smart card. Moreover, he can intercept the
login message and achieve <MU = h(XU||TU),TU>. However, A
cannot successfully login to the server using the achieved parameters from the stolen smart card.
– To generate valid and fresh login message 〈 MU*, TA 〉 for the
current timestamp TA , computation of MU* = h( XU || TA ) is
required.
– To compute MU* = h( XU || TA ) , a user secret key XU is needed.
– To achieve XU from YU, knowledge of PWU, IDU and BU are
required as XU = YU⊕h(PWU||b||IDU) and b = L⊕H(BU).
– As PWU, IDU and BU are U’s secret parameters, an adversary
cannot generate valid login message using stolen smart card.
The above discussion shows that only authorized user with
identity and password can generate a valid login message using
the smart card. This shows that the proposed scheme resists
stolen smart card attack.
Proposition 4. The proposed scheme is efficient to resist stolen
verifier attacks.

Proof. In the proposed scheme, the server does not store
user’s password. Instead of storing user identity, server stores
masked identity, i.e., IDU⊕h(x). To retrieve IDU from IDU⊕h(x),
server master key is needed. This shows that an adversary
cannot retrieve users’ credentials from the server database.
Proposition 5. The proposed scheme forbids replay attack.
Proof. Time stamp are consider to be the counter measure
to resist the replay attack. The proposed scheme adopts timestamp as a counter measure to resist replay attack. However,
an adversary A can try to perform replay attack by replacing the timestamp in login message, in proposed scheme this
will not succeed due to following facts:
– A replay the previously stored message, this attempts
will not succeeds, as the participants verify the message
freshness using timestamp.
– A can try to replace the old message <M U ,T U > with
〈 MU, TA 〉 for current timestamp TA . However, the receiver can verify this attempts using the condition
MU=?h(XU||TU).
– The adversary may try to replace <MU,TU> with 〈 MA , TA 〉 ,
where MU = h( XU || TA ) for current timestamp TA . To retrieve XU from YU, user secret credentials IDU, BU and PWU
are needed, which only user can input.
The above discussion shows that proposed scheme resist
replay attack.
Proposition 6. The proposed scheme resists forgery attack.
Proof. In the proposed scheme, the server generates different secret keys for reprehended requests of user for smart card.
So, in case if an adversary would like to use NID to acquire user
secret key XU, the attempt will not succeed as XU = h(x⊕IDSC⊕NID)
for randomly generated IDSC. As IDSC is randomly generated, for
same NID, XU will be different. Moreover, in the proposed
scheme, the user’s identity is secret, which cannot be achieved
by an adversary as user neither transmits nor stores the identity. The secrecy of identity and use of random values in user
secret key computation, resist forgery attack.
Proposition 7. The proposed scheme is efficient to resist userimpersonation, server impersonation and man-in-the middle
attacks.
Proof. An active adversary A may try to intercepts the communication between the user and server. However, the proposed
scheme efficiently resists active attacks on public channel.
– A may try to login to the server by impersonation the
user. However, to generate a valid login message 〈 MA , TA 〉
for current timestamp TA , U’s secret key XU is needed as
MA = h( XU || TA ) .
– A may try to masquerade as a valid server to impersonate the server. In this attempt, A try to respond to login
attempt by intercepting user login message <M U ,T U >.
However, to generate response message 〈 MA , TC 〉 for current
timestamp T C , user secret key X U is needed as
MA = h( XU || TU || TC ) .
– A may try to activate man-in-the middle attack.
However, to modified user and server messages <MU,TU> and

51

journal of information security and applications 23 (2015) 44–53

Table 2 – Comparison of the proposed scheme with related schemes for different security attributes.
Security attributes

Xu et al. (2009)

Song (2010)

Sood et al. (2010)

Chen et al. (2014)

Li et al. (2013)

Ours

Insider attack
Off-line password guessing
User impersonation attack
Server impersonation attack
Man-in-the middle attack
Replay attack
Mutual authentication
Efficient login phase
Efficiently password update

✕
✕
✕
✓
✓
✓
✓
✕
✕

✕
✕
✓
✓
✓
✓
✓
✕
✕

✕
✕
✓
✕
✓
✓
✕
✕
✕

✕
✕
✓
✓
✓
✓
✓
✕
✕

✕
✕
✓
✓
✓
✓
✓
✓
✓

✓
✓
✓
✓
✓
✓
✓
✓
✓

<M S ,T S >, secret key X U is needed as M U = h(X U ||T U ) and
MS = h(XU||TU||TS).
It is clear from the above discussion that user key XU is
needed in order to mount active attacks on public network.
The user key is protected with biometric and password, thus
no one other than the user can extract the stored key from the
smart card.
Proposition 8. The proposed scheme achieves mutual
authentication.
Proof. In mutual authentication mechanism user must prove
its identity to the server and the server must prove its identity to the user. In proposed scheme, user and server both verify
the authenticity of each other. To achieve it, server and user
verify MU=?h(XU||TU) and MS=?h(XU||TU||TS), respectively. Since both
values MU and MS are the hashed output of secret key XU along
with timestamp, therefore no unauthorized party can replay,
or construct MU or MS. Thus, only an authorized participant can
generate MU and MS. This shows that the server and user can
correctly verify the authenticity of each other.

7.

Performance analysis

In Table 2, we discuss the desirable security of proposed scheme
with relevant schemes, namely, Xu et al.’s scheme (2009), Song’s
scheme (2010), Sood et al.’s scheme (2010) and Chen et al.’s
scheme (2014). In Table 2, notation ‘✕’ is used if scheme does
not attains the property and ‘✓’ is used if scheme satisfies
attribute.
It is clear from Table 2 that Xu et al.’s scheme (2009), Song’s
scheme (2010), Sood et al.’s scheme (2010) and Chen et al.’s
scheme (2014) do not present efficient login and password
change phase. Additionally, these schemes do not support userfriendly password update environment, where an authorized
user can change his password without server assistance. Sood
et al.’s scheme (2010) does not support mutual authentication. It is also clear that Xu et al.’s scheme (2009), Song’s scheme
(2010), Sood et al.’s scheme (2010), Chen et al.’s scheme (2014)
and Li et al.’s scheme (2013) are vulnerable to off-line password guessing attack and insider attack. It is also noted that
a valid user cannot recover his/her lost smart card in (Xu et al.,
2009; Song, 2010; Sood et al., 2010; Chen et al., 2014; Li et al.,
2013; Islam, 2014). As smart card based authentication schemes
are adopted for may real life application such as banking, which

support smart card revocation. Therefore, these schemes (Xu
et al., 2009; Sood et al., 2010; Song, 2010; Chen et al., 2014; Li
et al., 2013) cannot be adopted for real life applications. On the
contrary, the proposed scheme supports all desirable security attributes including password update and session key
agreement. It protects privacy and supports smart card
revocation.
We compare the performance on the basis of user-side computation overhead in Table 5 of authorization process (login
phase and authentication phase) as the computation power
of user is almost negligible compare to server. Thus, it is important to reduce user-side computation overhead. An efficient
authentication protocol should require less computation on
user-side. Moreover, registration process is one-time mechanism, we discuss it separately in Table 4. The password update
mechanism should be user friendly where a user can update
his password without server assistance. We discuss the computation cost requirement for password update in Table 6. The
meaning of notations used in the computation cost comparison is given in Table 3.
In Table 7, we have compared the communication cost of
our scheme with other related schemes, namely, Xu et al.’s
scheme (2009), Song’s scheme (2010), Sood et al.’s scheme (2010),
Chen et al.’s scheme (2014), Li et al.’s scheme (2013) and Islam’s
scheme (2014) for the login and verification phases. In Table

Table 3 – Notation used in computation cost
comparison.
Symbol
Th
TE
TM
TS

Time complexity
Hash function
Exponential operation
Multiplication/Division operation
Symmetric key encryption/decryption

Table 4 – Computation cost required in registration of a
user and in the password update phase.
Schemes╱Overhead

Registration phase

Xu et al.’s scheme (2009)
Song’s scheme (2010)
Sood et al.’s scheme (2010)
Chen et al.’s scheme (2014)
Li et al.s’ scheme (2013)
Islam’s scheme (2014)
Proposed scheme

2Th + 2TE
2Th + TE
2Th + 2TE
Th + TE
2Th + 2TE
2Th + 1TE
6Th

52

journal of information security and applications 23 (2015) 44–53

Table 5 – User side computation cost comparison with
related schemes of login and verification phases.
Schemes╱User-side overhead

Login & verification

Xu et al.’s scheme (2009)
Song’s scheme (2010)
Sood et al.’s scheme (2010)
Chen et al.’s scheme (2014)
Li et al.’s scheme (2013)
Islam’s scheme (2014)
Proposed scheme

4Th + 2TE
4Th + 1TS
3Th + 2TM + 3TE
3Th + 2TM + 2TE
4Th + 1TM + 4TE
3Th + 3TE
5Th

8, we discussed the required memory in the smart card to store
security parameters. To produce low-cost smart card, storage
requirement should be less. We assume that the hash digest
(output) is 160 bits, if we use SHA-1 hash function (Fips pub
180-1); timestamp is 32 bits; user identity IDi is 160 bits; random
nonce/number is 160 bits. We take 1024-bit prime number for
modulo exponential operations. Then, the proposed scheme
login message {MU,TU} overhead is (160 + 32) =192 bits and the
server’s response message {MS,TS} overhead is (160 + 32) =192
bits. In other words, communication overhead of mutual authentication mechanism of the proposed scheme requires

Table 6 – Computation cost required in registration of a
user and in the password update phase.
Schemes╱Overhead

Password update phase

Xu et al.’s scheme (2009)
Song’s scheme (2010)
Sood et al.’s scheme (2010)
Chen et al.’s scheme (2014)
Li et al.’s scheme (2013)
Islam’s scheme (2014)
Proposed scheme

8Th + 4TE
2Th + 1TS + 1TE
2Th + 1TM + 2TE
6Th + 3TM + 4TE
3Th + 1TM + 4TE
2Th + 1TE
5Th

Table 7 – Communication overhead comparison of
proposed scheme with related schemes.
Schemes

Communication cost

Xu et al.’s scheme (2009)
Song’s scheme (2010)
Sood et al.’s scheme (2010)
Chen et al.’s scheme (2014)
Li et al.’s scheme (2013)
Islam’s scheme (2014)
Proposed scheme

2 messages (2752 bits)
2 messages (864 bits)
1 messages (2400 bits)
2 messages (1728 bits)
2 messages (2752 bits)
2 messages (2592 bits)
2 messages (384 bits)

Table 8 – Storage overhead comparison of proposed
scheme with related schemes.
Schemes

Storage overhead

Xu et al.’s scheme (2009)
Song’s scheme (2010)
Sood et al.’s scheme (2010)
Chen et al.’s scheme (2014)
Li et al.’s scheme (2013)
Islam’s scheme (2014)
Proposed scheme

2368 bits
320 bits
4096 bits
3072 bits
4096 bits
3232 bits
480 bits

(192 + 192) =384. It is clear from Tables 7 and 8 that the proposed scheme is efficient.

8.

Conclusion

We have discussed smart card based authentication schemes.
The discussion indicates that the earlier proposed schemes does
not satisfies desirable security attributes or have higher computation, communication and storage overhead. We have
proposed a remote user authentication scheme with smart card
revocation. The proposed scheme requires the computation of
only hash function and exclusive or operations. The proposed scheme is a lightweight authentication scheme, which
supports user-friendly password update mechanism and smart
card can quickly detect incorrect input. We verify the correctness of mutual authentication using the widely-accepted BAN
(Burrows, Abadi, and Needham) logic. Furthermore, the proposed scheme supports smart card revocation, where an
authorized user can achieve his/her lost smart card without
repeating the registration mechanism again. Considering the
security and performance provided by our scheme, we conclude that our scheme is more appropriate for practical
applications in network security protocols.
REFERENCES

Boyd C, Mathuria A. Protocols for authentication and key
establishment. Springer; 2003.
Burrows M, Abadi M, Needham RM. A logic of authentication.
Proc Royal Soc Lond A Math Phys Sci 1989;426(1871):233–71.
Chang C-C, Wu T-C. Remote password authentication with smart
cards. IEE Proc – Comp Digital Tech 1991;138(3):165–8.
Chen B-L, Kuo W-C, Wuu L-C. Robust smart-card-based remote
user password authentication scheme. Int J Commun Sys
2014;27(2):377–89.
Darwish M, Ouda A, Capretz LF. A cloud-based secure
authentication (csa) protocol suite for defense against denial
of service (dos) attacks. J Inf Secur Appl 2015;20:90–8.
doi:10.1016/j.jisa.2014.12.001.
Eisenbarth T, Kasper T, Moradi A, Paar C, Salmasizadeh M,
Shalmani MTM. On the power of power analysis in the real
world: a complete break of the keeloq code hopping scheme.
In: Advances in cryptology–CRYPTO 2008. Springer; 2008. p.
203–20.
Fips pub 180-1, national institute of standards and technology
(nist), u.s. department of commerce, april 1995, accessed:
November 2010.
He D, Wang D. Robust biometrics-based authentication scheme
for multiserver environment. IEEE Sys J 2014;1–8. doi:10.1109/
JSYST.2014.2301517.
Islam S. Design and analysis of an improved smartcard-based
remote user password authentication scheme. Int J Commun
Sys 2014;1–12. doi:10.1002/dac.2793.
Kalra S, Sood SK. Advanced password based authentication
scheme for wireless sensor networks. J Inf Secur Appl
2015;20:37–46. doi:10.1016/j.jisa.2014.10.008.
Karuppiah M, Saravanan R. A secure remote user mutual
authentication scheme using smart cards. J Inf Secur Appl
2014;19(4):282–94.
Kim TH, Kim C, Park I. Side channel analysis attacks using am
demodulation on commercial smart cards with seed. J Sys
Softw 2012;85(12):2899–908.

journal of information security and applications 23 (2015) 44–53

Kocher P, Jaffe J, Jun B. Differential power analysis. In: Advances
in cryptologyCRYPTO99. Springer; 1999. p. 388–97.
Kuo W-C, Wei H-J, Cheng J-C. An efficient and secure anonymous
mobility network authentication scheme. J Inf Secur Appl
2014;19(1):18–24.
Lee N-Y, Chiu Y-C. Improved remote authentication scheme with
smart card. Comput Stand Interfaces 2005;27(2):177–80.
Lee S-W, Kim H-S, Yoo K-Y. Improvement of chien et al. ’s remote
user authentication scheme using smart cards. Comput Stand
Interfaces 2005;27(2):181–3.
Li X, Niu J, Khurram Khan M, Liao J. An enhanced smart card
based remote user password authentication scheme. J Netw
Comput Appl 2013;36(5):1365–71.
Ma C-G, Wang D, Zhao S-D. Security flaws in two improved
remote user authentication schemes using smart cards. Int J
Commun Sys 2014;27(10):2215–27.
T Maitra, Cryptanalysis of a secure remote user authentication
scheme using smart cards, arXiv preprint arXiv:1502.04820.
Messerges TS, Dabbish EA, Sloan RH. Examining smart-card
security under the threat of power analysis attacks. Comput
IEEE Trans on 2002;51(5):541–52.
Mishra D, Mukhopadhyay S. Cryptanalysis of pairing-free
identity-based authenticated key agreement protocols,
information systems security. LNCS 2013;8303:247–54.
Nohl K, Evans D, Starbug S, Plötz H. Reverse-engineering a
cryptographic rfid tag. In: vol. 28. USENIX security
symposium. 2008.

53

Song R. Advanced smart card based password authentication
protocol. Comput Stand Interfaces 2010;32(5):321–5.
Sood SK, Sarje AK, Singh K. An improvement of xu et al.’s
authentication scheme using smart cards. In: Proceedings of
the third annual ACM Bangalore conference. ACM; 2010. p.
1–15.
Syverson P, Cervesato I. The logic of authentication protocols. In:
Foundations of security analysis and design. Springer; 2001. p.
63–137.
Wang D, Wang P. On the anonymity of two-factor authentication
schemes for wireless sensor networks: attacks, principle and
solutions. Comput Netw 2014;73:41–57.
Wang D, Wang P. Understanding security failures of two-factor
authentication schemes for real-time applications in
hierarchical wireless sensor networks. Ad Hoc Netw
2014;20:1–15.
Wang D, Ma C-g, Gu D-l, Cui Z-s. Cryptanalysis of two dynamic
id-based remote user authentication schemes for multiserver architecture. In: Network and system security.
Springer; 2012. p. 462–75.
Wang D, He D, Wang P, Chu C. Anonymous two-factor
authentication in distributed systems: certain goals are
beyond attainment. IEEE Trans Dependable Secure Computing
2014;1–14. doi:10.1109/TDSC.2014.2355850.
Xu J, Zhu W-T, Feng D-G. An improved smart card based
password authentication scheme with provable security.
Comput Stand Interfaces 2009;31(4):723–8.

